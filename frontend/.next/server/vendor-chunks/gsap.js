/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/gsap";
exports.ids = ["vendor-chunks/gsap"];
exports.modules = {

/***/ "./node_modules/gsap/ScrambleTextPlugin.js":
/*!*************************************************!*\
  !*** ./node_modules/gsap/ScrambleTextPlugin.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ScrambleTextPlugin: () => (/* binding */ ScrambleTextPlugin),\n/* harmony export */   \"default\": () => (/* binding */ ScrambleTextPlugin)\n/* harmony export */ });\n/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ \"./node_modules/gsap/utils/strings.js\");\n/*!\n * ScrambleTextPlugin 3.13.0\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ \nvar CharSet = /*#__PURE__*/ function() {\n    function CharSet(chars) {\n        this.chars = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(chars);\n        this.sets = [];\n        this.length = 50;\n        for(var i = 0; i < 20; i++){\n            this.sets[i] = _scrambleText(80, this.chars); //we create 20 strings that are 80 characters long, randomly chosen and pack them into an array. We then randomly choose the scrambled text from this array in order to greatly improve efficiency compared to creating new randomized text from scratch each and every time it's needed. This is a simple lookup whereas the other technique requires looping through as many times as there are characters needed, and calling Math.random() each time through the loop, building the string, etc.\n        }\n    }\n    var _proto = CharSet.prototype;\n    _proto.grow = function grow(newLength) {\n        //if we encounter a tween that has more than 80 characters, we'll need to add to the character sets accordingly. Once it's cached, it'll only need to grow again if we exceed that new length. Again, this is an efficiency tactic.\n        for(var i = 0; i < 20; i++){\n            this.sets[i] += _scrambleText(newLength - this.length, this.chars);\n        }\n        this.length = newLength;\n    };\n    return CharSet;\n}();\nvar gsap, _coreInitted, _getGSAP = function _getGSAP() {\n    return gsap ||  false && 0;\n}, _bonusValidated = 1, //<name>ScrambleTextPlugin</name>\n_spacesExp = /\\s+/g, _scrambleText = function _scrambleText(length, chars) {\n    var l = chars.length, s = \"\";\n    while(--length > -1){\n        s += chars[~~(Math.random() * l)];\n    }\n    return s;\n}, _upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", _lower = _upper.toLowerCase(), _charsLookup = {\n    upperCase: new CharSet(_upper),\n    lowerCase: new CharSet(_lower),\n    upperAndLowerCase: new CharSet(_upper + _lower)\n}, _initCore = function _initCore() {\n    _coreInitted = gsap = _getGSAP();\n};\nvar ScrambleTextPlugin = {\n    version: \"3.13.0\",\n    name: \"scrambleText\",\n    register: function register(core, Plugin, propTween) {\n        gsap = core;\n        _initCore();\n    },\n    init: function init(target, value, tween, index, targets) {\n        _coreInitted || _initCore();\n        this.prop = \"innerHTML\" in target ? \"innerHTML\" : \"textContent\" in target ? \"textContent\" : 0; // SVG text in IE doesn't have innerHTML, but it does have textContent.\n        if (!this.prop) {\n            return;\n        }\n        this.target = target;\n        if (typeof value !== \"object\") {\n            value = {\n                text: value\n            };\n        }\n        var text = value.text || value.value || \"\", trim = value.trim !== false, data = this, delim, maxLength, charset, splitByChars;\n        data.delimiter = delim = value.delimiter || \"\";\n        data.original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)((0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText)(target).replace(_spacesExp, \" \").split(\"&nbsp;\").join(\"\"), delim, trim);\n        if (text === \"{original}\" || text === true || text == null) {\n            text = data.original.join(delim);\n        }\n        data.text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)((text || \"\").replace(_spacesExp, \" \"), delim, trim);\n        data.hasClass = !!(value.newClass || value.oldClass);\n        data.newClass = value.newClass;\n        data.oldClass = value.oldClass;\n        splitByChars = delim === \"\";\n        data.textHasEmoji = splitByChars && !!data.text.emoji;\n        data.charsHaveEmoji = !!value.chars && !!(0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(value.chars).emoji;\n        data.length = splitByChars ? data.original.length : data.original.join(delim).length;\n        data.lengthDif = (splitByChars ? data.text.length : data.text.join(delim).length) - data.length;\n        data.fillChar = value.fillChar || value.chars && ~value.chars.indexOf(\" \") ? \"&nbsp;\" : \"\";\n        data.charSet = charset = _charsLookup[value.chars || \"upperCase\"] || new CharSet(value.chars);\n        data.speed = 0.05 / (value.speed || 1);\n        data.prevScrambleTime = 0;\n        data.setIndex = Math.random() * 20 | 0;\n        maxLength = data.length + Math.max(data.lengthDif, 0);\n        if (maxLength > charset.length) {\n            charset.grow(maxLength);\n        }\n        data.chars = charset.sets[data.setIndex];\n        data.revealDelay = value.revealDelay || 0;\n        data.tweenLength = value.tweenLength !== false;\n        data.tween = tween;\n        data.rightToLeft = !!value.rightToLeft;\n        data._props.push(\"scrambleText\", \"text\");\n        return _bonusValidated;\n    },\n    render: function render(ratio, data) {\n        var target = data.target, prop = data.prop, text = data.text, delimiter = data.delimiter, tween = data.tween, prevScrambleTime = data.prevScrambleTime, revealDelay = data.revealDelay, setIndex = data.setIndex, chars = data.chars, charSet = data.charSet, length = data.length, textHasEmoji = data.textHasEmoji, charsHaveEmoji = data.charsHaveEmoji, lengthDif = data.lengthDif, tweenLength = data.tweenLength, oldClass = data.oldClass, newClass = data.newClass, rightToLeft = data.rightToLeft, fillChar = data.fillChar, speed = data.speed, original = data.original, hasClass = data.hasClass, l = text.length, time = tween._time, timeDif = time - prevScrambleTime, i, i2, startText, endText, applyNew, applyOld, str, startClass, endClass, position, r;\n        if (revealDelay) {\n            if (tween._from) {\n                time = tween._dur - time; //invert the time for from() tweens\n            }\n            ratio = time === 0 ? 0 : time < revealDelay ? 0.000001 : time === tween._dur ? 1 : tween._ease((time - revealDelay) / (tween._dur - revealDelay));\n        }\n        if (ratio < 0) {\n            ratio = 0;\n        } else if (ratio > 1) {\n            ratio = 1;\n        }\n        if (rightToLeft) {\n            ratio = 1 - ratio;\n        }\n        i = ~~(ratio * l + 0.5);\n        if (ratio) {\n            if (timeDif > speed || timeDif < -speed) {\n                data.setIndex = setIndex = (setIndex + (Math.random() * 19 | 0)) % 20;\n                data.chars = charSet.sets[setIndex];\n                data.prevScrambleTime += timeDif;\n            }\n            endText = chars;\n        } else {\n            endText = original.join(delimiter);\n        }\n        r = tween._from ? ratio : 1 - ratio;\n        position = length + (tweenLength ? tween._from ? r * r * r : 1 - r * r * r : 1) * lengthDif;\n        if (rightToLeft) {\n            if (ratio === 1 && (tween._from || tween.data === \"isFromStart\")) {\n                //special case for from() tweens\n                startText = \"\";\n                endText = original.join(delimiter);\n            } else {\n                str = text.slice(i).join(delimiter);\n                if (charsHaveEmoji) {\n                    startText = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(endText).slice(0, position - (textHasEmoji ? (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(str) : str).length + 0.5 | 0).join(\"\");\n                } else {\n                    startText = endText.substr(0, position - (textHasEmoji ? (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(str) : str).length + 0.5 | 0);\n                }\n                endText = str;\n            }\n        } else {\n            startText = text.slice(0, i).join(delimiter);\n            i2 = (textHasEmoji ? (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(startText) : startText).length;\n            if (charsHaveEmoji) {\n                endText = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit)(endText).slice(i2, position + 0.5 | 0).join(\"\");\n            } else {\n                endText = endText.substr(i2, position - i2 + 0.5 | 0);\n            }\n        }\n        if (hasClass) {\n            startClass = rightToLeft ? oldClass : newClass;\n            endClass = rightToLeft ? newClass : oldClass;\n            applyNew = startClass && i !== 0;\n            applyOld = endClass && i !== l;\n            str = (applyNew ? \"<span class='\" + startClass + \"'>\" : \"\") + startText + (applyNew ? \"</span>\" : \"\") + (applyOld ? \"<span class='\" + endClass + \"'>\" : \"\") + delimiter + endText + (applyOld ? \"</span>\" : \"\");\n        } else {\n            str = startText + delimiter + endText;\n        }\n        target[prop] = fillChar === \"&nbsp;\" && ~str.indexOf(\"  \") ? str.split(\"  \").join(\"&nbsp;&nbsp;\") : str;\n    }\n};\nScrambleTextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;\nScrambleTextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;\n_getGSAP() && gsap.registerPlugin(ScrambleTextPlugin);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LGNBQWMsQ0FBQ2U7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovL2ludGVncmF0aW9uLW1vZHVsLWFwYXJhdC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9nc2FwL1NjcmFtYmxlVGV4dFBsdWdpbi5qcz8xMTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogU2NyYW1ibGVUZXh0UGx1Z2luIDMuMTMuMFxuICogaHR0cHM6Ly9nc2FwLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3NhcC5jb20vc3RhbmRhcmQtbGljZW5zZVxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZW1vamlTYWZlU3BsaXQsIGdldFRleHQgfSBmcm9tIFwiLi91dGlscy9zdHJpbmdzLmpzXCI7XG5cbnZhciBDaGFyU2V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ2hhclNldChjaGFycykge1xuICAgIHRoaXMuY2hhcnMgPSBlbW9qaVNhZmVTcGxpdChjaGFycyk7XG4gICAgdGhpcy5zZXRzID0gW107XG4gICAgdGhpcy5sZW5ndGggPSA1MDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgdGhpcy5zZXRzW2ldID0gX3NjcmFtYmxlVGV4dCg4MCwgdGhpcy5jaGFycyk7IC8vd2UgY3JlYXRlIDIwIHN0cmluZ3MgdGhhdCBhcmUgODAgY2hhcmFjdGVycyBsb25nLCByYW5kb21seSBjaG9zZW4gYW5kIHBhY2sgdGhlbSBpbnRvIGFuIGFycmF5LiBXZSB0aGVuIHJhbmRvbWx5IGNob29zZSB0aGUgc2NyYW1ibGVkIHRleHQgZnJvbSB0aGlzIGFycmF5IGluIG9yZGVyIHRvIGdyZWF0bHkgaW1wcm92ZSBlZmZpY2llbmN5IGNvbXBhcmVkIHRvIGNyZWF0aW5nIG5ldyByYW5kb21pemVkIHRleHQgZnJvbSBzY3JhdGNoIGVhY2ggYW5kIGV2ZXJ5IHRpbWUgaXQncyBuZWVkZWQuIFRoaXMgaXMgYSBzaW1wbGUgbG9va3VwIHdoZXJlYXMgdGhlIG90aGVyIHRlY2huaXF1ZSByZXF1aXJlcyBsb29waW5nIHRocm91Z2ggYXMgbWFueSB0aW1lcyBhcyB0aGVyZSBhcmUgY2hhcmFjdGVycyBuZWVkZWQsIGFuZCBjYWxsaW5nIE1hdGgucmFuZG9tKCkgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIGJ1aWxkaW5nIHRoZSBzdHJpbmcsIGV0Yy5cbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ2hhclNldC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdyb3cgPSBmdW5jdGlvbiBncm93KG5ld0xlbmd0aCkge1xuICAgIC8vaWYgd2UgZW5jb3VudGVyIGEgdHdlZW4gdGhhdCBoYXMgbW9yZSB0aGFuIDgwIGNoYXJhY3RlcnMsIHdlJ2xsIG5lZWQgdG8gYWRkIHRvIHRoZSBjaGFyYWN0ZXIgc2V0cyBhY2NvcmRpbmdseS4gT25jZSBpdCdzIGNhY2hlZCwgaXQnbGwgb25seSBuZWVkIHRvIGdyb3cgYWdhaW4gaWYgd2UgZXhjZWVkIHRoYXQgbmV3IGxlbmd0aC4gQWdhaW4sIHRoaXMgaXMgYW4gZWZmaWNpZW5jeSB0YWN0aWMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICB0aGlzLnNldHNbaV0gKz0gX3NjcmFtYmxlVGV4dChuZXdMZW5ndGggLSB0aGlzLmxlbmd0aCwgdGhpcy5jaGFycyk7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBuZXdMZW5ndGg7XG4gIH07XG5cbiAgcmV0dXJuIENoYXJTZXQ7XG59KCk7XG5cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2JvbnVzVmFsaWRhdGVkID0gMSxcbiAgICAvLzxuYW1lPlNjcmFtYmxlVGV4dFBsdWdpbjwvbmFtZT5cbl9zcGFjZXNFeHAgPSAvXFxzKy9nLFxuICAgIF9zY3JhbWJsZVRleHQgPSBmdW5jdGlvbiBfc2NyYW1ibGVUZXh0KGxlbmd0aCwgY2hhcnMpIHtcbiAgdmFyIGwgPSBjaGFycy5sZW5ndGgsXG4gICAgICBzID0gXCJcIjtcblxuICB3aGlsZSAoLS1sZW5ndGggPiAtMSkge1xuICAgIHMgKz0gY2hhcnNbfn4oTWF0aC5yYW5kb20oKSAqIGwpXTtcbiAgfVxuXG4gIHJldHVybiBzO1xufSxcbiAgICBfdXBwZXIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIsXG4gICAgX2xvd2VyID0gX3VwcGVyLnRvTG93ZXJDYXNlKCksXG4gICAgX2NoYXJzTG9va3VwID0ge1xuICB1cHBlckNhc2U6IG5ldyBDaGFyU2V0KF91cHBlciksXG4gIGxvd2VyQ2FzZTogbmV3IENoYXJTZXQoX2xvd2VyKSxcbiAgdXBwZXJBbmRMb3dlckNhc2U6IG5ldyBDaGFyU2V0KF91cHBlciArIF9sb3dlcilcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBfY29yZUluaXR0ZWQgPSBnc2FwID0gX2dldEdTQVAoKTtcbn07XG5cbmV4cG9ydCB2YXIgU2NyYW1ibGVUZXh0UGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuMTMuMFwiLFxuICBuYW1lOiBcInNjcmFtYmxlVGV4dFwiLFxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSwgUGx1Z2luLCBwcm9wVHdlZW4pIHtcbiAgICBnc2FwID0gY29yZTtcblxuICAgIF9pbml0Q29yZSgpO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcbiAgICB0aGlzLnByb3AgPSBcImlubmVySFRNTFwiIGluIHRhcmdldCA/IFwiaW5uZXJIVE1MXCIgOiBcInRleHRDb250ZW50XCIgaW4gdGFyZ2V0ID8gXCJ0ZXh0Q29udGVudFwiIDogMDsgLy8gU1ZHIHRleHQgaW4gSUUgZG9lc24ndCBoYXZlIGlubmVySFRNTCwgYnV0IGl0IGRvZXMgaGF2ZSB0ZXh0Q29udGVudC5cblxuICAgIGlmICghdGhpcy5wcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB2YWx1ZSA9IHtcbiAgICAgICAgdGV4dDogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRleHQgPSB2YWx1ZS50ZXh0IHx8IHZhbHVlLnZhbHVlIHx8IFwiXCIsXG4gICAgICAgIHRyaW0gPSB2YWx1ZS50cmltICE9PSBmYWxzZSxcbiAgICAgICAgZGF0YSA9IHRoaXMsXG4gICAgICAgIGRlbGltLFxuICAgICAgICBtYXhMZW5ndGgsXG4gICAgICAgIGNoYXJzZXQsXG4gICAgICAgIHNwbGl0QnlDaGFycztcbiAgICBkYXRhLmRlbGltaXRlciA9IGRlbGltID0gdmFsdWUuZGVsaW1pdGVyIHx8IFwiXCI7XG4gICAgZGF0YS5vcmlnaW5hbCA9IGVtb2ppU2FmZVNwbGl0KGdldFRleHQodGFyZ2V0KS5yZXBsYWNlKF9zcGFjZXNFeHAsIFwiIFwiKS5zcGxpdChcIiZuYnNwO1wiKS5qb2luKFwiXCIpLCBkZWxpbSwgdHJpbSk7XG5cbiAgICBpZiAodGV4dCA9PT0gXCJ7b3JpZ2luYWx9XCIgfHwgdGV4dCA9PT0gdHJ1ZSB8fCB0ZXh0ID09IG51bGwpIHtcbiAgICAgIHRleHQgPSBkYXRhLm9yaWdpbmFsLmpvaW4oZGVsaW0pO1xuICAgIH1cblxuICAgIGRhdGEudGV4dCA9IGVtb2ppU2FmZVNwbGl0KCh0ZXh0IHx8IFwiXCIpLnJlcGxhY2UoX3NwYWNlc0V4cCwgXCIgXCIpLCBkZWxpbSwgdHJpbSk7XG4gICAgZGF0YS5oYXNDbGFzcyA9ICEhKHZhbHVlLm5ld0NsYXNzIHx8IHZhbHVlLm9sZENsYXNzKTtcbiAgICBkYXRhLm5ld0NsYXNzID0gdmFsdWUubmV3Q2xhc3M7XG4gICAgZGF0YS5vbGRDbGFzcyA9IHZhbHVlLm9sZENsYXNzO1xuICAgIHNwbGl0QnlDaGFycyA9IGRlbGltID09PSBcIlwiO1xuICAgIGRhdGEudGV4dEhhc0Vtb2ppID0gc3BsaXRCeUNoYXJzICYmICEhZGF0YS50ZXh0LmVtb2ppO1xuICAgIGRhdGEuY2hhcnNIYXZlRW1vamkgPSAhIXZhbHVlLmNoYXJzICYmICEhZW1vamlTYWZlU3BsaXQodmFsdWUuY2hhcnMpLmVtb2ppO1xuICAgIGRhdGEubGVuZ3RoID0gc3BsaXRCeUNoYXJzID8gZGF0YS5vcmlnaW5hbC5sZW5ndGggOiBkYXRhLm9yaWdpbmFsLmpvaW4oZGVsaW0pLmxlbmd0aDtcbiAgICBkYXRhLmxlbmd0aERpZiA9IChzcGxpdEJ5Q2hhcnMgPyBkYXRhLnRleHQubGVuZ3RoIDogZGF0YS50ZXh0LmpvaW4oZGVsaW0pLmxlbmd0aCkgLSBkYXRhLmxlbmd0aDtcbiAgICBkYXRhLmZpbGxDaGFyID0gdmFsdWUuZmlsbENoYXIgfHwgdmFsdWUuY2hhcnMgJiYgfnZhbHVlLmNoYXJzLmluZGV4T2YoXCIgXCIpID8gXCImbmJzcDtcIiA6IFwiXCI7XG4gICAgZGF0YS5jaGFyU2V0ID0gY2hhcnNldCA9IF9jaGFyc0xvb2t1cFt2YWx1ZS5jaGFycyB8fCBcInVwcGVyQ2FzZVwiXSB8fCBuZXcgQ2hhclNldCh2YWx1ZS5jaGFycyk7XG4gICAgZGF0YS5zcGVlZCA9IDAuMDUgLyAodmFsdWUuc3BlZWQgfHwgMSk7XG4gICAgZGF0YS5wcmV2U2NyYW1ibGVUaW1lID0gMDtcbiAgICBkYXRhLnNldEluZGV4ID0gTWF0aC5yYW5kb20oKSAqIDIwIHwgMDtcbiAgICBtYXhMZW5ndGggPSBkYXRhLmxlbmd0aCArIE1hdGgubWF4KGRhdGEubGVuZ3RoRGlmLCAwKTtcblxuICAgIGlmIChtYXhMZW5ndGggPiBjaGFyc2V0Lmxlbmd0aCkge1xuICAgICAgY2hhcnNldC5ncm93KG1heExlbmd0aCk7XG4gICAgfVxuXG4gICAgZGF0YS5jaGFycyA9IGNoYXJzZXQuc2V0c1tkYXRhLnNldEluZGV4XTtcbiAgICBkYXRhLnJldmVhbERlbGF5ID0gdmFsdWUucmV2ZWFsRGVsYXkgfHwgMDtcbiAgICBkYXRhLnR3ZWVuTGVuZ3RoID0gdmFsdWUudHdlZW5MZW5ndGggIT09IGZhbHNlO1xuICAgIGRhdGEudHdlZW4gPSB0d2VlbjtcbiAgICBkYXRhLnJpZ2h0VG9MZWZ0ID0gISF2YWx1ZS5yaWdodFRvTGVmdDtcblxuICAgIGRhdGEuX3Byb3BzLnB1c2goXCJzY3JhbWJsZVRleHRcIiwgXCJ0ZXh0XCIpO1xuXG4gICAgcmV0dXJuIF9ib251c1ZhbGlkYXRlZDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZGF0YS50YXJnZXQsXG4gICAgICAgIHByb3AgPSBkYXRhLnByb3AsXG4gICAgICAgIHRleHQgPSBkYXRhLnRleHQsXG4gICAgICAgIGRlbGltaXRlciA9IGRhdGEuZGVsaW1pdGVyLFxuICAgICAgICB0d2VlbiA9IGRhdGEudHdlZW4sXG4gICAgICAgIHByZXZTY3JhbWJsZVRpbWUgPSBkYXRhLnByZXZTY3JhbWJsZVRpbWUsXG4gICAgICAgIHJldmVhbERlbGF5ID0gZGF0YS5yZXZlYWxEZWxheSxcbiAgICAgICAgc2V0SW5kZXggPSBkYXRhLnNldEluZGV4LFxuICAgICAgICBjaGFycyA9IGRhdGEuY2hhcnMsXG4gICAgICAgIGNoYXJTZXQgPSBkYXRhLmNoYXJTZXQsXG4gICAgICAgIGxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICB0ZXh0SGFzRW1vamkgPSBkYXRhLnRleHRIYXNFbW9qaSxcbiAgICAgICAgY2hhcnNIYXZlRW1vamkgPSBkYXRhLmNoYXJzSGF2ZUVtb2ppLFxuICAgICAgICBsZW5ndGhEaWYgPSBkYXRhLmxlbmd0aERpZixcbiAgICAgICAgdHdlZW5MZW5ndGggPSBkYXRhLnR3ZWVuTGVuZ3RoLFxuICAgICAgICBvbGRDbGFzcyA9IGRhdGEub2xkQ2xhc3MsXG4gICAgICAgIG5ld0NsYXNzID0gZGF0YS5uZXdDbGFzcyxcbiAgICAgICAgcmlnaHRUb0xlZnQgPSBkYXRhLnJpZ2h0VG9MZWZ0LFxuICAgICAgICBmaWxsQ2hhciA9IGRhdGEuZmlsbENoYXIsXG4gICAgICAgIHNwZWVkID0gZGF0YS5zcGVlZCxcbiAgICAgICAgb3JpZ2luYWwgPSBkYXRhLm9yaWdpbmFsLFxuICAgICAgICBoYXNDbGFzcyA9IGRhdGEuaGFzQ2xhc3MsXG4gICAgICAgIGwgPSB0ZXh0Lmxlbmd0aCxcbiAgICAgICAgdGltZSA9IHR3ZWVuLl90aW1lLFxuICAgICAgICB0aW1lRGlmID0gdGltZSAtIHByZXZTY3JhbWJsZVRpbWUsXG4gICAgICAgIGksXG4gICAgICAgIGkyLFxuICAgICAgICBzdGFydFRleHQsXG4gICAgICAgIGVuZFRleHQsXG4gICAgICAgIGFwcGx5TmV3LFxuICAgICAgICBhcHBseU9sZCxcbiAgICAgICAgc3RyLFxuICAgICAgICBzdGFydENsYXNzLFxuICAgICAgICBlbmRDbGFzcyxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHI7XG5cbiAgICBpZiAocmV2ZWFsRGVsYXkpIHtcbiAgICAgIGlmICh0d2Vlbi5fZnJvbSkge1xuICAgICAgICB0aW1lID0gdHdlZW4uX2R1ciAtIHRpbWU7IC8vaW52ZXJ0IHRoZSB0aW1lIGZvciBmcm9tKCkgdHdlZW5zXG4gICAgICB9XG5cbiAgICAgIHJhdGlvID0gdGltZSA9PT0gMCA/IDAgOiB0aW1lIDwgcmV2ZWFsRGVsYXkgPyAwLjAwMDAwMSA6IHRpbWUgPT09IHR3ZWVuLl9kdXIgPyAxIDogdHdlZW4uX2Vhc2UoKHRpbWUgLSByZXZlYWxEZWxheSkgLyAodHdlZW4uX2R1ciAtIHJldmVhbERlbGF5KSk7XG4gICAgfVxuXG4gICAgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAwO1xuICAgIH0gZWxzZSBpZiAocmF0aW8gPiAxKSB7XG4gICAgICByYXRpbyA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0VG9MZWZ0KSB7XG4gICAgICByYXRpbyA9IDEgLSByYXRpbztcbiAgICB9XG5cbiAgICBpID0gfn4ocmF0aW8gKiBsICsgMC41KTtcblxuICAgIGlmIChyYXRpbykge1xuICAgICAgaWYgKHRpbWVEaWYgPiBzcGVlZCB8fCB0aW1lRGlmIDwgLXNwZWVkKSB7XG4gICAgICAgIGRhdGEuc2V0SW5kZXggPSBzZXRJbmRleCA9IChzZXRJbmRleCArIChNYXRoLnJhbmRvbSgpICogMTkgfCAwKSkgJSAyMDtcbiAgICAgICAgZGF0YS5jaGFycyA9IGNoYXJTZXQuc2V0c1tzZXRJbmRleF07XG4gICAgICAgIGRhdGEucHJldlNjcmFtYmxlVGltZSArPSB0aW1lRGlmO1xuICAgICAgfVxuXG4gICAgICBlbmRUZXh0ID0gY2hhcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZFRleHQgPSBvcmlnaW5hbC5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgciA9IHR3ZWVuLl9mcm9tID8gcmF0aW8gOiAxIC0gcmF0aW87XG4gICAgcG9zaXRpb24gPSBsZW5ndGggKyAodHdlZW5MZW5ndGggPyB0d2Vlbi5fZnJvbSA/IHIgKiByICogciA6IDEgLSByICogciAqIHIgOiAxKSAqIGxlbmd0aERpZjtcblxuICAgIGlmIChyaWdodFRvTGVmdCkge1xuICAgICAgaWYgKHJhdGlvID09PSAxICYmICh0d2Vlbi5fZnJvbSB8fCB0d2Vlbi5kYXRhID09PSBcImlzRnJvbVN0YXJ0XCIpKSB7XG4gICAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciBmcm9tKCkgdHdlZW5zXG4gICAgICAgIHN0YXJ0VGV4dCA9IFwiXCI7XG4gICAgICAgIGVuZFRleHQgPSBvcmlnaW5hbC5qb2luKGRlbGltaXRlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSB0ZXh0LnNsaWNlKGkpLmpvaW4oZGVsaW1pdGVyKTtcblxuICAgICAgICBpZiAoY2hhcnNIYXZlRW1vamkpIHtcbiAgICAgICAgICBzdGFydFRleHQgPSBlbW9qaVNhZmVTcGxpdChlbmRUZXh0KS5zbGljZSgwLCBwb3NpdGlvbiAtICh0ZXh0SGFzRW1vamkgPyBlbW9qaVNhZmVTcGxpdChzdHIpIDogc3RyKS5sZW5ndGggKyAwLjUgfCAwKS5qb2luKFwiXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0VGV4dCA9IGVuZFRleHQuc3Vic3RyKDAsIHBvc2l0aW9uIC0gKHRleHRIYXNFbW9qaSA/IGVtb2ppU2FmZVNwbGl0KHN0cikgOiBzdHIpLmxlbmd0aCArIDAuNSB8IDApO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kVGV4dCA9IHN0cjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRUZXh0ID0gdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcik7XG4gICAgICBpMiA9ICh0ZXh0SGFzRW1vamkgPyBlbW9qaVNhZmVTcGxpdChzdGFydFRleHQpIDogc3RhcnRUZXh0KS5sZW5ndGg7XG5cbiAgICAgIGlmIChjaGFyc0hhdmVFbW9qaSkge1xuICAgICAgICBlbmRUZXh0ID0gZW1vamlTYWZlU3BsaXQoZW5kVGV4dCkuc2xpY2UoaTIsIHBvc2l0aW9uICsgMC41IHwgMCkuam9pbihcIlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFRleHQgPSBlbmRUZXh0LnN1YnN0cihpMiwgcG9zaXRpb24gLSBpMiArIDAuNSB8IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNDbGFzcykge1xuICAgICAgc3RhcnRDbGFzcyA9IHJpZ2h0VG9MZWZ0ID8gb2xkQ2xhc3MgOiBuZXdDbGFzcztcbiAgICAgIGVuZENsYXNzID0gcmlnaHRUb0xlZnQgPyBuZXdDbGFzcyA6IG9sZENsYXNzO1xuICAgICAgYXBwbHlOZXcgPSBzdGFydENsYXNzICYmIGkgIT09IDA7XG4gICAgICBhcHBseU9sZCA9IGVuZENsYXNzICYmIGkgIT09IGw7XG4gICAgICBzdHIgPSAoYXBwbHlOZXcgPyBcIjxzcGFuIGNsYXNzPSdcIiArIHN0YXJ0Q2xhc3MgKyBcIic+XCIgOiBcIlwiKSArIHN0YXJ0VGV4dCArIChhcHBseU5ldyA/IFwiPC9zcGFuPlwiIDogXCJcIikgKyAoYXBwbHlPbGQgPyBcIjxzcGFuIGNsYXNzPSdcIiArIGVuZENsYXNzICsgXCInPlwiIDogXCJcIikgKyBkZWxpbWl0ZXIgKyBlbmRUZXh0ICsgKGFwcGx5T2xkID8gXCI8L3NwYW4+XCIgOiBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gc3RhcnRUZXh0ICsgZGVsaW1pdGVyICsgZW5kVGV4dDtcbiAgICB9XG5cbiAgICB0YXJnZXRbcHJvcF0gPSBmaWxsQ2hhciA9PT0gXCImbmJzcDtcIiAmJiB+c3RyLmluZGV4T2YoXCIgIFwiKSA/IHN0ci5zcGxpdChcIiAgXCIpLmpvaW4oXCImbmJzcDsmbmJzcDtcIikgOiBzdHI7XG4gIH1cbn07XG5TY3JhbWJsZVRleHRQbHVnaW4uZW1vamlTYWZlU3BsaXQgPSBlbW9qaVNhZmVTcGxpdDtcblNjcmFtYmxlVGV4dFBsdWdpbi5nZXRUZXh0ID0gZ2V0VGV4dDtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihTY3JhbWJsZVRleHRQbHVnaW4pO1xuZXhwb3J0IHsgU2NyYW1ibGVUZXh0UGx1Z2luIGFzIGRlZmF1bHQgfTsiXSwibmFtZXMiOlsiZW1vamlTYWZlU3BsaXQiLCJnZXRUZXh0IiwiQ2hhclNldCIsImNoYXJzIiwic2V0cyIsImxlbmd0aCIsImkiLCJfc2NyYW1ibGVUZXh0IiwiX3Byb3RvIiwicHJvdG90eXBlIiwiZ3JvdyIsIm5ld0xlbmd0aCIsImdzYXAiLCJfY29yZUluaXR0ZWQiLCJfZ2V0R1NBUCIsIndpbmRvdyIsInJlZ2lzdGVyUGx1Z2luIiwiX2JvbnVzVmFsaWRhdGVkIiwiX3NwYWNlc0V4cCIsImwiLCJzIiwiTWF0aCIsInJhbmRvbSIsIl91cHBlciIsIl9sb3dlciIsInRvTG93ZXJDYXNlIiwiX2NoYXJzTG9va3VwIiwidXBwZXJDYXNlIiwibG93ZXJDYXNlIiwidXBwZXJBbmRMb3dlckNhc2UiLCJfaW5pdENvcmUiLCJTY3JhbWJsZVRleHRQbHVnaW4iLCJ2ZXJzaW9uIiwibmFtZSIsInJlZ2lzdGVyIiwiY29yZSIsIlBsdWdpbiIsInByb3BUd2VlbiIsImluaXQiLCJ0YXJnZXQiLCJ2YWx1ZSIsInR3ZWVuIiwiaW5kZXgiLCJ0YXJnZXRzIiwicHJvcCIsInRleHQiLCJ0cmltIiwiZGF0YSIsImRlbGltIiwibWF4TGVuZ3RoIiwiY2hhcnNldCIsInNwbGl0QnlDaGFycyIsImRlbGltaXRlciIsIm9yaWdpbmFsIiwicmVwbGFjZSIsInNwbGl0Iiwiam9pbiIsImhhc0NsYXNzIiwibmV3Q2xhc3MiLCJvbGRDbGFzcyIsInRleHRIYXNFbW9qaSIsImVtb2ppIiwiY2hhcnNIYXZlRW1vamkiLCJsZW5ndGhEaWYiLCJmaWxsQ2hhciIsImluZGV4T2YiLCJjaGFyU2V0Iiwic3BlZWQiLCJwcmV2U2NyYW1ibGVUaW1lIiwic2V0SW5kZXgiLCJtYXgiLCJyZXZlYWxEZWxheSIsInR3ZWVuTGVuZ3RoIiwicmlnaHRUb0xlZnQiLCJfcHJvcHMiLCJwdXNoIiwicmVuZGVyIiwicmF0aW8iLCJ0aW1lIiwiX3RpbWUiLCJ0aW1lRGlmIiwiaTIiLCJzdGFydFRleHQiLCJlbmRUZXh0IiwiYXBwbHlOZXciLCJhcHBseU9sZCIsInN0ciIsInN0YXJ0Q2xhc3MiLCJlbmRDbGFzcyIsInBvc2l0aW9uIiwiciIsIl9mcm9tIiwiX2R1ciIsIl9lYXNlIiwic2xpY2UiLCJzdWJzdHIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/gsap/ScrambleTextPlugin.js\n");

/***/ }),

/***/ "./node_modules/gsap/dist/gsap.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/dist/gsap.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function(global, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    function _inheritsLoose(subClass, superClass) {\n        subClass.prototype = Object.create(superClass.prototype);\n        subClass.prototype.constructor = subClass;\n        subClass.__proto__ = superClass;\n    }\n    function _assertThisInitialized(self1) {\n        if (self1 === void 0) {\n            throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        }\n        return self1;\n    }\n    /*!\n   * GSAP 3.13.0\n   * https://gsap.com\n   *\n   * @license Copyright 2008-2025, GreenSock. All rights reserved.\n   * Subject to the terms at https://gsap.com/standard-license\n   * @author: Jack Doyle, jack@greensock.com\n  */ var _config = {\n        autoSleep: 120,\n        force3D: \"auto\",\n        nullTargetWarn: 1,\n        units: {\n            lineHeight: \"\"\n        }\n    }, _defaults = {\n        duration: .5,\n        overwrite: false,\n        delay: 0\n    }, _suppressOverwrites, _reverting, _context, _bigNum = 1e8, _tinyNum = 1 / _bigNum, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt = Math.sqrt, _cos = Math.cos, _sin = Math.sin, _isString = function _isString(value) {\n        return typeof value === \"string\";\n    }, _isFunction = function _isFunction(value) {\n        return typeof value === \"function\";\n    }, _isNumber = function _isNumber(value) {\n        return typeof value === \"number\";\n    }, _isUndefined = function _isUndefined(value) {\n        return typeof value === \"undefined\";\n    }, _isObject = function _isObject(value) {\n        return typeof value === \"object\";\n    }, _isNotFalse = function _isNotFalse(value) {\n        return value !== false;\n    }, _windowExists = function _windowExists() {\n        return \"undefined\" !== \"undefined\";\n    }, _isFuncOrString = function _isFuncOrString(value) {\n        return _isFunction(value) || _isString(value);\n    }, _isTypedArray = typeof ArrayBuffer === \"function\" && ArrayBuffer.isView || function() {}, _isArray = Array.isArray, _strictNumExp = /(?:-?\\.?\\d|\\.)+/gi, _numExp = /[-+=.]*\\d+[.e\\-+]*\\d*[e\\-+]*\\d*/g, _numWithUnitExp = /[-+=.]*\\d+[.e-]*\\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\\d+\\.?\\d*(?:e-|e\\+)?\\d*/gi, _relExp = /[+-]=-?[.\\d]+/, _delimitedValueExp = /[^,'\"\\[\\]\\s]+/gi, _unitExp = /^[+\\-=e\\s\\d]*\\d+[.\\d]*([a-z]*|%)\\s*$/i, _globalTimeline, _win, _coreInitted, _doc, _globals = {}, _installScope = {}, _coreReady, _install = function _install(scope) {\n        return (_installScope = _merge(scope, _globals)) && gsap;\n    }, _missingPlugin = function _missingPlugin(property, value) {\n        return console.warn(\"Invalid property\", property, \"set to\", value, \"Missing plugin? gsap.registerPlugin()\");\n    }, _warn = function _warn(message, suppress) {\n        return !suppress && console.warn(message);\n    }, _addGlobal = function _addGlobal(name, obj) {\n        return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;\n    }, _emptyFunc = function _emptyFunc() {\n        return 0;\n    }, _startAtRevertConfig = {\n        suppressEvents: true,\n        isStart: true,\n        kill: false\n    }, _revertConfigNoKill = {\n        suppressEvents: true,\n        kill: false\n    }, _revertConfig = {\n        suppressEvents: true\n    }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = \"\", _harness = function _harness(targets) {\n        var target = targets[0], harnessPlugin, i;\n        _isObject(target) || _isFunction(target) || (targets = [\n            targets\n        ]);\n        if (!(harnessPlugin = (target._gsap || {}).harness)) {\n            i = _harnessPlugins.length;\n            while(i-- && !_harnessPlugins[i].targetTest(target)){}\n            harnessPlugin = _harnessPlugins[i];\n        }\n        i = targets.length;\n        while(i--){\n            targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);\n        }\n        return targets;\n    }, _getCache = function _getCache(target) {\n        return target._gsap || _harness(toArray(target))[0]._gsap;\n    }, _getProperty = function _getProperty(target, property, v) {\n        return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;\n    }, _forEachName = function _forEachName(names, func) {\n        return (names = names.split(\",\")).forEach(func) || names;\n    }, _round = function _round(value) {\n        return Math.round(value * 100000) / 100000 || 0;\n    }, _roundPrecise = function _roundPrecise(value) {\n        return Math.round(value * 10000000) / 10000000 || 0;\n    }, _parseRelative = function _parseRelative(start, value) {\n        var operator = value.charAt(0), end = parseFloat(value.substr(2));\n        start = parseFloat(start);\n        return operator === \"+\" ? start + end : operator === \"-\" ? start - end : operator === \"*\" ? start * end : start / end;\n    }, _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {\n        var l = toFind.length, i = 0;\n        for(; toSearch.indexOf(toFind[i]) < 0 && ++i < l;){}\n        return i < l;\n    }, _lazyRender = function _lazyRender() {\n        var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;\n        _lazyLookup = {};\n        _lazyTweens.length = 0;\n        for(i = 0; i < l; i++){\n            tween = a[i];\n            tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);\n        }\n    }, _isRevertWorthy = function _isRevertWorthy(animation) {\n        return !!(animation._initted || animation._startAt || animation.add);\n    }, _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {\n        _lazyTweens.length && !_reverting && _lazyRender();\n        animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));\n        _lazyTweens.length && !_reverting && _lazyRender();\n    }, _numericIfPossible = function _numericIfPossible(value) {\n        var n = parseFloat(value);\n        return (n || n === 0) && (value + \"\").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;\n    }, _passThrough = function _passThrough(p) {\n        return p;\n    }, _setDefaults = function _setDefaults(obj, defaults) {\n        for(var p in defaults){\n            p in obj || (obj[p] = defaults[p]);\n        }\n        return obj;\n    }, _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {\n        return function(obj, defaults) {\n            for(var p in defaults){\n                p in obj || p === \"duration\" && excludeDuration || p === \"ease\" || (obj[p] = defaults[p]);\n            }\n        };\n    }, _merge = function _merge(base, toMerge) {\n        for(var p in toMerge){\n            base[p] = toMerge[p];\n        }\n        return base;\n    }, _mergeDeep = function _mergeDeep(base, toMerge) {\n        for(var p in toMerge){\n            p !== \"__proto__\" && p !== \"constructor\" && p !== \"prototype\" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);\n        }\n        return base;\n    }, _copyExcluding = function _copyExcluding(obj, excluding) {\n        var copy = {}, p;\n        for(p in obj){\n            p in excluding || (copy[p] = obj[p]);\n        }\n        return copy;\n    }, _inheritDefaults = function _inheritDefaults(vars) {\n        var parent = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;\n        if (_isNotFalse(vars.inherit)) {\n            while(parent){\n                func(vars, parent.vars.defaults);\n                parent = parent.parent || parent._dp;\n            }\n        }\n        return vars;\n    }, _arraysMatch = function _arraysMatch(a1, a2) {\n        var i = a1.length, match = i === a2.length;\n        while(match && i-- && a1[i] === a2[i]){}\n        return i < 0;\n    }, _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {\n        if (firstProp === void 0) {\n            firstProp = \"_first\";\n        }\n        if (lastProp === void 0) {\n            lastProp = \"_last\";\n        }\n        var prev = parent[lastProp], t;\n        if (sortBy) {\n            t = child[sortBy];\n            while(prev && prev[sortBy] > t){\n                prev = prev._prev;\n            }\n        }\n        if (prev) {\n            child._next = prev._next;\n            prev._next = child;\n        } else {\n            child._next = parent[firstProp];\n            parent[firstProp] = child;\n        }\n        if (child._next) {\n            child._next._prev = child;\n        } else {\n            parent[lastProp] = child;\n        }\n        child._prev = prev;\n        child.parent = child._dp = parent;\n        return child;\n    }, _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {\n        if (firstProp === void 0) {\n            firstProp = \"_first\";\n        }\n        if (lastProp === void 0) {\n            lastProp = \"_last\";\n        }\n        var prev = child._prev, next = child._next;\n        if (prev) {\n            prev._next = next;\n        } else if (parent[firstProp] === child) {\n            parent[firstProp] = next;\n        }\n        if (next) {\n            next._prev = prev;\n        } else if (parent[lastProp] === child) {\n            parent[lastProp] = prev;\n        }\n        child._next = child._prev = child.parent = null;\n    }, _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {\n        child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);\n        child._act = 0;\n    }, _uncache = function _uncache(animation, child) {\n        if (animation && (!child || child._end > animation._dur || child._start < 0)) {\n            var a = animation;\n            while(a){\n                a._dirty = 1;\n                a = a.parent;\n            }\n        }\n        return animation;\n    }, _recacheAncestors = function _recacheAncestors(animation) {\n        var parent = animation.parent;\n        while(parent && parent.parent){\n            parent._dirty = 1;\n            parent.totalDuration();\n            parent = parent.parent;\n        }\n        return animation;\n    }, _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {\n        return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));\n    }, _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {\n        return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);\n    }, _elapsedCycleDuration = function _elapsedCycleDuration(animation) {\n        return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;\n    }, _animationCycle = function _animationCycle(tTime, cycleDuration) {\n        var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));\n        return tTime && whole === tTime ? whole - 1 : whole;\n    }, _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {\n        return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);\n    }, _setEnd = function _setEnd(animation) {\n        return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));\n    }, _alignPlayhead = function _alignPlayhead(animation, totalTime) {\n        var parent = animation._dp;\n        if (parent && parent.smoothChildTiming && animation._ts) {\n            animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));\n            _setEnd(animation);\n            parent._dirty || _uncache(parent, animation);\n        }\n        return animation;\n    }, _postAddChecks = function _postAddChecks(timeline, child) {\n        var t;\n        if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {\n            t = _parentToChildTotalTime(timeline.rawTime(), child);\n            if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {\n                child.render(t, true);\n            }\n        }\n        if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {\n            if (timeline._dur < timeline.duration()) {\n                t = timeline;\n                while(t._dp){\n                    t.rawTime() >= 0 && t.totalTime(t._tTime);\n                    t = t._dp;\n                }\n            }\n            timeline._zTime = -_tinyNum;\n        }\n    }, _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {\n        child.parent && _removeFromParent(child);\n        child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);\n        child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));\n        _addLinkedListItem(timeline, child, \"_first\", \"_last\", timeline._sort ? \"_start\" : 0);\n        _isFromOrFromStart(child) || (timeline._recent = child);\n        skipChecks || _postAddChecks(timeline, child);\n        timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);\n        return timeline;\n    }, _scrollTrigger = function _scrollTrigger(animation, trigger) {\n        return (_globals.ScrollTrigger || _missingPlugin(\"scrollTrigger\", trigger)) && _globals.ScrollTrigger.create(trigger, animation);\n    }, _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {\n        _initTween(tween, time, tTime);\n        if (!tween._initted) {\n            return 1;\n        }\n        if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {\n            _lazyTweens.push(tween);\n            tween._lazy = [\n                tTime,\n                suppressEvents\n            ];\n            return 1;\n        }\n    }, _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {\n        var parent = _ref.parent;\n        return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));\n    }, _isFromOrFromStart = function _isFromOrFromStart(_ref2) {\n        var data = _ref2.data;\n        return data === \"isFromStart\" || data === \"isStart\";\n    }, _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {\n        var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;\n        if (repeatDelay && tween._repeat) {\n            tTime = _clamp(0, tween._tDur, totalTime);\n            iteration = _animationCycle(tTime, repeatDelay);\n            tween._yoyo && iteration & 1 && (ratio = 1 - ratio);\n            if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {\n                prevRatio = 1 - ratio;\n                tween.vars.repeatRefresh && tween._initted && tween.invalidate();\n            }\n        }\n        if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {\n            if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {\n                return;\n            }\n            prevIteration = tween._zTime;\n            tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);\n            suppressEvents || (suppressEvents = totalTime && !prevIteration);\n            tween.ratio = ratio;\n            tween._from && (ratio = 1 - ratio);\n            tween._time = 0;\n            tween._tTime = tTime;\n            pt = tween._pt;\n            while(pt){\n                pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n            totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);\n            tween._onUpdate && !suppressEvents && _callback(tween, \"onUpdate\");\n            tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, \"onRepeat\");\n            if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {\n                ratio && _removeFromParent(tween, 1);\n                if (!suppressEvents && !_reverting) {\n                    _callback(tween, ratio ? \"onComplete\" : \"onReverseComplete\", true);\n                    tween._prom && tween._prom();\n                }\n            }\n        } else if (!tween._zTime) {\n            tween._zTime = totalTime;\n        }\n    }, _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {\n        var child;\n        if (time > prevTime) {\n            child = animation._first;\n            while(child && child._start <= time){\n                if (child.data === \"isPause\" && child._start > prevTime) {\n                    return child;\n                }\n                child = child._next;\n            }\n        } else {\n            child = animation._last;\n            while(child && child._start >= time){\n                if (child.data === \"isPause\" && child._start < prevTime) {\n                    return child;\n                }\n                child = child._prev;\n            }\n        }\n    }, _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {\n        var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;\n        totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);\n        animation._dur = dur;\n        animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);\n        totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);\n        animation.parent && _setEnd(animation);\n        skipUncache || _uncache(animation.parent, animation);\n        return animation;\n    }, _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {\n        return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);\n    }, _zeroPosition = {\n        _start: 0,\n        endTime: _emptyFunc,\n        totalDuration: _emptyFunc\n    }, _parsePosition = function _parsePosition(animation, position, percentAnimation) {\n        var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i, offset, isPercent;\n        if (_isString(position) && (isNaN(position) || position in labels)) {\n            offset = position.charAt(0);\n            isPercent = position.substr(-1) === \"%\";\n            i = position.indexOf(\"=\");\n            if (offset === \"<\" || offset === \">\") {\n                i >= 0 && (position = position.replace(/=/, \"\"));\n                return (offset === \"<\" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);\n            }\n            if (i < 0) {\n                position in labels || (labels[position] = clippedDuration);\n                return labels[position];\n            }\n            offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));\n            if (isPercent && percentAnimation) {\n                offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();\n            }\n            return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;\n        }\n        return position == null ? clippedDuration : +position;\n    }, _createTweenType = function _createTweenType(type, params, timeline) {\n        var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent;\n        isLegacy && (vars.duration = params[1]);\n        vars.parent = timeline;\n        if (type) {\n            irVars = vars;\n            parent = timeline;\n            while(parent && !(\"immediateRender\" in irVars)){\n                irVars = parent.vars.defaults || {};\n                parent = _isNotFalse(parent.vars.inherit) && parent.parent;\n            }\n            vars.immediateRender = _isNotFalse(irVars.immediateRender);\n            type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];\n        }\n        return new Tween(params[0], vars, params[varsIndex + 1]);\n    }, _conditionalReturn = function _conditionalReturn(value, func) {\n        return value || value === 0 ? func(value) : func;\n    }, _clamp = function _clamp(min, max, value) {\n        return value < min ? min : value > max ? max : value;\n    }, getUnit = function getUnit(value, v) {\n        return !_isString(value) || !(v = _unitExp.exec(value)) ? \"\" : v[1];\n    }, clamp = function clamp(min, max, value) {\n        return _conditionalReturn(value, function(v) {\n            return _clamp(min, max, v);\n        });\n    }, _slice = [].slice, _isArrayLike = function _isArrayLike(value, nonEmpty) {\n        return value && _isObject(value) && \"length\" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;\n    }, _flatten = function _flatten(ar, leaveStrings, accumulator) {\n        if (accumulator === void 0) {\n            accumulator = [];\n        }\n        return ar.forEach(function(value) {\n            var _accumulator;\n            return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);\n        }) || accumulator;\n    }, toArray = function toArray(value, scope, leaveStrings) {\n        return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [\n            value\n        ] : [];\n    }, selector = function selector(value) {\n        value = toArray(value)[0] || _warn(\"Invalid scope\") || {};\n        return function(v) {\n            var el = value.current || value.nativeElement || value;\n            return toArray(v, el.querySelectorAll ? el : el === value ? _warn(\"Invalid scope\") || _doc.createElement(\"div\") : value);\n        };\n    }, shuffle = function shuffle(a) {\n        return a.sort(function() {\n            return .5 - Math.random();\n        });\n    }, distribute = function distribute(v) {\n        if (_isFunction(v)) {\n            return v;\n        }\n        var vars = _isObject(v) ? v : {\n            each: v\n        }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;\n        if (_isString(from)) {\n            ratioX = ratioY = ({\n                center: .5,\n                edges: .5,\n                end: 1\n            })[from] || 0;\n        } else if (!isDecimal && ratios) {\n            ratioX = from[0];\n            ratioY = from[1];\n        }\n        return function(i, target, a) {\n            var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;\n            if (!distances) {\n                wrapAt = vars.grid === \"auto\" ? 0 : (vars.grid || [\n                    1,\n                    _bigNum\n                ])[1];\n                if (!wrapAt) {\n                    max = -_bigNum;\n                    while(max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l){}\n                    wrapAt < l && wrapAt--;\n                }\n                distances = cache[l] = [];\n                originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;\n                originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;\n                max = 0;\n                min = _bigNum;\n                for(j = 0; j < l; j++){\n                    x = j % wrapAt - originX;\n                    y = originY - (j / wrapAt | 0);\n                    distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === \"y\" ? y : x);\n                    d > max && (max = d);\n                    d < min && (min = d);\n                }\n                from === \"random\" && shuffle(distances);\n                distances.max = max - min;\n                distances.min = min;\n                distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === \"y\" ? l / wrapAt : wrapAt) || 0) * (from === \"edges\" ? -1 : 1);\n                distances.b = l < 0 ? base - l : base;\n                distances.u = getUnit(vars.amount || vars.each) || 0;\n                ease = ease && l < 0 ? _invertEase(ease) : ease;\n            }\n            l = (distances[i] - distances.min) / distances.max || 0;\n            return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;\n        };\n    }, _roundModifier = function _roundModifier(v) {\n        var p = Math.pow(10, ((v + \"\").split(\".\")[1] || \"\").length);\n        return function(raw) {\n            var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);\n            return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));\n        };\n    }, snap = function snap(snapTo, value) {\n        var isArray = _isArray(snapTo), radius, is2D;\n        if (!isArray && _isObject(snapTo)) {\n            radius = isArray = snapTo.radius || _bigNum;\n            if (snapTo.values) {\n                snapTo = toArray(snapTo.values);\n                if (is2D = !_isNumber(snapTo[0])) {\n                    radius *= radius;\n                }\n            } else {\n                snapTo = _roundModifier(snapTo.increment);\n            }\n        }\n        return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {\n            is2D = snapTo(raw);\n            return Math.abs(is2D - raw) <= radius ? is2D : raw;\n        } : function(raw) {\n            var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;\n            while(i--){\n                if (is2D) {\n                    dx = snapTo[i].x - x;\n                    dy = snapTo[i].y - y;\n                    dx = dx * dx + dy * dy;\n                } else {\n                    dx = Math.abs(snapTo[i] - x);\n                }\n                if (dx < min) {\n                    min = dx;\n                    closest = i;\n                }\n            }\n            closest = !radius || min <= radius ? snapTo[closest] : raw;\n            return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);\n        });\n    }, random = function random(min, max, roundingIncrement, returnFunction) {\n        return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {\n            return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + \"\").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;\n        });\n    }, pipe = function pipe() {\n        for(var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++){\n            functions[_key] = arguments[_key];\n        }\n        return function(value) {\n            return functions.reduce(function(v, f) {\n                return f(v);\n            }, value);\n        };\n    }, unitize = function unitize(func, unit) {\n        return function(value) {\n            return func(parseFloat(value)) + (unit || getUnit(value));\n        };\n    }, normalize = function normalize(min, max, value) {\n        return mapRange(min, max, 0, 1, value);\n    }, _wrapArray = function _wrapArray(a, wrapper, value) {\n        return _conditionalReturn(value, function(index) {\n            return a[~~wrapper(index)];\n        });\n    }, wrap = function wrap(min, max, value) {\n        var range = max - min;\n        return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {\n            return (range + (value - min) % range) % range + min;\n        });\n    }, wrapYoyo = function wrapYoyo(min, max, value) {\n        var range = max - min, total = range * 2;\n        return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {\n            value = (total + (value - min) % total) % total || 0;\n            return min + (value > range ? total - value : value);\n        });\n    }, _replaceRandom = function _replaceRandom(value) {\n        var prev = 0, s = \"\", i, nums, end, isArray;\n        while(~(i = value.indexOf(\"random(\", prev))){\n            end = value.indexOf(\")\", i);\n            isArray = value.charAt(i + 7) === \"[\";\n            nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);\n            s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);\n            prev = end + 1;\n        }\n        return s + value.substr(prev, value.length - prev);\n    }, mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {\n        var inRange = inMax - inMin, outRange = outMax - outMin;\n        return _conditionalReturn(value, function(value) {\n            return outMin + ((value - inMin) / inRange * outRange || 0);\n        });\n    }, interpolate = function interpolate(start, end, progress, mutate) {\n        var func = isNaN(start + end) ? 0 : function(p) {\n            return (1 - p) * start + p * end;\n        };\n        if (!func) {\n            var isString = _isString(start), master = {}, p, i, interpolators, l, il;\n            progress === true && (mutate = 1) && (progress = null);\n            if (isString) {\n                start = {\n                    p: start\n                };\n                end = {\n                    p: end\n                };\n            } else if (_isArray(start) && !_isArray(end)) {\n                interpolators = [];\n                l = start.length;\n                il = l - 2;\n                for(i = 1; i < l; i++){\n                    interpolators.push(interpolate(start[i - 1], start[i]));\n                }\n                l--;\n                func = function func(p) {\n                    p *= l;\n                    var i = Math.min(il, ~~p);\n                    return interpolators[i](p - i);\n                };\n                progress = end;\n            } else if (!mutate) {\n                start = _merge(_isArray(start) ? [] : {}, start);\n            }\n            if (!interpolators) {\n                for(p in end){\n                    _addPropTween.call(master, start, p, \"get\", end[p]);\n                }\n                func = function func(p) {\n                    return _renderPropTweens(p, master) || (isString ? start.p : start);\n                };\n            }\n        }\n        return _conditionalReturn(progress, func);\n    }, _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {\n        var labels = timeline.labels, min = _bigNum, p, distance, label;\n        for(p in labels){\n            distance = labels[p] - fromTime;\n            if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {\n                label = p;\n                min = distance;\n            }\n        }\n        return label;\n    }, _callback = function _callback(animation, type, executeLazyFirst) {\n        var v = animation.vars, callback = v[type], prevContext = _context, context = animation._ctx, params, scope, result;\n        if (!callback) {\n            return;\n        }\n        params = v[type + \"Params\"];\n        scope = v.callbackScope || animation;\n        executeLazyFirst && _lazyTweens.length && _lazyRender();\n        context && (_context = context);\n        result = params ? callback.apply(scope, params) : callback.call(scope);\n        _context = prevContext;\n        return result;\n    }, _interrupt = function _interrupt(animation) {\n        _removeFromParent(animation);\n        animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);\n        animation.progress() < 1 && _callback(animation, \"onInterrupt\");\n        return animation;\n    }, _quickTween, _registerPluginQueue = [], _createPlugin = function _createPlugin(config) {\n        if (!config) return;\n        config = !config.name && config[\"default\"] || config;\n        if (_windowExists() || config.headless) {\n            var name = config.name, isFunc = _isFunction(config), Plugin = name && !isFunc && config.init ? function() {\n                this._props = [];\n            } : config, instanceDefaults = {\n                init: _emptyFunc,\n                render: _renderPropTweens,\n                add: _addPropTween,\n                kill: _killPropTweensOf,\n                modifier: _addPluginModifier,\n                rawVars: 0\n            }, statics = {\n                targetTest: 0,\n                get: 0,\n                getSetter: _getSetter,\n                aliases: {},\n                register: 0\n            };\n            _wake();\n            if (config !== Plugin) {\n                if (_plugins[name]) {\n                    return;\n                }\n                _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));\n                _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));\n                _plugins[Plugin.prop = name] = Plugin;\n                if (config.targetTest) {\n                    _harnessPlugins.push(Plugin);\n                    _reservedProps[name] = 1;\n                }\n                name = (name === \"css\" ? \"CSS\" : name.charAt(0).toUpperCase() + name.substr(1)) + \"Plugin\";\n            }\n            _addGlobal(name, Plugin);\n            config.register && config.register(gsap, Plugin, PropTween);\n        } else {\n            _registerPluginQueue.push(config);\n        }\n    }, _255 = 255, _colorLookup = {\n        aqua: [\n            0,\n            _255,\n            _255\n        ],\n        lime: [\n            0,\n            _255,\n            0\n        ],\n        silver: [\n            192,\n            192,\n            192\n        ],\n        black: [\n            0,\n            0,\n            0\n        ],\n        maroon: [\n            128,\n            0,\n            0\n        ],\n        teal: [\n            0,\n            128,\n            128\n        ],\n        blue: [\n            0,\n            0,\n            _255\n        ],\n        navy: [\n            0,\n            0,\n            128\n        ],\n        white: [\n            _255,\n            _255,\n            _255\n        ],\n        olive: [\n            128,\n            128,\n            0\n        ],\n        yellow: [\n            _255,\n            _255,\n            0\n        ],\n        orange: [\n            _255,\n            165,\n            0\n        ],\n        gray: [\n            128,\n            128,\n            128\n        ],\n        purple: [\n            128,\n            0,\n            128\n        ],\n        green: [\n            0,\n            128,\n            0\n        ],\n        red: [\n            _255,\n            0,\n            0\n        ],\n        pink: [\n            _255,\n            192,\n            203\n        ],\n        cyan: [\n            0,\n            _255,\n            _255\n        ],\n        transparent: [\n            _255,\n            _255,\n            _255,\n            0\n        ]\n    }, _hue = function _hue(h, m1, m2) {\n        h += h < 0 ? 1 : h > 1 ? -1 : 0;\n        return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;\n    }, splitColor = function splitColor(v, toHSL, forceAlpha) {\n        var a = !v ? _colorLookup.black : _isNumber(v) ? [\n            v >> 16,\n            v >> 8 & _255,\n            v & _255\n        ] : 0, r, g, b, h, s, l, max, min, d, wasHSL;\n        if (!a) {\n            if (v.substr(-1) === \",\") {\n                v = v.substr(0, v.length - 1);\n            }\n            if (_colorLookup[v]) {\n                a = _colorLookup[v];\n            } else if (v.charAt(0) === \"#\") {\n                if (v.length < 6) {\n                    r = v.charAt(1);\n                    g = v.charAt(2);\n                    b = v.charAt(3);\n                    v = \"#\" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : \"\");\n                }\n                if (v.length === 9) {\n                    a = parseInt(v.substr(1, 6), 16);\n                    return [\n                        a >> 16,\n                        a >> 8 & _255,\n                        a & _255,\n                        parseInt(v.substr(7), 16) / 255\n                    ];\n                }\n                v = parseInt(v.substr(1), 16);\n                a = [\n                    v >> 16,\n                    v >> 8 & _255,\n                    v & _255\n                ];\n            } else if (v.substr(0, 3) === \"hsl\") {\n                a = wasHSL = v.match(_strictNumExp);\n                if (!toHSL) {\n                    h = +a[0] % 360 / 360;\n                    s = +a[1] / 100;\n                    l = +a[2] / 100;\n                    g = l <= .5 ? l * (s + 1) : l + s - l * s;\n                    r = l * 2 - g;\n                    a.length > 3 && (a[3] *= 1);\n                    a[0] = _hue(h + 1 / 3, r, g);\n                    a[1] = _hue(h, r, g);\n                    a[2] = _hue(h - 1 / 3, r, g);\n                } else if (~v.indexOf(\"=\")) {\n                    a = v.match(_numExp);\n                    forceAlpha && a.length < 4 && (a[3] = 1);\n                    return a;\n                }\n            } else {\n                a = v.match(_strictNumExp) || _colorLookup.transparent;\n            }\n            a = a.map(Number);\n        }\n        if (toHSL && !wasHSL) {\n            r = a[0] / _255;\n            g = a[1] / _255;\n            b = a[2] / _255;\n            max = Math.max(r, g, b);\n            min = Math.min(r, g, b);\n            l = (max + min) / 2;\n            if (max === min) {\n                h = s = 0;\n            } else {\n                d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;\n                h *= 60;\n            }\n            a[0] = ~~(h + .5);\n            a[1] = ~~(s * 100 + .5);\n            a[2] = ~~(l * 100 + .5);\n        }\n        forceAlpha && a.length < 4 && (a[3] = 1);\n        return a;\n    }, _colorOrderData = function _colorOrderData(v) {\n        var values = [], c = [], i = -1;\n        v.split(_colorExp).forEach(function(v) {\n            var a = v.match(_numWithUnitExp) || [];\n            values.push.apply(values, a);\n            c.push(i += a.length + 1);\n        });\n        values.c = c;\n        return values;\n    }, _formatColors = function _formatColors(s, toHSL, orderMatchData) {\n        var result = \"\", colors = (s + result).match(_colorExp), type = toHSL ? \"hsla(\" : \"rgba(\", i = 0, c, shell, d, l;\n        if (!colors) {\n            return s;\n        }\n        colors = colors.map(function(color) {\n            return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + \",\" + color[1] + \"%,\" + color[2] + \"%,\" + color[3] : color.join(\",\")) + \")\";\n        });\n        if (orderMatchData) {\n            d = _colorOrderData(s);\n            c = orderMatchData.c;\n            if (c.join(result) !== d.c.join(result)) {\n                shell = s.replace(_colorExp, \"1\").split(_numWithUnitExp);\n                l = shell.length - 1;\n                for(; i < l; i++){\n                    result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + \"0,0,0,0)\" : (d.length ? d : colors.length ? colors : orderMatchData).shift());\n                }\n            }\n        }\n        if (!shell) {\n            shell = s.split(_colorExp);\n            l = shell.length - 1;\n            for(; i < l; i++){\n                result += shell[i] + colors[i];\n            }\n        }\n        return result + shell[l];\n    }, _colorExp = function() {\n        var s = \"(?:\\\\b(?:(?:rgb|rgba|hsl|hsla)\\\\(.+?\\\\))|\\\\B#(?:[0-9a-f]{3,4}){1,2}\\\\b\", p;\n        for(p in _colorLookup){\n            s += \"|\" + p + \"\\\\b\";\n        }\n        return new RegExp(s + \")\", \"gi\");\n    }(), _hslExp = /hsl[a]?\\(/, _colorStringFilter = function _colorStringFilter(a) {\n        var combined = a.join(\" \"), toHSL;\n        _colorExp.lastIndex = 0;\n        if (_colorExp.test(combined)) {\n            toHSL = _hslExp.test(combined);\n            a[1] = _formatColors(a[1], toHSL);\n            a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));\n            return true;\n        }\n    }, _tickerActive, _ticker = function() {\n        var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1000 / 240, _nextTime = _gap, _listeners = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick(v) {\n            var elapsed = _getTime() - _lastUpdate, manual = v === true, overlap, dispatch, time, frame;\n            (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);\n            _lastUpdate += elapsed;\n            time = _lastUpdate - _startTime;\n            overlap = time - _nextTime;\n            if (overlap > 0 || manual) {\n                frame = ++_self.frame;\n                _delta = time - _self.time * 1000;\n                _self.time = time = time / 1000;\n                _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);\n                dispatch = 1;\n            }\n            manual || (_id = _req(_tick));\n            if (dispatch) {\n                for(_i = 0; _i < _listeners.length; _i++){\n                    _listeners[_i](time, _delta, frame, v);\n                }\n            }\n        };\n        _self = {\n            time: 0,\n            frame: 0,\n            tick: function tick() {\n                _tick(true);\n            },\n            deltaRatio: function deltaRatio(fps) {\n                return _delta / (1000 / (fps || 60));\n            },\n            wake: function wake() {\n                if (_coreReady) {\n                    if (!_coreInitted && _windowExists()) {\n                        _win = _coreInitted = window;\n                        _doc = _win.document || {};\n                        _globals.gsap = gsap;\n                        (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);\n                        _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});\n                        _registerPluginQueue.forEach(_createPlugin);\n                    }\n                    _raf = typeof requestAnimationFrame !== \"undefined\" && requestAnimationFrame;\n                    _id && _self.sleep();\n                    _req = _raf || function(f) {\n                        return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);\n                    };\n                    _tickerActive = 1;\n                    _tick(2);\n                }\n            },\n            sleep: function sleep() {\n                (_raf ? cancelAnimationFrame : clearTimeout)(_id);\n                _tickerActive = 0;\n                _req = _emptyFunc;\n            },\n            lagSmoothing: function lagSmoothing(threshold, adjustedLag) {\n                _lagThreshold = threshold || Infinity;\n                _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);\n            },\n            fps: function fps(_fps) {\n                _gap = 1000 / (_fps || 240);\n                _nextTime = _self.time * 1000 + _gap;\n            },\n            add: function add(callback, once, prioritize) {\n                var func = once ? function(t, d, f, v) {\n                    callback(t, d, f, v);\n                    _self.remove(func);\n                } : callback;\n                _self.remove(callback);\n                _listeners[prioritize ? \"unshift\" : \"push\"](func);\n                _wake();\n                return func;\n            },\n            remove: function remove(callback, i) {\n                ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;\n            },\n            _listeners: _listeners\n        };\n        return _self;\n    }(), _wake = function _wake() {\n        return !_tickerActive && _ticker.wake();\n    }, _easeMap = {}, _customEaseExp = /^[\\d.\\-M][\\d.\\-,\\s]/, _quotesExp = /[\"']/g, _parseObjectInString = function _parseObjectInString(value) {\n        var obj = {}, split = value.substr(1, value.length - 3).split(\":\"), key = split[0], i = 1, l = split.length, index, val, parsedVal;\n        for(; i < l; i++){\n            val = split[i];\n            index = i !== l - 1 ? val.lastIndexOf(\",\") : val.length;\n            parsedVal = val.substr(0, index);\n            obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, \"\").trim() : +parsedVal;\n            key = val.substr(index + 1).trim();\n        }\n        return obj;\n    }, _valueInParentheses = function _valueInParentheses(value) {\n        var open = value.indexOf(\"(\") + 1, close = value.indexOf(\")\"), nested = value.indexOf(\"(\", open);\n        return value.substring(open, ~nested && nested < close ? value.indexOf(\")\", close + 1) : close);\n    }, _configEaseFromString = function _configEaseFromString(name) {\n        var split = (name + \"\").split(\"(\"), ease = _easeMap[split[0]];\n        return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf(\"{\") ? [\n            _parseObjectInString(split[1])\n        ] : _valueInParentheses(name).split(\",\").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE(\"\", name) : ease;\n    }, _invertEase = function _invertEase(ease) {\n        return function(p) {\n            return 1 - ease(1 - p);\n        };\n    }, _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {\n        var child = timeline._first, ease;\n        while(child){\n            if (child instanceof Timeline) {\n                _propagateYoyoEase(child, isYoyo);\n            } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {\n                if (child.timeline) {\n                    _propagateYoyoEase(child.timeline, isYoyo);\n                } else {\n                    ease = child._ease;\n                    child._ease = child._yEase;\n                    child._yEase = ease;\n                    child._yoyo = isYoyo;\n                }\n            }\n            child = child._next;\n        }\n    }, _parseEase = function _parseEase(ease, defaultEase) {\n        return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;\n    }, _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {\n        if (easeOut === void 0) {\n            easeOut = function easeOut(p) {\n                return 1 - easeIn(1 - p);\n            };\n        }\n        if (easeInOut === void 0) {\n            easeInOut = function easeInOut(p) {\n                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;\n            };\n        }\n        var ease = {\n            easeIn: easeIn,\n            easeOut: easeOut,\n            easeInOut: easeInOut\n        }, lowercaseName;\n        _forEachName(names, function(name) {\n            _easeMap[name] = _globals[name] = ease;\n            _easeMap[lowercaseName = name.toLowerCase()] = easeOut;\n            for(var p in ease){\n                _easeMap[lowercaseName + (p === \"easeIn\" ? \".in\" : p === \"easeOut\" ? \".out\" : \".inOut\")] = _easeMap[name + \".\" + p] = ease[p];\n            }\n        });\n        return ease;\n    }, _easeInOutFromOut = function _easeInOutFromOut(easeOut) {\n        return function(p) {\n            return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;\n        };\n    }, _configElastic = function _configElastic(type, amplitude, period) {\n        var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut(p) {\n            return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;\n        }, ease = type === \"out\" ? easeOut : type === \"in\" ? function(p) {\n            return 1 - easeOut(1 - p);\n        } : _easeInOutFromOut(easeOut);\n        p2 = _2PI / p2;\n        ease.config = function(amplitude, period) {\n            return _configElastic(type, amplitude, period);\n        };\n        return ease;\n    }, _configBack = function _configBack(type, overshoot) {\n        if (overshoot === void 0) {\n            overshoot = 1.70158;\n        }\n        var easeOut = function easeOut(p) {\n            return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;\n        }, ease = type === \"out\" ? easeOut : type === \"in\" ? function(p) {\n            return 1 - easeOut(1 - p);\n        } : _easeInOutFromOut(easeOut);\n        ease.config = function(overshoot) {\n            return _configBack(type, overshoot);\n        };\n        return ease;\n    };\n    _forEachName(\"Linear,Quad,Cubic,Quart,Quint,Strong\", function(name, i) {\n        var power = i < 5 ? i + 1 : i;\n        _insertEase(name + \",Power\" + (power - 1), i ? function(p) {\n            return Math.pow(p, power);\n        } : function(p) {\n            return p;\n        }, function(p) {\n            return 1 - Math.pow(1 - p, power);\n        }, function(p) {\n            return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;\n        });\n    });\n    _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;\n    _insertEase(\"Elastic\", _configElastic(\"in\"), _configElastic(\"out\"), _configElastic());\n    (function(n, c) {\n        var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut(p) {\n            return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;\n        };\n        _insertEase(\"Bounce\", function(p) {\n            return 1 - easeOut(1 - p);\n        }, easeOut);\n    })(7.5625, 2.75);\n    _insertEase(\"Expo\", function(p) {\n        return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);\n    });\n    _insertEase(\"Circ\", function(p) {\n        return -(_sqrt(1 - p * p) - 1);\n    });\n    _insertEase(\"Sine\", function(p) {\n        return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;\n    });\n    _insertEase(\"Back\", _configBack(\"in\"), _configBack(\"out\"), _configBack());\n    _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {\n        config: function config(steps, immediateStart) {\n            if (steps === void 0) {\n                steps = 1;\n            }\n            var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;\n            return function(p) {\n                return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;\n            };\n        }\n    };\n    _defaults.ease = _easeMap[\"quad.out\"];\n    _forEachName(\"onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt\", function(name) {\n        return _callbackNames += name + \",\" + name + \"Params,\";\n    });\n    var GSCache = function GSCache(target, harness) {\n        this.id = _gsID++;\n        target._gsap = this;\n        this.target = target;\n        this.harness = harness;\n        this.get = harness ? harness.get : _getProperty;\n        this.set = harness ? harness.getSetter : _getSetter;\n    };\n    var Animation = function() {\n        function Animation(vars) {\n            this.vars = vars;\n            this._delay = +vars.delay || 0;\n            if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {\n                this._rDelay = vars.repeatDelay || 0;\n                this._yoyo = !!vars.yoyo || !!vars.yoyoEase;\n            }\n            this._ts = 1;\n            _setDuration(this, +vars.duration, 1, 1);\n            this.data = vars.data;\n            if (_context) {\n                this._ctx = _context;\n                _context.data.push(this);\n            }\n            _tickerActive || _ticker.wake();\n        }\n        var _proto = Animation.prototype;\n        _proto.delay = function delay(value) {\n            if (value || value === 0) {\n                this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);\n                this._delay = value;\n                return this;\n            }\n            return this._delay;\n        };\n        _proto.duration = function duration(value) {\n            return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;\n        };\n        _proto.totalDuration = function totalDuration(value) {\n            if (!arguments.length) {\n                return this._tDur;\n            }\n            this._dirty = 0;\n            return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));\n        };\n        _proto.totalTime = function totalTime(_totalTime, suppressEvents) {\n            _wake();\n            if (!arguments.length) {\n                return this._tTime;\n            }\n            var parent = this._dp;\n            if (parent && parent.smoothChildTiming && this._ts) {\n                _alignPlayhead(this, _totalTime);\n                !parent._dp || parent.parent || _postAddChecks(parent, this);\n                while(parent && parent.parent){\n                    if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {\n                        parent.totalTime(parent._tTime, true);\n                    }\n                    parent = parent.parent;\n                }\n                if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {\n                    _addToTimeline(this._dp, this, this._start - this._delay);\n                }\n            }\n            if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {\n                this._ts || (this._pTime = _totalTime);\n                _lazySafeRender(this, _totalTime, suppressEvents);\n            }\n            return this;\n        };\n        _proto.time = function time(value, suppressEvents) {\n            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;\n        };\n        _proto.totalProgress = function totalProgress(value, suppressEvents) {\n            return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;\n        };\n        _proto.progress = function progress(value, suppressEvents) {\n            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;\n        };\n        _proto.iteration = function iteration(value, suppressEvents) {\n            var cycleDuration = this.duration() + this._rDelay;\n            return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;\n        };\n        _proto.timeScale = function timeScale(value, suppressEvents) {\n            if (!arguments.length) {\n                return this._rts === -_tinyNum ? 0 : this._rts;\n            }\n            if (this._rts === value) {\n                return this;\n            }\n            var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;\n            this._rts = +value || 0;\n            this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;\n            this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);\n            _setEnd(this);\n            return _recacheAncestors(this);\n        };\n        _proto.paused = function paused(value) {\n            if (!arguments.length) {\n                return this._ps;\n            }\n            if (this._ps !== value) {\n                this._ps = value;\n                if (value) {\n                    this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());\n                    this._ts = this._act = 0;\n                } else {\n                    _wake();\n                    this._ts = this._rts;\n                    this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));\n                }\n            }\n            return this;\n        };\n        _proto.startTime = function startTime(value) {\n            if (arguments.length) {\n                this._start = value;\n                var parent = this.parent || this._dp;\n                parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);\n                return this;\n            }\n            return this._start;\n        };\n        _proto.endTime = function endTime(includeRepeats) {\n            return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);\n        };\n        _proto.rawTime = function rawTime(wrapRepeats) {\n            var parent = this.parent || this._dp;\n            return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);\n        };\n        _proto.revert = function revert(config) {\n            if (config === void 0) {\n                config = _revertConfig;\n            }\n            var prevIsReverting = _reverting;\n            _reverting = config;\n            if (_isRevertWorthy(this)) {\n                this.timeline && this.timeline.revert(config);\n                this.totalTime(-0.01, config.suppressEvents);\n            }\n            this.data !== \"nested\" && config.kill !== false && this.kill();\n            _reverting = prevIsReverting;\n            return this;\n        };\n        _proto.globalTime = function globalTime(rawTime) {\n            var animation = this, time = arguments.length ? rawTime : animation.rawTime();\n            while(animation){\n                time = animation._start + time / (Math.abs(animation._ts) || 1);\n                animation = animation._dp;\n            }\n            return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;\n        };\n        _proto.repeat = function repeat(value) {\n            if (arguments.length) {\n                this._repeat = value === Infinity ? -2 : value;\n                return _onUpdateTotalDuration(this);\n            }\n            return this._repeat === -2 ? Infinity : this._repeat;\n        };\n        _proto.repeatDelay = function repeatDelay(value) {\n            if (arguments.length) {\n                var time = this._time;\n                this._rDelay = value;\n                _onUpdateTotalDuration(this);\n                return time ? this.time(time) : this;\n            }\n            return this._rDelay;\n        };\n        _proto.yoyo = function yoyo(value) {\n            if (arguments.length) {\n                this._yoyo = value;\n                return this;\n            }\n            return this._yoyo;\n        };\n        _proto.seek = function seek(position, suppressEvents) {\n            return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));\n        };\n        _proto.restart = function restart(includeDelay, suppressEvents) {\n            this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));\n            this._dur || (this._zTime = -_tinyNum);\n            return this;\n        };\n        _proto.play = function play(from, suppressEvents) {\n            from != null && this.seek(from, suppressEvents);\n            return this.reversed(false).paused(false);\n        };\n        _proto.reverse = function reverse(from, suppressEvents) {\n            from != null && this.seek(from || this.totalDuration(), suppressEvents);\n            return this.reversed(true).paused(false);\n        };\n        _proto.pause = function pause(atTime, suppressEvents) {\n            atTime != null && this.seek(atTime, suppressEvents);\n            return this.paused(true);\n        };\n        _proto.resume = function resume() {\n            return this.paused(false);\n        };\n        _proto.reversed = function reversed(value) {\n            if (arguments.length) {\n                !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));\n                return this;\n            }\n            return this._rts < 0;\n        };\n        _proto.invalidate = function invalidate() {\n            this._initted = this._act = 0;\n            this._zTime = -_tinyNum;\n            return this;\n        };\n        _proto.isActive = function isActive() {\n            var parent = this.parent || this._dp, start = this._start, rawTime;\n            return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);\n        };\n        _proto.eventCallback = function eventCallback(type, callback, params) {\n            var vars = this.vars;\n            if (arguments.length > 1) {\n                if (!callback) {\n                    delete vars[type];\n                } else {\n                    vars[type] = callback;\n                    params && (vars[type + \"Params\"] = params);\n                    type === \"onUpdate\" && (this._onUpdate = callback);\n                }\n                return this;\n            }\n            return vars[type];\n        };\n        _proto.then = function then(onFulfilled) {\n            var self1 = this;\n            return new Promise(function(resolve) {\n                var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve() {\n                    var _then = self1.then;\n                    self1.then = null;\n                    _isFunction(f) && (f = f(self1)) && (f.then || f === self1) && (self1.then = _then);\n                    resolve(f);\n                    self1.then = _then;\n                };\n                if (self1._initted && self1.totalProgress() === 1 && self1._ts >= 0 || !self1._tTime && self1._ts < 0) {\n                    _resolve();\n                } else {\n                    self1._prom = _resolve;\n                }\n            });\n        };\n        _proto.kill = function kill() {\n            _interrupt(this);\n        };\n        return Animation;\n    }();\n    _setDefaults(Animation.prototype, {\n        _time: 0,\n        _start: 0,\n        _end: 0,\n        _tTime: 0,\n        _tDur: 0,\n        _dirty: 0,\n        _repeat: 0,\n        _yoyo: false,\n        parent: null,\n        _initted: false,\n        _rDelay: 0,\n        _ts: 1,\n        _dp: 0,\n        ratio: 0,\n        _zTime: -_tinyNum,\n        _prom: 0,\n        _ps: false,\n        _rts: 1\n    });\n    var Timeline = function(_Animation) {\n        _inheritsLoose(Timeline, _Animation);\n        function Timeline(vars, position) {\n            var _this;\n            if (vars === void 0) {\n                vars = {};\n            }\n            _this = _Animation.call(this, vars) || this;\n            _this.labels = {};\n            _this.smoothChildTiming = !!vars.smoothChildTiming;\n            _this.autoRemoveChildren = !!vars.autoRemoveChildren;\n            _this._sort = _isNotFalse(vars.sortChildren);\n            _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);\n            vars.reversed && _this.reverse();\n            vars.paused && _this.paused(true);\n            vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);\n            return _this;\n        }\n        var _proto2 = Timeline.prototype;\n        _proto2.to = function to(targets, vars, position) {\n            _createTweenType(0, arguments, this);\n            return this;\n        };\n        _proto2.from = function from(targets, vars, position) {\n            _createTweenType(1, arguments, this);\n            return this;\n        };\n        _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {\n            _createTweenType(2, arguments, this);\n            return this;\n        };\n        _proto2.set = function set(targets, vars, position) {\n            vars.duration = 0;\n            vars.parent = this;\n            _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);\n            vars.immediateRender = !!vars.immediateRender;\n            new Tween(targets, vars, _parsePosition(this, position), 1);\n            return this;\n        };\n        _proto2.call = function call(callback, params, position) {\n            return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);\n        };\n        _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n            vars.duration = duration;\n            vars.stagger = vars.stagger || stagger;\n            vars.onComplete = onCompleteAll;\n            vars.onCompleteParams = onCompleteAllParams;\n            vars.parent = this;\n            new Tween(targets, vars, _parsePosition(this, position));\n            return this;\n        };\n        _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {\n            vars.runBackwards = 1;\n            _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);\n            return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);\n        };\n        _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {\n            toVars.startAt = fromVars;\n            _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);\n            return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);\n        };\n        _proto2.render = function render(totalTime, suppressEvents, force) {\n            var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;\n            this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);\n            if (tTime !== this._tTime || force || crossingStart) {\n                if (prevTime !== this._time && dur) {\n                    tTime += this._time - prevTime;\n                    totalTime += this._time - prevTime;\n                }\n                time = tTime;\n                prevStart = this._start;\n                timeScale = this._ts;\n                prevPaused = !timeScale;\n                if (crossingStart) {\n                    dur || (prevTime = this._zTime);\n                    (totalTime || !suppressEvents) && (this._zTime = totalTime);\n                }\n                if (this._repeat) {\n                    yoyo = this._yoyo;\n                    cycleDuration = dur + this._rDelay;\n                    if (this._repeat < -1 && totalTime < 0) {\n                        return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                    }\n                    time = _roundPrecise(tTime % cycleDuration);\n                    if (tTime === tDur) {\n                        iteration = this._repeat;\n                        time = dur;\n                    } else {\n                        prevIteration = _roundPrecise(tTime / cycleDuration);\n                        iteration = ~~prevIteration;\n                        if (iteration && iteration === prevIteration) {\n                            time = dur;\n                            iteration--;\n                        }\n                        time > dur && (time = dur);\n                    }\n                    prevIteration = _animationCycle(this._tTime, cycleDuration);\n                    !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);\n                    if (yoyo && iteration & 1) {\n                        time = dur - time;\n                        isYoyo = 1;\n                    }\n                    if (iteration !== prevIteration && !this._lock) {\n                        var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);\n                        iteration < prevIteration && (rewinding = !rewinding);\n                        prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;\n                        this._lock = 1;\n                        this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;\n                        this._tTime = tTime;\n                        !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n                        this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);\n                        if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {\n                            return this;\n                        }\n                        dur = this._dur;\n                        tDur = this._tDur;\n                        if (doesWrap) {\n                            this._lock = 2;\n                            prevTime = rewinding ? dur : -0.0001;\n                            this.render(prevTime, true);\n                            this.vars.repeatRefresh && !isYoyo && this.invalidate();\n                        }\n                        this._lock = 0;\n                        if (!this._ts && !prevPaused) {\n                            return this;\n                        }\n                        _propagateYoyoEase(this, isYoyo);\n                    }\n                }\n                if (this._hasPause && !this._forcing && this._lock < 2) {\n                    pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));\n                    if (pauseTween) {\n                        tTime -= time - (time = pauseTween._start);\n                    }\n                }\n                this._tTime = tTime;\n                this._time = time;\n                this._act = !timeScale;\n                if (!this._initted) {\n                    this._onUpdate = this.vars.onUpdate;\n                    this._initted = 1;\n                    this._zTime = totalTime;\n                    prevTime = 0;\n                }\n                if (!prevTime && tTime && !suppressEvents && !prevIteration) {\n                    _callback(this, \"onStart\");\n                    if (this._tTime !== tTime) {\n                        return this;\n                    }\n                }\n                if (time >= prevTime && totalTime >= 0) {\n                    child = this._first;\n                    while(child){\n                        next = child._next;\n                        if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {\n                            if (child.parent !== this) {\n                                return this.render(totalTime, suppressEvents, force);\n                            }\n                            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);\n                            if (time !== this._time || !this._ts && !prevPaused) {\n                                pauseTween = 0;\n                                next && (tTime += this._zTime = -_tinyNum);\n                                break;\n                            }\n                        }\n                        child = next;\n                    }\n                } else {\n                    child = this._last;\n                    var adjustedTime = totalTime < 0 ? totalTime : time;\n                    while(child){\n                        next = child._prev;\n                        if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {\n                            if (child.parent !== this) {\n                                return this.render(totalTime, suppressEvents, force);\n                            }\n                            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child));\n                            if (time !== this._time || !this._ts && !prevPaused) {\n                                pauseTween = 0;\n                                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);\n                                break;\n                            }\n                        }\n                        child = next;\n                    }\n                }\n                if (pauseTween && !suppressEvents) {\n                    this.pause();\n                    pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;\n                    if (this._ts) {\n                        this._start = prevStart;\n                        _setEnd(this);\n                        return this.render(totalTime, suppressEvents, force);\n                    }\n                }\n                this._onUpdate && !suppressEvents && _callback(this, \"onUpdate\", true);\n                if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {\n                    if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {\n                        if (!this._lock) {\n                            (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);\n                            if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {\n                                _callback(this, tTime === tDur && totalTime >= 0 ? \"onComplete\" : \"onReverseComplete\", true);\n                                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                            }\n                        }\n                    }\n                }\n            }\n            return this;\n        };\n        _proto2.add = function add(child, position) {\n            var _this2 = this;\n            _isNumber(position) || (position = _parsePosition(this, position, child));\n            if (!(child instanceof Animation)) {\n                if (_isArray(child)) {\n                    child.forEach(function(obj) {\n                        return _this2.add(obj, position);\n                    });\n                    return this;\n                }\n                if (_isString(child)) {\n                    return this.addLabel(child, position);\n                }\n                if (_isFunction(child)) {\n                    child = Tween.delayedCall(0, child);\n                } else {\n                    return this;\n                }\n            }\n            return this !== child ? _addToTimeline(this, child, position) : this;\n        };\n        _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {\n            if (nested === void 0) {\n                nested = true;\n            }\n            if (tweens === void 0) {\n                tweens = true;\n            }\n            if (timelines === void 0) {\n                timelines = true;\n            }\n            if (ignoreBeforeTime === void 0) {\n                ignoreBeforeTime = -_bigNum;\n            }\n            var a = [], child = this._first;\n            while(child){\n                if (child._start >= ignoreBeforeTime) {\n                    if (child instanceof Tween) {\n                        tweens && a.push(child);\n                    } else {\n                        timelines && a.push(child);\n                        nested && a.push.apply(a, child.getChildren(true, tweens, timelines));\n                    }\n                }\n                child = child._next;\n            }\n            return a;\n        };\n        _proto2.getById = function getById(id) {\n            var animations = this.getChildren(1, 1, 1), i = animations.length;\n            while(i--){\n                if (animations[i].vars.id === id) {\n                    return animations[i];\n                }\n            }\n        };\n        _proto2.remove = function remove(child) {\n            if (_isString(child)) {\n                return this.removeLabel(child);\n            }\n            if (_isFunction(child)) {\n                return this.killTweensOf(child);\n            }\n            child.parent === this && _removeLinkedListItem(this, child);\n            if (child === this._recent) {\n                this._recent = this._last;\n            }\n            return _uncache(this);\n        };\n        _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {\n            if (!arguments.length) {\n                return this._tTime;\n            }\n            this._forcing = 1;\n            if (!this._dp && this._ts) {\n                this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));\n            }\n            _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);\n            this._forcing = 0;\n            return this;\n        };\n        _proto2.addLabel = function addLabel(label, position) {\n            this.labels[label] = _parsePosition(this, position);\n            return this;\n        };\n        _proto2.removeLabel = function removeLabel(label) {\n            delete this.labels[label];\n            return this;\n        };\n        _proto2.addPause = function addPause(position, callback, params) {\n            var t = Tween.delayedCall(0, callback || _emptyFunc, params);\n            t.data = \"isPause\";\n            this._hasPause = 1;\n            return _addToTimeline(this, t, _parsePosition(this, position));\n        };\n        _proto2.removePause = function removePause(position) {\n            var child = this._first;\n            position = _parsePosition(this, position);\n            while(child){\n                if (child._start === position && child.data === \"isPause\") {\n                    _removeFromParent(child);\n                }\n                child = child._next;\n            }\n        };\n        _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n            var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;\n            while(i--){\n                _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);\n            }\n            return this;\n        };\n        _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {\n            var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;\n            while(child){\n                if (child instanceof Tween) {\n                    if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {\n                        a.push(child);\n                    }\n                } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {\n                    a.push.apply(a, children);\n                }\n                child = child._next;\n            }\n            return a;\n        };\n        _proto2.tweenTo = function tweenTo(position, vars) {\n            vars = vars || {};\n            var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({\n                ease: vars.ease || \"none\",\n                lazy: false,\n                immediateRender: false,\n                time: endTime,\n                overwrite: \"auto\",\n                duration: vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,\n                onStart: function onStart() {\n                    tl.pause();\n                    if (!initted) {\n                        var duration = vars.duration || Math.abs((endTime - (startAt && \"time\" in startAt ? startAt.time : tl._time)) / tl.timeScale());\n                        tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);\n                        initted = 1;\n                    }\n                    _onStart && _onStart.apply(tween, onStartParams || []);\n                }\n            }, vars));\n            return immediateRender ? tween.render(0) : tween;\n        };\n        _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {\n            return this.tweenTo(toPosition, _setDefaults({\n                startAt: {\n                    time: _parsePosition(this, fromPosition)\n                }\n            }, vars));\n        };\n        _proto2.recent = function recent() {\n            return this._recent;\n        };\n        _proto2.nextLabel = function nextLabel(afterTime) {\n            if (afterTime === void 0) {\n                afterTime = this._time;\n            }\n            return _getLabelInDirection(this, _parsePosition(this, afterTime));\n        };\n        _proto2.previousLabel = function previousLabel(beforeTime) {\n            if (beforeTime === void 0) {\n                beforeTime = this._time;\n            }\n            return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);\n        };\n        _proto2.currentLabel = function currentLabel(value) {\n            return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);\n        };\n        _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {\n            if (ignoreBeforeTime === void 0) {\n                ignoreBeforeTime = 0;\n            }\n            var child = this._first, labels = this.labels, p;\n            while(child){\n                if (child._start >= ignoreBeforeTime) {\n                    child._start += amount;\n                    child._end += amount;\n                }\n                child = child._next;\n            }\n            if (adjustLabels) {\n                for(p in labels){\n                    if (labels[p] >= ignoreBeforeTime) {\n                        labels[p] += amount;\n                    }\n                }\n            }\n            return _uncache(this);\n        };\n        _proto2.invalidate = function invalidate(soft) {\n            var child = this._first;\n            this._lock = 0;\n            while(child){\n                child.invalidate(soft);\n                child = child._next;\n            }\n            return _Animation.prototype.invalidate.call(this, soft);\n        };\n        _proto2.clear = function clear(includeLabels) {\n            if (includeLabels === void 0) {\n                includeLabels = true;\n            }\n            var child = this._first, next;\n            while(child){\n                next = child._next;\n                this.remove(child);\n                child = next;\n            }\n            this._dp && (this._time = this._tTime = this._pTime = 0);\n            includeLabels && (this.labels = {});\n            return _uncache(this);\n        };\n        _proto2.totalDuration = function totalDuration(value) {\n            var max = 0, self1 = this, child = self1._last, prevStart = _bigNum, prev, start, parent;\n            if (arguments.length) {\n                return self1.timeScale((self1._repeat < 0 ? self1.duration() : self1.totalDuration()) / (self1.reversed() ? -value : value));\n            }\n            if (self1._dirty) {\n                parent = self1.parent;\n                while(child){\n                    prev = child._prev;\n                    child._dirty && child.totalDuration();\n                    start = child._start;\n                    if (start > prevStart && self1._sort && child._ts && !self1._lock) {\n                        self1._lock = 1;\n                        _addToTimeline(self1, child, start - child._delay, 1)._lock = 0;\n                    } else {\n                        prevStart = start;\n                    }\n                    if (start < 0 && child._ts) {\n                        max -= start;\n                        if (!parent && !self1._dp || parent && parent.smoothChildTiming) {\n                            self1._start += start / self1._ts;\n                            self1._time -= start;\n                            self1._tTime -= start;\n                        }\n                        self1.shiftChildren(-start, false, -Infinity);\n                        prevStart = 0;\n                    }\n                    child._end > max && child._ts && (max = child._end);\n                    child = prev;\n                }\n                _setDuration(self1, self1 === _globalTimeline && self1._time > max ? self1._time : max, 1, 1);\n                self1._dirty = 0;\n            }\n            return self1._tDur;\n        };\n        Timeline.updateRoot = function updateRoot(time) {\n            if (_globalTimeline._ts) {\n                _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));\n                _lastRenderedFrame = _ticker.frame;\n            }\n            if (_ticker.frame >= _nextGCFrame) {\n                _nextGCFrame += _config.autoSleep || 120;\n                var child = _globalTimeline._first;\n                if (!child || !child._ts) {\n                    if (_config.autoSleep && _ticker._listeners.length < 2) {\n                        while(child && !child._ts){\n                            child = child._next;\n                        }\n                        child || _ticker.sleep();\n                    }\n                }\n            }\n        };\n        return Timeline;\n    }(Animation);\n    _setDefaults(Timeline.prototype, {\n        _lock: 0,\n        _hasPause: 0,\n        _forcing: 0\n    });\n    var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {\n        var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;\n        pt.b = start;\n        pt.e = end;\n        start += \"\";\n        end += \"\";\n        if (hasRandom = ~end.indexOf(\"random(\")) {\n            end = _replaceRandom(end);\n        }\n        if (stringFilter) {\n            a = [\n                start,\n                end\n            ];\n            stringFilter(a, target, prop);\n            start = a[0];\n            end = a[1];\n        }\n        startNums = start.match(_complexStringNumExp) || [];\n        while(result = _complexStringNumExp.exec(end)){\n            endNum = result[0];\n            chunk = end.substring(index, result.index);\n            if (color) {\n                color = (color + 1) % 5;\n            } else if (chunk.substr(-5) === \"rgba(\") {\n                color = 1;\n            }\n            if (endNum !== startNums[matchIndex++]) {\n                startNum = parseFloat(startNums[matchIndex - 1]) || 0;\n                pt._pt = {\n                    _next: pt._pt,\n                    p: chunk || matchIndex === 1 ? chunk : \",\",\n                    s: startNum,\n                    c: endNum.charAt(1) === \"=\" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,\n                    m: color && color < 4 ? Math.round : 0\n                };\n                index = _complexStringNumExp.lastIndex;\n            }\n        }\n        pt.c = index < end.length ? end.substring(index, end.length) : \"\";\n        pt.fp = funcParam;\n        if (_relExp.test(end) || hasRandom) {\n            pt.e = 0;\n        }\n        this._pt = pt;\n        return pt;\n    }, _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {\n        _isFunction(end) && (end = end(index || 0, target, targets));\n        var currentValue = target[prop], parsedStart = start !== \"get\" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf(\"set\") || !_isFunction(target[\"get\" + prop.substr(3)]) ? prop : \"get\" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;\n        if (_isString(end)) {\n            if (~end.indexOf(\"random(\")) {\n                end = _replaceRandom(end);\n            }\n            if (end.charAt(1) === \"=\") {\n                pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);\n                if (pt || pt === 0) {\n                    end = pt;\n                }\n            }\n        }\n        if (!optional || parsedStart !== end || _forceAllPropTweens) {\n            if (!isNaN(parsedStart * end) && end !== \"\") {\n                pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === \"boolean\" ? _renderBoolean : _renderPlain, 0, setter);\n                funcParam && (pt.fp = funcParam);\n                modifier && pt.modifier(modifier, this, target);\n                return this._pt = pt;\n            }\n            !currentValue && !(prop in target) && _missingPlugin(prop, end);\n            return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);\n        }\n    }, _processVars = function _processVars(vars, index, target, targets, tween) {\n        _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));\n        if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {\n            return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;\n        }\n        var copy = {}, p;\n        for(p in vars){\n            copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);\n        }\n        return copy;\n    }, _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {\n        var plugin, pt, ptLookup, i;\n        if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {\n            tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);\n            if (tween !== _quickTween) {\n                ptLookup = tween._ptLookup[tween._targets.indexOf(target)];\n                i = plugin._props.length;\n                while(i--){\n                    ptLookup[plugin._props[i]] = pt;\n                }\n            }\n        }\n        return plugin;\n    }, _overwritingTween, _forceAllPropTweens, _initTween = function _initTween(tween, time, tTime) {\n        var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent = tween.parent, fullTargets = parent && parent.data === \"nested\" ? parent.vars.targets : targets, autoOverwrite = tween._overwrite === \"auto\" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;\n        tl && (!keyframes || !ease) && (ease = \"none\");\n        tween._ease = _parseEase(ease, _defaults.ease);\n        tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;\n        if (yoyoEase && tween._yoyo && !tween._repeat) {\n            yoyoEase = tween._yEase;\n            tween._yEase = tween._ease;\n            tween._ease = yoyoEase;\n        }\n        tween._from = !tl && !!vars.runBackwards;\n        if (!tl || keyframes && !vars.stagger) {\n            harness = targets[0] ? _getCache(targets[0]).harness : 0;\n            harnessVars = harness && vars[harness.prop];\n            cleanVars = _copyExcluding(vars, _reservedProps);\n            if (prevStartAt) {\n                prevStartAt._zTime < 0 && prevStartAt.progress(1);\n                time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);\n                prevStartAt._lazy = 0;\n            }\n            if (startAt) {\n                _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({\n                    data: \"isStart\",\n                    overwrite: false,\n                    parent: parent,\n                    immediateRender: true,\n                    lazy: !prevStartAt && _isNotFalse(lazy),\n                    startAt: null,\n                    delay: 0,\n                    onUpdate: onUpdate && function() {\n                        return _callback(tween, \"onUpdate\");\n                    },\n                    stagger: 0\n                }, startAt)));\n                tween._startAt._dp = 0;\n                tween._startAt._sat = tween;\n                time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);\n                if (immediateRender) {\n                    if (dur && time <= 0 && tTime <= 0) {\n                        time && (tween._zTime = time);\n                        return;\n                    }\n                }\n            } else if (runBackwards && dur) {\n                if (!prevStartAt) {\n                    time && (immediateRender = false);\n                    p = _setDefaults({\n                        overwrite: false,\n                        data: \"isFromStart\",\n                        lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),\n                        immediateRender: immediateRender,\n                        stagger: 0,\n                        parent: parent\n                    }, cleanVars);\n                    harnessVars && (p[harness.prop] = harnessVars);\n                    _removeFromParent(tween._startAt = Tween.set(targets, p));\n                    tween._startAt._dp = 0;\n                    tween._startAt._sat = tween;\n                    time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));\n                    tween._zTime = time;\n                    if (!immediateRender) {\n                        _initTween(tween._startAt, _tinyNum, _tinyNum);\n                    } else if (!time) {\n                        return;\n                    }\n                }\n            }\n            tween._pt = tween._ptCache = 0;\n            lazy = dur && _isNotFalse(lazy) || lazy && !dur;\n            for(i = 0; i < targets.length; i++){\n                target = targets[i];\n                gsData = target._gsap || _harness(targets)[i]._gsap;\n                tween._ptLookup[i] = ptLookup = {};\n                _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();\n                index = fullTargets === targets ? i : fullTargets.indexOf(target);\n                if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {\n                    tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);\n                    plugin._props.forEach(function(name) {\n                        ptLookup[name] = pt;\n                    });\n                    plugin.priority && (hasPriority = 1);\n                }\n                if (!harness || harnessVars) {\n                    for(p in cleanVars){\n                        if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {\n                            plugin.priority && (hasPriority = 1);\n                        } else {\n                            ptLookup[p] = pt = _addPropTween.call(tween, target, p, \"get\", cleanVars[p], index, fullTargets, 0, vars.stringFilter);\n                        }\n                    }\n                }\n                tween._op && tween._op[i] && tween.kill(target, tween._op[i]);\n                if (autoOverwrite && tween._pt) {\n                    _overwritingTween = tween;\n                    _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));\n                    overwritten = !tween.parent;\n                    _overwritingTween = 0;\n                }\n                tween._pt && lazy && (_lazyLookup[gsData.id] = 1);\n            }\n            hasPriority && _sortPropTweensByPriority(tween);\n            tween._onInit && tween._onInit(tween);\n        }\n        tween._onUpdate = onUpdate;\n        tween._initted = (!tween._op || tween._pt) && !overwritten;\n        keyframes && time <= 0 && tl.render(_bigNum, true, true);\n    }, _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {\n        var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;\n        if (!ptCache) {\n            ptCache = tween._ptCache[property] = [];\n            lookup = tween._ptLookup;\n            i = tween._targets.length;\n            while(i--){\n                pt = lookup[i][property];\n                if (pt && pt.d && pt.d._pt) {\n                    pt = pt.d._pt;\n                    while(pt && pt.p !== property && pt.fp !== property){\n                        pt = pt._next;\n                    }\n                }\n                if (!pt) {\n                    _forceAllPropTweens = 1;\n                    tween.vars[property] = \"+=0\";\n                    _initTween(tween, time);\n                    _forceAllPropTweens = 0;\n                    return skipRecursion ? _warn(property + \" not eligible for reset\") : 1;\n                }\n                ptCache.push(pt);\n            }\n        }\n        i = ptCache.length;\n        while(i--){\n            rootPT = ptCache[i];\n            pt = rootPT._pt || rootPT;\n            pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;\n            pt.c = value - pt.s;\n            rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));\n            rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));\n        }\n    }, _addAliasesToVars = function _addAliasesToVars(targets, vars) {\n        var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;\n        if (!propertyAliases) {\n            return vars;\n        }\n        copy = _merge({}, vars);\n        for(p in propertyAliases){\n            if (p in copy) {\n                aliases = propertyAliases[p].split(\",\");\n                i = aliases.length;\n                while(i--){\n                    copy[aliases[i]] = copy[p];\n                }\n            }\n        }\n        return copy;\n    }, _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {\n        var ease = obj.ease || easeEach || \"power1.inOut\", p, a;\n        if (_isArray(obj)) {\n            a = allProps[prop] || (allProps[prop] = []);\n            obj.forEach(function(value, i) {\n                return a.push({\n                    t: i / (obj.length - 1) * 100,\n                    v: value,\n                    e: ease\n                });\n            });\n        } else {\n            for(p in obj){\n                a = allProps[p] || (allProps[p] = []);\n                p === \"ease\" || a.push({\n                    t: parseFloat(prop),\n                    v: obj[p],\n                    e: ease\n                });\n            }\n        }\n    }, _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {\n        return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf(\"random(\") ? _replaceRandom(value) : value;\n    }, _staggerTweenProps = _callbackNames + \"repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert\", _staggerPropsToSkip = {};\n    _forEachName(_staggerTweenProps + \",id,stagger,delay,duration,paused,scrollTrigger\", function(name) {\n        return _staggerPropsToSkip[name] = 1;\n    });\n    var Tween = function(_Animation2) {\n        _inheritsLoose(Tween, _Animation2);\n        function Tween(targets, vars, position, skipInherit) {\n            var _this3;\n            if (typeof vars === \"number\") {\n                position.duration = vars;\n                vars = position;\n                position = null;\n            }\n            _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;\n            var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : \"length\" in vars) ? [\n                targets\n            ] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;\n            _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn(\"GSAP target \" + targets + \" not found. https://gsap.com\", !_config.nullTargetWarn) || [];\n            _this3._ptLookup = [];\n            _this3._overwrite = overwrite;\n            if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n                vars = _this3.vars;\n                tl = _this3.timeline = new Timeline({\n                    data: \"nested\",\n                    defaults: defaults || {},\n                    targets: parent && parent.data === \"nested\" ? parent.vars.targets : parsedTargets\n                });\n                tl.kill();\n                tl.parent = tl._dp = _assertThisInitialized(_this3);\n                tl._start = 0;\n                if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {\n                    l = parsedTargets.length;\n                    staggerFunc = stagger && distribute(stagger);\n                    if (_isObject(stagger)) {\n                        for(p in stagger){\n                            if (~_staggerTweenProps.indexOf(p)) {\n                                staggerVarsToMerge || (staggerVarsToMerge = {});\n                                staggerVarsToMerge[p] = stagger[p];\n                            }\n                        }\n                    }\n                    for(i = 0; i < l; i++){\n                        copy = _copyExcluding(vars, _staggerPropsToSkip);\n                        copy.stagger = 0;\n                        yoyoEase && (copy.yoyoEase = yoyoEase);\n                        staggerVarsToMerge && _merge(copy, staggerVarsToMerge);\n                        curTarget = parsedTargets[i];\n                        copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);\n                        copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;\n                        if (!stagger && l === 1 && copy.delay) {\n                            _this3._delay = delay = copy.delay;\n                            _this3._start += delay;\n                            copy.delay = 0;\n                        }\n                        tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);\n                        tl._ease = _easeMap.none;\n                    }\n                    tl.duration() ? duration = delay = 0 : _this3.timeline = 0;\n                } else if (keyframes) {\n                    _inheritDefaults(_setDefaults(tl.vars.defaults, {\n                        ease: \"none\"\n                    }));\n                    tl._ease = _parseEase(keyframes.ease || vars.ease || \"none\");\n                    var time = 0, a, kf, v;\n                    if (_isArray(keyframes)) {\n                        keyframes.forEach(function(frame) {\n                            return tl.to(parsedTargets, frame, \">\");\n                        });\n                        tl.duration();\n                    } else {\n                        copy = {};\n                        for(p in keyframes){\n                            p === \"ease\" || p === \"easeEach\" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);\n                        }\n                        for(p in copy){\n                            a = copy[p].sort(function(a, b) {\n                                return a.t - b.t;\n                            });\n                            time = 0;\n                            for(i = 0; i < a.length; i++){\n                                kf = a[i];\n                                v = {\n                                    ease: kf.e,\n                                    duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration\n                                };\n                                v[p] = kf.v;\n                                tl.to(parsedTargets, v, time);\n                                time += v.duration;\n                            }\n                        }\n                        tl.duration() < duration && tl.to({}, {\n                            duration: duration - tl.duration()\n                        });\n                    }\n                }\n                duration || _this3.duration(duration = tl.duration());\n            } else {\n                _this3.timeline = 0;\n            }\n            if (overwrite === true && !_suppressOverwrites) {\n                _overwritingTween = _assertThisInitialized(_this3);\n                _globalTimeline.killTweensOf(parsedTargets);\n                _overwritingTween = 0;\n            }\n            _addToTimeline(parent, _assertThisInitialized(_this3), position);\n            vars.reversed && _this3.reverse();\n            vars.paused && _this3.paused(true);\n            if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== \"nested\") {\n                _this3._tTime = -_tinyNum;\n                _this3.render(Math.max(0, -delay) || 0);\n            }\n            scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);\n            return _this3;\n        }\n        var _proto3 = Tween.prototype;\n        _proto3.render = function render(totalTime, suppressEvents, force) {\n            var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;\n            if (!dur) {\n                _renderZeroDurationTween(this, totalTime, suppressEvents, force);\n            } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {\n                time = tTime;\n                timeline = this.timeline;\n                if (this._repeat) {\n                    cycleDuration = dur + this._rDelay;\n                    if (this._repeat < -1 && isNegative) {\n                        return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);\n                    }\n                    time = _roundPrecise(tTime % cycleDuration);\n                    if (tTime === tDur) {\n                        iteration = this._repeat;\n                        time = dur;\n                    } else {\n                        prevIteration = _roundPrecise(tTime / cycleDuration);\n                        iteration = ~~prevIteration;\n                        if (iteration && iteration === prevIteration) {\n                            time = dur;\n                            iteration--;\n                        } else if (time > dur) {\n                            time = dur;\n                        }\n                    }\n                    isYoyo = this._yoyo && iteration & 1;\n                    if (isYoyo) {\n                        yoyoEase = this._yEase;\n                        time = dur - time;\n                    }\n                    prevIteration = _animationCycle(this._tTime, cycleDuration);\n                    if (time === prevTime && !force && this._initted && iteration === prevIteration) {\n                        this._tTime = tTime;\n                        return this;\n                    }\n                    if (iteration !== prevIteration) {\n                        timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);\n                        if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {\n                            this._lock = force = 1;\n                            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;\n                        }\n                    }\n                }\n                if (!this._initted) {\n                    if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {\n                        this._tTime = 0;\n                        return this;\n                    }\n                    if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {\n                        return this;\n                    }\n                    if (dur !== this._dur) {\n                        return this.render(totalTime, suppressEvents, force);\n                    }\n                }\n                this._tTime = tTime;\n                this._time = time;\n                if (!this._act && this._ts) {\n                    this._act = 1;\n                    this._lazy = 0;\n                }\n                this.ratio = ratio = (yoyoEase || this._ease)(time / dur);\n                if (this._from) {\n                    this.ratio = ratio = 1 - ratio;\n                }\n                if (!prevTime && tTime && !suppressEvents && !prevIteration) {\n                    _callback(this, \"onStart\");\n                    if (this._tTime !== tTime) {\n                        return this;\n                    }\n                }\n                pt = this._pt;\n                while(pt){\n                    pt.r(ratio, pt.d);\n                    pt = pt._next;\n                }\n                timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);\n                if (this._onUpdate && !suppressEvents) {\n                    isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);\n                    _callback(this, \"onUpdate\");\n                }\n                this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, \"onRepeat\");\n                if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {\n                    isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);\n                    (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);\n                    if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {\n                        _callback(this, tTime === tDur ? \"onComplete\" : \"onReverseComplete\", true);\n                        this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();\n                    }\n                }\n            }\n            return this;\n        };\n        _proto3.targets = function targets() {\n            return this._targets;\n        };\n        _proto3.invalidate = function invalidate(soft) {\n            (!soft || !this.vars.runBackwards) && (this._startAt = 0);\n            this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;\n            this._ptLookup = [];\n            this.timeline && this.timeline.invalidate(soft);\n            return _Animation2.prototype.invalidate.call(this, soft);\n        };\n        _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {\n            _tickerActive || _ticker.wake();\n            this._ts || this.play();\n            var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;\n            this._initted || _initTween(this, time);\n            ratio = this._ease(time / this._dur);\n            if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {\n                return this.resetTo(property, value, start, startIsRelative, 1);\n            }\n            _alignPlayhead(this, 0);\n            this.parent || _addLinkedListItem(this._dp, this, \"_first\", \"_last\", this._dp._sort ? \"_start\" : 0);\n            return this.render(0);\n        };\n        _proto3.kill = function kill(targets, vars) {\n            if (vars === void 0) {\n                vars = \"all\";\n            }\n            if (!targets && (!vars || vars === \"all\")) {\n                this._lazy = this._pt = 0;\n                this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);\n                return this;\n            }\n            if (this.timeline) {\n                var tDur = this.timeline.totalDuration();\n                this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);\n                this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);\n                return this;\n            }\n            var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;\n            if ((!vars || vars === \"all\") && _arraysMatch(parsedTargets, killingTargets)) {\n                vars === \"all\" && (this._pt = 0);\n                return _interrupt(this);\n            }\n            overwrittenProps = this._op = this._op || [];\n            if (vars !== \"all\") {\n                if (_isString(vars)) {\n                    p = {};\n                    _forEachName(vars, function(name) {\n                        return p[name] = 1;\n                    });\n                    vars = p;\n                }\n                vars = _addAliasesToVars(parsedTargets, vars);\n            }\n            i = parsedTargets.length;\n            while(i--){\n                if (~killingTargets.indexOf(parsedTargets[i])) {\n                    curLookup = propTweenLookup[i];\n                    if (vars === \"all\") {\n                        overwrittenProps[i] = vars;\n                        props = curLookup;\n                        curOverwriteProps = {};\n                    } else {\n                        curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};\n                        props = vars;\n                    }\n                    for(p in props){\n                        pt = curLookup && curLookup[p];\n                        if (pt) {\n                            if (!(\"kill\" in pt.d) || pt.d.kill(p) === true) {\n                                _removeLinkedListItem(this, pt, \"_pt\");\n                            }\n                            delete curLookup[p];\n                        }\n                        if (curOverwriteProps !== \"all\") {\n                            curOverwriteProps[p] = 1;\n                        }\n                    }\n                }\n            }\n            this._initted && !this._pt && firstPT && _interrupt(this);\n            return this;\n        };\n        Tween.to = function to(targets, vars) {\n            return new Tween(targets, vars, arguments[2]);\n        };\n        Tween.from = function from(targets, vars) {\n            return _createTweenType(1, arguments);\n        };\n        Tween.delayedCall = function delayedCall(delay, callback, params, scope) {\n            return new Tween(callback, 0, {\n                immediateRender: false,\n                lazy: false,\n                overwrite: false,\n                delay: delay,\n                onComplete: callback,\n                onReverseComplete: callback,\n                onCompleteParams: params,\n                onReverseCompleteParams: params,\n                callbackScope: scope\n            });\n        };\n        Tween.fromTo = function fromTo(targets, fromVars, toVars) {\n            return _createTweenType(2, arguments);\n        };\n        Tween.set = function set(targets, vars) {\n            vars.duration = 0;\n            vars.repeatDelay || (vars.repeat = 0);\n            return new Tween(targets, vars);\n        };\n        Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {\n            return _globalTimeline.killTweensOf(targets, props, onlyActive);\n        };\n        return Tween;\n    }(Animation);\n    _setDefaults(Tween.prototype, {\n        _targets: [],\n        _lazy: 0,\n        _startAt: 0,\n        _op: 0,\n        _onInit: 0\n    });\n    _forEachName(\"staggerTo,staggerFrom,staggerFromTo\", function(name) {\n        Tween[name] = function() {\n            var tl = new Timeline(), params = _slice.call(arguments, 0);\n            params.splice(name === \"staggerFromTo\" ? 5 : 4, 0, 0);\n            return tl[name].apply(tl, params);\n        };\n    });\n    var _setterPlain = function _setterPlain(target, property, value) {\n        return target[property] = value;\n    }, _setterFunc = function _setterFunc(target, property, value) {\n        return target[property](value);\n    }, _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {\n        return target[property](data.fp, value);\n    }, _setterAttribute = function _setterAttribute(target, property, value) {\n        return target.setAttribute(property, value);\n    }, _getSetter = function _getSetter(target, property) {\n        return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;\n    }, _renderPlain = function _renderPlain(ratio, data) {\n        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);\n    }, _renderBoolean = function _renderBoolean(ratio, data) {\n        return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);\n    }, _renderComplexString = function _renderComplexString(ratio, data) {\n        var pt = data._pt, s = \"\";\n        if (!ratio && data.b) {\n            s = data.b;\n        } else if (ratio === 1 && data.e) {\n            s = data.e;\n        } else {\n            while(pt){\n                s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s;\n                pt = pt._next;\n            }\n            s += data.c;\n        }\n        data.set(data.t, data.p, s, data);\n    }, _renderPropTweens = function _renderPropTweens(ratio, data) {\n        var pt = data._pt;\n        while(pt){\n            pt.r(ratio, pt.d);\n            pt = pt._next;\n        }\n    }, _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {\n        var pt = this._pt, next;\n        while(pt){\n            next = pt._next;\n            pt.p === property && pt.modifier(modifier, tween, target);\n            pt = next;\n        }\n    }, _killPropTweensOf = function _killPropTweensOf(property) {\n        var pt = this._pt, hasNonDependentRemaining, next;\n        while(pt){\n            next = pt._next;\n            if (pt.p === property && !pt.op || pt.op === property) {\n                _removeLinkedListItem(this, pt, \"_pt\");\n            } else if (!pt.dep) {\n                hasNonDependentRemaining = 1;\n            }\n            pt = next;\n        }\n        return !hasNonDependentRemaining;\n    }, _setterWithModifier = function _setterWithModifier(target, property, value, data) {\n        data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);\n    }, _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {\n        var pt = parent._pt, next, pt2, first, last;\n        while(pt){\n            next = pt._next;\n            pt2 = first;\n            while(pt2 && pt2.pr > pt.pr){\n                pt2 = pt2._next;\n            }\n            if (pt._prev = pt2 ? pt2._prev : last) {\n                pt._prev._next = pt;\n            } else {\n                first = pt;\n            }\n            if (pt._next = pt2) {\n                pt2._prev = pt;\n            } else {\n                last = pt;\n            }\n            pt = next;\n        }\n        parent._pt = first;\n    };\n    var PropTween = function() {\n        function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {\n            this.t = target;\n            this.s = start;\n            this.c = change;\n            this.p = prop;\n            this.r = renderer || _renderPlain;\n            this.d = data || this;\n            this.set = setter || _setterPlain;\n            this.pr = priority || 0;\n            this._next = next;\n            if (next) {\n                next._prev = this;\n            }\n        }\n        var _proto4 = PropTween.prototype;\n        _proto4.modifier = function modifier(func, tween, target) {\n            this.mSet = this.mSet || this.set;\n            this.set = _setterWithModifier;\n            this.m = func;\n            this.mt = target;\n            this.tween = tween;\n        };\n        return PropTween;\n    }();\n    _forEachName(_callbackNames + \"parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger\", function(name) {\n        return _reservedProps[name] = 1;\n    });\n    _globals.TweenMax = _globals.TweenLite = Tween;\n    _globals.TimelineLite = _globals.TimelineMax = Timeline;\n    _globalTimeline = new Timeline({\n        sortChildren: false,\n        defaults: _defaults,\n        autoRemoveChildren: true,\n        id: \"root\",\n        smoothChildTiming: true\n    });\n    _config.stringFilter = _colorStringFilter;\n    var _media = [], _listeners = {}, _emptyArray = [], _lastMediaTime = 0, _contextID = 0, _dispatch = function _dispatch(type) {\n        return (_listeners[type] || _emptyArray).map(function(f) {\n            return f();\n        });\n    }, _onMediaChange = function _onMediaChange() {\n        var time = Date.now(), matches = [];\n        if (time - _lastMediaTime > 2) {\n            _dispatch(\"matchMediaInit\");\n            _media.forEach(function(c) {\n                var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;\n                for(p in queries){\n                    match = _win.matchMedia(queries[p]).matches;\n                    match && (anyMatch = 1);\n                    if (match !== conditions[p]) {\n                        conditions[p] = match;\n                        toggled = 1;\n                    }\n                }\n                if (toggled) {\n                    c.revert();\n                    anyMatch && matches.push(c);\n                }\n            });\n            _dispatch(\"matchMediaRevert\");\n            matches.forEach(function(c) {\n                return c.onMatch(c, function(func) {\n                    return c.add(null, func);\n                });\n            });\n            _lastMediaTime = time;\n            _dispatch(\"matchMedia\");\n        }\n    };\n    var Context = function() {\n        function Context(func, scope) {\n            this.selector = scope && selector(scope);\n            this.data = [];\n            this._r = [];\n            this.isReverted = false;\n            this.id = _contextID++;\n            func && this.add(func);\n        }\n        var _proto5 = Context.prototype;\n        _proto5.add = function add(name, func, scope) {\n            if (_isFunction(name)) {\n                scope = func;\n                func = name;\n                name = _isFunction;\n            }\n            var self1 = this, f = function f() {\n                var prev = _context, prevSelector = self1.selector, result;\n                prev && prev !== self1 && prev.data.push(self1);\n                scope && (self1.selector = selector(scope));\n                _context = self1;\n                result = func.apply(self1, arguments);\n                _isFunction(result) && self1._r.push(result);\n                _context = prev;\n                self1.selector = prevSelector;\n                self1.isReverted = false;\n                return result;\n            };\n            self1.last = f;\n            return name === _isFunction ? f(self1, function(func) {\n                return self1.add(null, func);\n            }) : name ? self1[name] = f : f;\n        };\n        _proto5.ignore = function ignore(func) {\n            var prev = _context;\n            _context = null;\n            func(this);\n            _context = prev;\n        };\n        _proto5.getTweens = function getTweens() {\n            var a = [];\n            this.data.forEach(function(e) {\n                return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === \"nested\") && a.push(e);\n            });\n            return a;\n        };\n        _proto5.clear = function clear() {\n            this._r.length = this.data.length = 0;\n        };\n        _proto5.kill = function kill(revert, matchMedia) {\n            var _this4 = this;\n            if (revert) {\n                (function() {\n                    var tweens = _this4.getTweens(), i = _this4.data.length, t;\n                    while(i--){\n                        t = _this4.data[i];\n                        if (t.data === \"isFlip\") {\n                            t.revert();\n                            t.getChildren(true, true, false).forEach(function(tween) {\n                                return tweens.splice(tweens.indexOf(tween), 1);\n                            });\n                        }\n                    }\n                    tweens.map(function(t) {\n                        return {\n                            g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,\n                            t: t\n                        };\n                    }).sort(function(a, b) {\n                        return b.g - a.g || -Infinity;\n                    }).forEach(function(o) {\n                        return o.t.revert(revert);\n                    });\n                    i = _this4.data.length;\n                    while(i--){\n                        t = _this4.data[i];\n                        if (t instanceof Timeline) {\n                            if (t.data !== \"nested\") {\n                                t.scrollTrigger && t.scrollTrigger.revert();\n                                t.kill();\n                            }\n                        } else {\n                            !(t instanceof Tween) && t.revert && t.revert(revert);\n                        }\n                    }\n                    _this4._r.forEach(function(f) {\n                        return f(revert, _this4);\n                    });\n                    _this4.isReverted = true;\n                })();\n            } else {\n                this.data.forEach(function(e) {\n                    return e.kill && e.kill();\n                });\n            }\n            this.clear();\n            if (matchMedia) {\n                var i = _media.length;\n                while(i--){\n                    _media[i].id === this.id && _media.splice(i, 1);\n                }\n            }\n        };\n        _proto5.revert = function revert(config) {\n            this.kill(config || {});\n        };\n        return Context;\n    }();\n    var MatchMedia = function() {\n        function MatchMedia(scope) {\n            this.contexts = [];\n            this.scope = scope;\n            _context && _context.data.push(this);\n        }\n        var _proto6 = MatchMedia.prototype;\n        _proto6.add = function add(conditions, func, scope) {\n            _isObject(conditions) || (conditions = {\n                matches: conditions\n            });\n            var context = new Context(0, scope || this.scope), cond = context.conditions = {}, mq, p, active;\n            _context && !context.selector && (context.selector = _context.selector);\n            this.contexts.push(context);\n            func = context.add(\"onMatch\", func);\n            context.queries = conditions;\n            for(p in conditions){\n                if (p === \"all\") {\n                    active = 1;\n                } else {\n                    mq = _win.matchMedia(conditions[p]);\n                    if (mq) {\n                        _media.indexOf(context) < 0 && _media.push(context);\n                        (cond[p] = mq.matches) && (active = 1);\n                        mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener(\"change\", _onMediaChange);\n                    }\n                }\n            }\n            active && func(context, function(f) {\n                return context.add(null, f);\n            });\n            return this;\n        };\n        _proto6.revert = function revert(config) {\n            this.kill(config || {});\n        };\n        _proto6.kill = function kill(revert) {\n            this.contexts.forEach(function(c) {\n                return c.kill(revert, true);\n            });\n        };\n        return MatchMedia;\n    }();\n    var _gsap = {\n        registerPlugin: function registerPlugin() {\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){\n                args[_key2] = arguments[_key2];\n            }\n            args.forEach(function(config) {\n                return _createPlugin(config);\n            });\n        },\n        timeline: function timeline(vars) {\n            return new Timeline(vars);\n        },\n        getTweensOf: function getTweensOf(targets, onlyActive) {\n            return _globalTimeline.getTweensOf(targets, onlyActive);\n        },\n        getProperty: function getProperty(target, property, unit, uncache) {\n            _isString(target) && (target = toArray(target)[0]);\n            var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;\n            unit === \"native\" && (unit = \"\");\n            return !target ? target : !property ? function(property, unit, uncache) {\n                return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n            } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));\n        },\n        quickSetter: function quickSetter(target, property, unit) {\n            target = toArray(target);\n            if (target.length > 1) {\n                var setters = target.map(function(t) {\n                    return gsap.quickSetter(t, property, unit);\n                }), l = setters.length;\n                return function(value) {\n                    var i = l;\n                    while(i--){\n                        setters[i](value);\n                    }\n                };\n            }\n            target = target[0] || {};\n            var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {\n                var p = new Plugin();\n                _quickTween._pt = 0;\n                p.init(target, unit ? value + unit : value, _quickTween, 0, [\n                    target\n                ]);\n                p.render(1, p);\n                _quickTween._pt && _renderPropTweens(1, _quickTween);\n            } : cache.set(target, p);\n            return Plugin ? setter : function(value) {\n                return setter(target, p, unit ? value + unit : value, cache, 1);\n            };\n        },\n        quickTo: function quickTo(target, property, vars) {\n            var _setDefaults2;\n            var tween = gsap.to(target, _setDefaults((_setDefaults2 = {}, _setDefaults2[property] = \"+=0.1\", _setDefaults2.paused = true, _setDefaults2.stagger = 0, _setDefaults2), vars || {})), func = function func(value, start, startIsRelative) {\n                return tween.resetTo(property, value, start, startIsRelative);\n            };\n            func.tween = tween;\n            return func;\n        },\n        isTweening: function isTweening(targets) {\n            return _globalTimeline.getTweensOf(targets, true).length > 0;\n        },\n        defaults: function defaults(value) {\n            value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));\n            return _mergeDeep(_defaults, value || {});\n        },\n        config: function config(value) {\n            return _mergeDeep(_config, value || {});\n        },\n        registerEffect: function registerEffect(_ref3) {\n            var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults = _ref3.defaults, extendTimeline = _ref3.extendTimeline;\n            (plugins || \"\").split(\",\").forEach(function(pluginName) {\n                return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + \" effect requires \" + pluginName + \" plugin.\");\n            });\n            _effects[name] = function(targets, vars, tl) {\n                return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);\n            };\n            if (extendTimeline) {\n                Timeline.prototype[name] = function(targets, vars, position) {\n                    return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);\n                };\n            }\n        },\n        registerEase: function registerEase(name, ease) {\n            _easeMap[name] = _parseEase(ease);\n        },\n        parseEase: function parseEase(ease, defaultEase) {\n            return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;\n        },\n        getById: function getById(id) {\n            return _globalTimeline.getById(id);\n        },\n        exportRoot: function exportRoot(vars, includeDelayedCalls) {\n            if (vars === void 0) {\n                vars = {};\n            }\n            var tl = new Timeline(vars), child, next;\n            tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);\n            _globalTimeline.remove(tl);\n            tl._dp = 0;\n            tl._time = tl._tTime = _globalTimeline._time;\n            child = _globalTimeline._first;\n            while(child){\n                next = child._next;\n                if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {\n                    _addToTimeline(tl, child, child._start - child._delay);\n                }\n                child = next;\n            }\n            _addToTimeline(_globalTimeline, tl, 0);\n            return tl;\n        },\n        context: function context(func, scope) {\n            return func ? new Context(func, scope) : _context;\n        },\n        matchMedia: function matchMedia(scope) {\n            return new MatchMedia(scope);\n        },\n        matchMediaRefresh: function matchMediaRefresh() {\n            return _media.forEach(function(c) {\n                var cond = c.conditions, found, p;\n                for(p in cond){\n                    if (cond[p]) {\n                        cond[p] = false;\n                        found = 1;\n                    }\n                }\n                found && c.revert();\n            }) || _onMediaChange();\n        },\n        addEventListener: function addEventListener(type, callback) {\n            var a = _listeners[type] || (_listeners[type] = []);\n            ~a.indexOf(callback) || a.push(callback);\n        },\n        removeEventListener: function removeEventListener(type, callback) {\n            var a = _listeners[type], i = a && a.indexOf(callback);\n            i >= 0 && a.splice(i, 1);\n        },\n        utils: {\n            wrap: wrap,\n            wrapYoyo: wrapYoyo,\n            distribute: distribute,\n            random: random,\n            snap: snap,\n            normalize: normalize,\n            getUnit: getUnit,\n            clamp: clamp,\n            splitColor: splitColor,\n            toArray: toArray,\n            selector: selector,\n            mapRange: mapRange,\n            pipe: pipe,\n            unitize: unitize,\n            interpolate: interpolate,\n            shuffle: shuffle\n        },\n        install: _install,\n        effects: _effects,\n        ticker: _ticker,\n        updateRoot: Timeline.updateRoot,\n        plugins: _plugins,\n        globalTimeline: _globalTimeline,\n        core: {\n            PropTween: PropTween,\n            globals: _addGlobal,\n            Tween: Tween,\n            Timeline: Timeline,\n            Animation: Animation,\n            getCache: _getCache,\n            _removeLinkedListItem: _removeLinkedListItem,\n            reverting: function reverting() {\n                return _reverting;\n            },\n            context: function context(toAdd) {\n                if (toAdd && _context) {\n                    _context.data.push(toAdd);\n                    toAdd._ctx = _context;\n                }\n                return _context;\n            },\n            suppressOverwrites: function suppressOverwrites(value) {\n                return _suppressOverwrites = value;\n            }\n        }\n    };\n    _forEachName(\"to,from,fromTo,delayedCall,set,killTweensOf\", function(name) {\n        return _gsap[name] = Tween[name];\n    });\n    _ticker.add(Timeline.updateRoot);\n    _quickTween = _gsap.to({}, {\n        duration: 0\n    });\n    var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {\n        var pt = plugin._pt;\n        while(pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop){\n            pt = pt._next;\n        }\n        return pt;\n    }, _addModifiers = function _addModifiers(tween, modifiers) {\n        var targets = tween._targets, p, i, pt;\n        for(p in modifiers){\n            i = targets.length;\n            while(i--){\n                pt = tween._ptLookup[i][p];\n                if (pt && (pt = pt.d)) {\n                    if (pt._pt) {\n                        pt = _getPluginPropTween(pt, p);\n                    }\n                    pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);\n                }\n            }\n        }\n    }, _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {\n        return {\n            name: name,\n            headless: 1,\n            rawVars: 1,\n            init: function init(target, vars, tween) {\n                tween._onInit = function(tween) {\n                    var temp, p;\n                    if (_isString(vars)) {\n                        temp = {};\n                        _forEachName(vars, function(name) {\n                            return temp[name] = 1;\n                        });\n                        vars = temp;\n                    }\n                    if (modifier) {\n                        temp = {};\n                        for(p in vars){\n                            temp[p] = modifier(vars[p]);\n                        }\n                        vars = temp;\n                    }\n                    _addModifiers(tween, vars);\n                };\n            }\n        };\n    };\n    var gsap = _gsap.registerPlugin({\n        name: \"attr\",\n        init: function init(target, vars, tween, index, targets) {\n            var p, pt, v;\n            this.tween = tween;\n            for(p in vars){\n                v = target.getAttribute(p) || \"\";\n                pt = this.add(target, \"setAttribute\", (v || 0) + \"\", vars[p], index, targets, 0, 0, p);\n                pt.op = p;\n                pt.b = v;\n                this._props.push(p);\n            }\n        },\n        render: function render(ratio, data) {\n            var pt = data._pt;\n            while(pt){\n                _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);\n                pt = pt._next;\n            }\n        }\n    }, {\n        name: \"endArray\",\n        headless: 1,\n        init: function init(target, value) {\n            var i = value.length;\n            while(i--){\n                this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);\n            }\n        }\n    }, _buildModifierPlugin(\"roundProps\", _roundModifier), _buildModifierPlugin(\"modifiers\"), _buildModifierPlugin(\"snap\", snap)) || _gsap;\n    Tween.version = Timeline.version = gsap.version = \"3.13.0\";\n    _coreReady = 1;\n    _windowExists() && _wake();\n    var Power0 = _easeMap.Power0, Power1 = _easeMap.Power1, Power2 = _easeMap.Power2, Power3 = _easeMap.Power3, Power4 = _easeMap.Power4, Linear = _easeMap.Linear, Quad = _easeMap.Quad, Cubic = _easeMap.Cubic, Quart = _easeMap.Quart, Quint = _easeMap.Quint, Strong = _easeMap.Strong, Elastic = _easeMap.Elastic, Back = _easeMap.Back, SteppedEase = _easeMap.SteppedEase, Bounce = _easeMap.Bounce, Sine = _easeMap.Sine, Expo = _easeMap.Expo, Circ = _easeMap.Circ;\n    var _win$1, _doc$1, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _reverting$1, _windowExists$1 = function _windowExists() {\n        return \"undefined\" !== \"undefined\";\n    }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD = Math.PI / 180, _atan2 = Math.atan2, _bigNum$1 = 1e8, _capsExp = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\\s,\\(]\\S/, _propertyAliases = {\n        autoAlpha: \"opacity,visibility\",\n        scale: \"scaleX,scaleY\",\n        alpha: \"opacity\"\n    }, _renderCSSProp = function _renderCSSProp(ratio, data) {\n        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n    }, _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {\n        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);\n    }, _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {\n        return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);\n    }, _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {\n        var value = data.s + data.c * ratio;\n        data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);\n    }, _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {\n        return data.set(data.t, data.p, ratio ? data.e : data.b, data);\n    }, _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {\n        return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);\n    }, _setterCSSStyle = function _setterCSSStyle(target, property, value) {\n        return target.style[property] = value;\n    }, _setterCSSProp = function _setterCSSProp(target, property, value) {\n        return target.style.setProperty(property, value);\n    }, _setterTransform = function _setterTransform(target, property, value) {\n        return target._gsap[property] = value;\n    }, _setterScale = function _setterScale(target, property, value) {\n        return target._gsap.scaleX = target._gsap.scaleY = value;\n    }, _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {\n        var cache = target._gsap;\n        cache.scaleX = cache.scaleY = value;\n        cache.renderTransform(ratio, cache);\n    }, _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {\n        var cache = target._gsap;\n        cache[property] = value;\n        cache.renderTransform(ratio, cache);\n    }, _transformProp = \"transform\", _transformOriginProp = _transformProp + \"Origin\", _saveStyle = function _saveStyle(property, isNotCSS) {\n        var _this = this;\n        var target = this.target, style = target.style, cache = target._gsap;\n        if (property in _transformProps && style) {\n            this.tfm = this.tfm || {};\n            if (property !== \"transform\") {\n                property = _propertyAliases[property] || property;\n                ~property.indexOf(\",\") ? property.split(\",\").forEach(function(a) {\n                    return _this.tfm[a] = _get(target, a);\n                }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);\n                property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);\n            } else {\n                return _propertyAliases.transform.split(\",\").forEach(function(p) {\n                    return _saveStyle.call(_this, p, isNotCSS);\n                });\n            }\n            if (this.props.indexOf(_transformProp) >= 0) {\n                return;\n            }\n            if (cache.svg) {\n                this.svgo = target.getAttribute(\"data-svg-origin\");\n                this.props.push(_transformOriginProp, isNotCSS, \"\");\n            }\n            property = _transformProp;\n        }\n        (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);\n    }, _removeIndependentTransforms = function _removeIndependentTransforms(style) {\n        if (style.translate) {\n            style.removeProperty(\"translate\");\n            style.removeProperty(\"scale\");\n            style.removeProperty(\"rotate\");\n        }\n    }, _revertStyle = function _revertStyle() {\n        var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;\n        for(i = 0; i < props.length; i += 3){\n            if (!props[i + 1]) {\n                props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === \"--\" ? props[i] : props[i].replace(_capsExp, \"-$1\").toLowerCase());\n            } else if (props[i + 1] === 2) {\n                target[props[i]](props[i + 2]);\n            } else {\n                target[props[i]] = props[i + 2];\n            }\n        }\n        if (this.tfm) {\n            for(p in this.tfm){\n                cache[p] = this.tfm[p];\n            }\n            if (cache.svg) {\n                cache.renderTransform();\n                target.setAttribute(\"data-svg-origin\", this.svgo || \"\");\n            }\n            i = _reverting$1();\n            if ((!i || !i.isStart) && !style[_transformProp]) {\n                _removeIndependentTransforms(style);\n                if (cache.zOrigin && style[_transformOriginProp]) {\n                    style[_transformOriginProp] += \" \" + cache.zOrigin + \"px\";\n                    cache.zOrigin = 0;\n                    cache.renderTransform();\n                }\n                cache.uncache = 1;\n            }\n        }\n    }, _getStyleSaver = function _getStyleSaver(target, properties) {\n        var saver = {\n            target: target,\n            props: [],\n            revert: _revertStyle,\n            save: _saveStyle\n        };\n        target._gsap || gsap.core.getCache(target);\n        properties && target.style && target.nodeType && properties.split(\",\").forEach(function(p) {\n            return saver.save(p);\n        });\n        return saver;\n    }, _supports3D, _createElement = function _createElement(type, ns) {\n        var e = _doc$1.createElementNS ? _doc$1.createElementNS((ns || \"http://www.w3.org/1999/xhtml\").replace(/^https/, \"http\"), type) : _doc$1.createElement(type);\n        return e && e.style ? e : _doc$1.createElement(type);\n    }, _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {\n        var cs = getComputedStyle(target);\n        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, \"-$1\").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || \"\";\n    }, _prefixes = \"O,Moz,ms,Ms,Webkit\".split(\",\"), _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {\n        var e = element || _tempDiv, s = e.style, i = 5;\n        if (property in s && !preferPrefix) {\n            return property;\n        }\n        property = property.charAt(0).toUpperCase() + property.substr(1);\n        while(i-- && !(_prefixes[i] + property in s)){}\n        return i < 0 ? null : (i === 3 ? \"ms\" : i >= 0 ? _prefixes[i] : \"\") + property;\n    }, _initCore = function _initCore() {\n        if (_windowExists$1() && window.document) {\n            _win$1 = window;\n            _doc$1 = _win$1.document;\n            _docElement = _doc$1.documentElement;\n            _tempDiv = _createElement(\"div\") || {\n                style: {}\n            };\n            _tempDivStyler = _createElement(\"div\");\n            _transformProp = _checkPropPrefix(_transformProp);\n            _transformOriginProp = _transformProp + \"Origin\";\n            _tempDiv.style.cssText = \"border-width:0;line-height:0;position:absolute;padding:0\";\n            _supports3D = !!_checkPropPrefix(\"perspective\");\n            _reverting$1 = gsap.core.reverting;\n            _pluginInitted = 1;\n        }\n    }, _getReparentedCloneBBox = function _getReparentedCloneBBox(target) {\n        var owner = target.ownerSVGElement, svg = _createElement(\"svg\", owner && owner.getAttribute(\"xmlns\") || \"http://www.w3.org/2000/svg\"), clone = target.cloneNode(true), bbox;\n        clone.style.display = \"block\";\n        svg.appendChild(clone);\n        _docElement.appendChild(svg);\n        try {\n            bbox = clone.getBBox();\n        } catch (e) {}\n        svg.removeChild(clone);\n        _docElement.removeChild(svg);\n        return bbox;\n    }, _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {\n        var i = attributesArray.length;\n        while(i--){\n            if (target.hasAttribute(attributesArray[i])) {\n                return target.getAttribute(attributesArray[i]);\n            }\n        }\n    }, _getBBox = function _getBBox(target) {\n        var bounds, cloned;\n        try {\n            bounds = target.getBBox();\n        } catch (error) {\n            bounds = _getReparentedCloneBBox(target);\n            cloned = 1;\n        }\n        bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target));\n        return bounds && !bounds.width && !bounds.x && !bounds.y ? {\n            x: +_getAttributeFallbacks(target, [\n                \"x\",\n                \"cx\",\n                \"x1\"\n            ]) || 0,\n            y: +_getAttributeFallbacks(target, [\n                \"y\",\n                \"cy\",\n                \"y1\"\n            ]) || 0,\n            width: 0,\n            height: 0\n        } : bounds;\n    }, _isSVG = function _isSVG(e) {\n        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));\n    }, _removeProperty = function _removeProperty(target, property) {\n        if (property) {\n            var style = target.style, first2Chars;\n            if (property in _transformProps && property !== _transformOriginProp) {\n                property = _transformProp;\n            }\n            if (style.removeProperty) {\n                first2Chars = property.substr(0, 2);\n                if (first2Chars === \"ms\" || property.substr(0, 6) === \"webkit\") {\n                    property = \"-\" + property;\n                }\n                style.removeProperty(first2Chars === \"--\" ? property : property.replace(_capsExp, \"-$1\").toLowerCase());\n            } else {\n                style.removeAttribute(property);\n            }\n        }\n    }, _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {\n        var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);\n        plugin._pt = pt;\n        pt.b = beginning;\n        pt.e = end;\n        plugin._props.push(property);\n        return pt;\n    }, _nonConvertibleUnits = {\n        deg: 1,\n        rad: 1,\n        turn: 1\n    }, _nonStandardLayouts = {\n        grid: 1,\n        flex: 1\n    }, _convertToUnit = function _convertToUnit(target, property, value, unit) {\n        var curValue = parseFloat(value) || 0, curUnit = (value + \"\").trim().substr((curValue + \"\").length) || \"px\", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === \"svg\", measureProperty = (isRootSVG ? \"client\" : \"offset\") + (horizontal ? \"Width\" : \"Height\"), amount = 100, toPixels = unit === \"px\", toPercent = unit === \"%\", px, parent, cache, isSVG;\n        if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {\n            return curValue;\n        }\n        curUnit !== \"px\" && !toPixels && (curValue = _convertToUnit(target, property, value, \"px\"));\n        isSVG = target.getCTM && _isSVG(target);\n        if ((toPercent || curUnit === \"%\") && (_transformProps[property] || ~property.indexOf(\"adius\"))) {\n            px = isSVG ? target.getBBox()[horizontal ? \"width\" : \"height\"] : target[measureProperty];\n            return _round(toPercent ? curValue / px * amount : curValue / 100 * px);\n        }\n        style[horizontal ? \"width\" : \"height\"] = amount + (toPixels ? curUnit : unit);\n        parent = unit !== \"rem\" && ~property.indexOf(\"adius\") || unit === \"em\" && target.appendChild && !isRootSVG ? target : target.parentNode;\n        if (isSVG) {\n            parent = (target.ownerSVGElement || {}).parentNode;\n        }\n        if (!parent || parent === _doc$1 || !parent.appendChild) {\n            parent = _doc$1.body;\n        }\n        cache = parent._gsap;\n        if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {\n            return _round(curValue / cache.width * amount);\n        } else {\n            if (toPercent && (property === \"height\" || property === \"width\")) {\n                var v = target.style[property];\n                target.style[property] = amount + unit;\n                px = target[measureProperty];\n                v ? target.style[property] = v : _removeProperty(target, property);\n            } else {\n                (toPercent || curUnit === \"%\") && !_nonStandardLayouts[_getComputedProperty(parent, \"display\")] && (style.position = _getComputedProperty(target, \"position\"));\n                parent === target && (style.position = \"static\");\n                parent.appendChild(_tempDiv);\n                px = _tempDiv[measureProperty];\n                parent.removeChild(_tempDiv);\n                style.position = \"absolute\";\n            }\n            if (horizontal && toPercent) {\n                cache = _getCache(parent);\n                cache.time = _ticker.time;\n                cache.width = parent[measureProperty];\n            }\n        }\n        return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);\n    }, _get = function _get(target, property, unit, uncache) {\n        var value;\n        _pluginInitted || _initCore();\n        if (property in _propertyAliases && property !== \"transform\") {\n            property = _propertyAliases[property];\n            if (~property.indexOf(\",\")) {\n                property = property.split(\",\")[0];\n            }\n        }\n        if (_transformProps[property] && property !== \"transform\") {\n            value = _parseTransform(target, uncache);\n            value = property !== \"transformOrigin\" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + \" \" + value.zOrigin + \"px\";\n        } else {\n            value = target.style[property];\n            if (!value || value === \"auto\" || uncache || ~(value + \"\").indexOf(\"calc(\")) {\n                value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === \"opacity\" ? 1 : 0);\n            }\n        }\n        return unit && !~(value + \"\").trim().indexOf(\" \") ? _convertToUnit(target, property, value, unit) + unit : value;\n    }, _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {\n        if (!start || start === \"none\") {\n            var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);\n            if (s && s !== start) {\n                prop = p;\n                start = s;\n            } else if (prop === \"borderColor\") {\n                start = _getComputedProperty(target, \"borderTopColor\");\n            }\n        }\n        var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;\n        pt.b = start;\n        pt.e = end;\n        start += \"\";\n        end += \"\";\n        if (end.substring(0, 6) === \"var(--\") {\n            end = _getComputedProperty(target, end.substring(4, end.indexOf(\")\")));\n        }\n        if (end === \"auto\") {\n            startValue = target.style[prop];\n            target.style[prop] = end;\n            end = _getComputedProperty(target, prop) || end;\n            startValue ? target.style[prop] = startValue : _removeProperty(target, prop);\n        }\n        a = [\n            start,\n            end\n        ];\n        _colorStringFilter(a);\n        start = a[0];\n        end = a[1];\n        startValues = start.match(_numWithUnitExp) || [];\n        endValues = end.match(_numWithUnitExp) || [];\n        if (endValues.length) {\n            while(result = _numWithUnitExp.exec(end)){\n                endValue = result[0];\n                chunk = end.substring(index, result.index);\n                if (color) {\n                    color = (color + 1) % 5;\n                } else if (chunk.substr(-5) === \"rgba(\" || chunk.substr(-5) === \"hsla(\") {\n                    color = 1;\n                }\n                if (endValue !== (startValue = startValues[matchIndex++] || \"\")) {\n                    startNum = parseFloat(startValue) || 0;\n                    startUnit = startValue.substr((startNum + \"\").length);\n                    endValue.charAt(1) === \"=\" && (endValue = _parseRelative(startNum, endValue) + startUnit);\n                    endNum = parseFloat(endValue);\n                    endUnit = endValue.substr((endNum + \"\").length);\n                    index = _numWithUnitExp.lastIndex - endUnit.length;\n                    if (!endUnit) {\n                        endUnit = endUnit || _config.units[prop] || startUnit;\n                        if (index === end.length) {\n                            end += endUnit;\n                            pt.e += endUnit;\n                        }\n                    }\n                    if (startUnit !== endUnit) {\n                        startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;\n                    }\n                    pt._pt = {\n                        _next: pt._pt,\n                        p: chunk || matchIndex === 1 ? chunk : \",\",\n                        s: startNum,\n                        c: endNum - startNum,\n                        m: color && color < 4 || prop === \"zIndex\" ? Math.round : 0\n                    };\n                }\n            }\n            pt.c = index < end.length ? end.substring(index, end.length) : \"\";\n        } else {\n            pt.r = prop === \"display\" && end === \"none\" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;\n        }\n        _relExp.test(end) && (pt.e = 0);\n        this._pt = pt;\n        return pt;\n    }, _keywordToPercent = {\n        top: \"0%\",\n        bottom: \"100%\",\n        left: \"0%\",\n        right: \"100%\",\n        center: \"50%\"\n    }, _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {\n        var split = value.split(\" \"), x = split[0], y = split[1] || \"50%\";\n        if (x === \"top\" || x === \"bottom\" || y === \"left\" || y === \"right\") {\n            value = x;\n            x = y;\n            y = value;\n        }\n        split[0] = _keywordToPercent[x] || x;\n        split[1] = _keywordToPercent[y] || y;\n        return split.join(\" \");\n    }, _renderClearProps = function _renderClearProps(ratio, data) {\n        if (data.tween && data.tween._time === data.tween._dur) {\n            var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;\n            if (props === \"all\" || props === true) {\n                style.cssText = \"\";\n                clearTransforms = 1;\n            } else {\n                props = props.split(\",\");\n                i = props.length;\n                while(--i > -1){\n                    prop = props[i];\n                    if (_transformProps[prop]) {\n                        clearTransforms = 1;\n                        prop = prop === \"transformOrigin\" ? _transformOriginProp : _transformProp;\n                    }\n                    _removeProperty(target, prop);\n                }\n            }\n            if (clearTransforms) {\n                _removeProperty(target, _transformProp);\n                if (cache) {\n                    cache.svg && target.removeAttribute(\"transform\");\n                    style.scale = style.rotate = style.translate = \"none\";\n                    _parseTransform(target, 1);\n                    cache.uncache = 1;\n                    _removeIndependentTransforms(style);\n                }\n            }\n        }\n    }, _specialProps = {\n        clearProps: function clearProps(plugin, target, property, endValue, tween) {\n            if (tween.data !== \"isFromStart\") {\n                var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);\n                pt.u = endValue;\n                pt.pr = -10;\n                pt.tween = tween;\n                plugin._props.push(property);\n                return 1;\n            }\n        }\n    }, _identity2DMatrix = [\n        1,\n        0,\n        0,\n        1,\n        0,\n        0\n    ], _rotationalProperties = {}, _isNullTransform = function _isNullTransform(value) {\n        return value === \"matrix(1, 0, 0, 1, 0, 0)\" || value === \"none\" || !value;\n    }, _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {\n        var matrixString = _getComputedProperty(target, _transformProp);\n        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);\n    }, _getMatrix = function _getMatrix(target, force2D) {\n        var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent, nextSibling, temp, addedToDOM;\n        if (cache.svg && target.getAttribute(\"transform\")) {\n            temp = target.transform.baseVal.consolidate().matrix;\n            matrix = [\n                temp.a,\n                temp.b,\n                temp.c,\n                temp.d,\n                temp.e,\n                temp.f\n            ];\n            return matrix.join(\",\") === \"1,0,0,1,0,0\" ? _identity2DMatrix : matrix;\n        } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {\n            temp = style.display;\n            style.display = \"block\";\n            parent = target.parentNode;\n            if (!parent || !target.offsetParent && !target.getBoundingClientRect().width) {\n                addedToDOM = 1;\n                nextSibling = target.nextElementSibling;\n                _docElement.appendChild(target);\n            }\n            matrix = _getComputedTransformMatrixAsArray(target);\n            temp ? style.display = temp : _removeProperty(target, \"display\");\n            if (addedToDOM) {\n                nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);\n            }\n        }\n        return force2D && matrix.length > 6 ? [\n            matrix[0],\n            matrix[1],\n            matrix[4],\n            matrix[5],\n            matrix[12],\n            matrix[13]\n        ] : matrix;\n    }, _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {\n        var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(\" \"), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;\n        if (!originIsAbsolute) {\n            bounds = _getBBox(target);\n            xOrigin = bounds.x + (~originSplit[0].indexOf(\"%\") ? xOrigin / 100 * bounds.width : xOrigin);\n            yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf(\"%\") ? yOrigin / 100 * bounds.height : yOrigin);\n        } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {\n            x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;\n            y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;\n            xOrigin = x;\n            yOrigin = y;\n        }\n        if (smooth || smooth !== false && cache.smooth) {\n            tx = xOrigin - xOriginOld;\n            ty = yOrigin - yOriginOld;\n            cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;\n            cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;\n        } else {\n            cache.xOffset = cache.yOffset = 0;\n        }\n        cache.xOrigin = xOrigin;\n        cache.yOrigin = yOrigin;\n        cache.smooth = !!smooth;\n        cache.origin = origin;\n        cache.originIsAbsolute = !!originIsAbsolute;\n        target.style[_transformOriginProp] = \"0px 0px\";\n        if (pluginToAddPropTweensTo) {\n            _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOrigin\", xOriginOld, xOrigin);\n            _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOrigin\", yOriginOld, yOrigin);\n            _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"xOffset\", xOffsetOld, cache.xOffset);\n            _addNonTweeningPT(pluginToAddPropTweensTo, cache, \"yOffset\", yOffsetOld, cache.yOffset);\n        }\n        target.setAttribute(\"data-svg-origin\", xOrigin + \" \" + yOrigin);\n    }, _parseTransform = function _parseTransform(target, uncache) {\n        var cache = target._gsap || new GSCache(target);\n        if (\"x\" in cache && !uncache && !cache.uncache) {\n            return cache;\n        }\n        var style = target.style, invertedScaleX = cache.scaleX < 0, px = \"px\", deg = \"deg\", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || \"0\", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;\n        x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;\n        scaleX = scaleY = 1;\n        cache.svg = !!(target.getCTM && _isSVG(target));\n        if (cs.translate) {\n            if (cs.translate !== \"none\" || cs.scale !== \"none\" || cs.rotate !== \"none\") {\n                style[_transformProp] = (cs.translate !== \"none\" ? \"translate3d(\" + (cs.translate + \" 0 0\").split(\" \").slice(0, 3).join(\", \") + \") \" : \"\") + (cs.rotate !== \"none\" ? \"rotate(\" + cs.rotate + \") \" : \"\") + (cs.scale !== \"none\" ? \"scale(\" + cs.scale.split(\" \").join(\",\") + \") \" : \"\") + (cs[_transformProp] !== \"none\" ? cs[_transformProp] : \"\");\n            }\n            style.scale = style.rotate = style.translate = \"none\";\n        }\n        matrix = _getMatrix(target, cache.svg);\n        if (cache.svg) {\n            if (cache.uncache) {\n                t2 = target.getBBox();\n                origin = cache.xOrigin - t2.x + \"px \" + (cache.yOrigin - t2.y) + \"px\";\n                t1 = \"\";\n            } else {\n                t1 = !uncache && target.getAttribute(\"data-svg-origin\");\n            }\n            _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);\n        }\n        xOrigin = cache.xOrigin || 0;\n        yOrigin = cache.yOrigin || 0;\n        if (matrix !== _identity2DMatrix) {\n            a = matrix[0];\n            b = matrix[1];\n            c = matrix[2];\n            d = matrix[3];\n            x = a12 = matrix[4];\n            y = a22 = matrix[5];\n            if (matrix.length === 6) {\n                scaleX = Math.sqrt(a * a + b * b);\n                scaleY = Math.sqrt(d * d + c * c);\n                rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;\n                skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;\n                skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));\n                if (cache.svg) {\n                    x -= xOrigin - (xOrigin * a + yOrigin * c);\n                    y -= yOrigin - (xOrigin * b + yOrigin * d);\n                }\n            } else {\n                a32 = matrix[6];\n                a42 = matrix[7];\n                a13 = matrix[8];\n                a23 = matrix[9];\n                a33 = matrix[10];\n                a43 = matrix[11];\n                x = matrix[12];\n                y = matrix[13];\n                z = matrix[14];\n                angle = _atan2(a32, a33);\n                rotationX = angle * _RAD2DEG;\n                if (angle) {\n                    cos = Math.cos(-angle);\n                    sin = Math.sin(-angle);\n                    t1 = a12 * cos + a13 * sin;\n                    t2 = a22 * cos + a23 * sin;\n                    t3 = a32 * cos + a33 * sin;\n                    a13 = a12 * -sin + a13 * cos;\n                    a23 = a22 * -sin + a23 * cos;\n                    a33 = a32 * -sin + a33 * cos;\n                    a43 = a42 * -sin + a43 * cos;\n                    a12 = t1;\n                    a22 = t2;\n                    a32 = t3;\n                }\n                angle = _atan2(-c, a33);\n                rotationY = angle * _RAD2DEG;\n                if (angle) {\n                    cos = Math.cos(-angle);\n                    sin = Math.sin(-angle);\n                    t1 = a * cos - a13 * sin;\n                    t2 = b * cos - a23 * sin;\n                    t3 = c * cos - a33 * sin;\n                    a43 = d * sin + a43 * cos;\n                    a = t1;\n                    b = t2;\n                    c = t3;\n                }\n                angle = _atan2(b, a);\n                rotation = angle * _RAD2DEG;\n                if (angle) {\n                    cos = Math.cos(angle);\n                    sin = Math.sin(angle);\n                    t1 = a * cos + b * sin;\n                    t2 = a12 * cos + a22 * sin;\n                    b = b * cos - a * sin;\n                    a22 = a22 * cos - a12 * sin;\n                    a = t1;\n                    a12 = t2;\n                }\n                if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {\n                    rotationX = rotation = 0;\n                    rotationY = 180 - rotationY;\n                }\n                scaleX = _round(Math.sqrt(a * a + b * b + c * c));\n                scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));\n                angle = _atan2(a12, a22);\n                skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;\n                perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;\n            }\n            if (cache.svg) {\n                t1 = target.getAttribute(\"transform\");\n                cache.forceCSS = target.setAttribute(\"transform\", \"\") || !_isNullTransform(_getComputedProperty(target, _transformProp));\n                t1 && target.setAttribute(\"transform\", t1);\n            }\n        }\n        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {\n            if (invertedScaleX) {\n                scaleX *= -1;\n                skewX += rotation <= 0 ? 180 : -180;\n                rotation += rotation <= 0 ? 180 : -180;\n            } else {\n                scaleY *= -1;\n                skewX += skewX <= 0 ? 180 : -180;\n            }\n        }\n        uncache = uncache || cache.uncache;\n        cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;\n        cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;\n        cache.z = z + px;\n        cache.scaleX = _round(scaleX);\n        cache.scaleY = _round(scaleY);\n        cache.rotation = _round(rotation) + deg;\n        cache.rotationX = _round(rotationX) + deg;\n        cache.rotationY = _round(rotationY) + deg;\n        cache.skewX = skewX + deg;\n        cache.skewY = skewY + deg;\n        cache.transformPerspective = perspective + px;\n        if (cache.zOrigin = parseFloat(origin.split(\" \")[2]) || !uncache && cache.zOrigin || 0) {\n            style[_transformOriginProp] = _firstTwoOnly(origin);\n        }\n        cache.xOffset = cache.yOffset = 0;\n        cache.force3D = _config.force3D;\n        cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;\n        cache.uncache = 0;\n        return cache;\n    }, _firstTwoOnly = function _firstTwoOnly(value) {\n        return (value = value.split(\" \"))[0] + \" \" + value[1];\n    }, _addPxTranslate = function _addPxTranslate(target, start, value) {\n        var unit = getUnit(start);\n        return _round(parseFloat(start) + parseFloat(_convertToUnit(target, \"x\", value + \"px\", unit))) + unit;\n    }, _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {\n        cache.z = \"0px\";\n        cache.rotationY = cache.rotationX = \"0deg\";\n        cache.force3D = 0;\n        _renderCSSTransforms(ratio, cache);\n    }, _zeroDeg = \"0deg\", _zeroPx = \"0px\", _endParenthesis = \") \", _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {\n        var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = \"\", use3D = force3D === \"auto\" && ratio && ratio !== 1 || force3D === true;\n        if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {\n            var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;\n            angle = parseFloat(rotationX) * _DEG2RAD;\n            cos = Math.cos(angle);\n            x = _addPxTranslate(target, x, a13 * cos * -zOrigin);\n            y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);\n            z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);\n        }\n        if (transformPerspective !== _zeroPx) {\n            transforms += \"perspective(\" + transformPerspective + _endParenthesis;\n        }\n        if (xPercent || yPercent) {\n            transforms += \"translate(\" + xPercent + \"%, \" + yPercent + \"%) \";\n        }\n        if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {\n            transforms += z !== _zeroPx || use3D ? \"translate3d(\" + x + \", \" + y + \", \" + z + \") \" : \"translate(\" + x + \", \" + y + _endParenthesis;\n        }\n        if (rotation !== _zeroDeg) {\n            transforms += \"rotate(\" + rotation + _endParenthesis;\n        }\n        if (rotationY !== _zeroDeg) {\n            transforms += \"rotateY(\" + rotationY + _endParenthesis;\n        }\n        if (rotationX !== _zeroDeg) {\n            transforms += \"rotateX(\" + rotationX + _endParenthesis;\n        }\n        if (skewX !== _zeroDeg || skewY !== _zeroDeg) {\n            transforms += \"skew(\" + skewX + \", \" + skewY + _endParenthesis;\n        }\n        if (scaleX !== 1 || scaleY !== 1) {\n            transforms += \"scale(\" + scaleX + \", \" + scaleY + _endParenthesis;\n        }\n        target.style[_transformProp] = transforms || \"translate(0, 0)\";\n    }, _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {\n        var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;\n        rotation = parseFloat(rotation);\n        skewX = parseFloat(skewX);\n        skewY = parseFloat(skewY);\n        if (skewY) {\n            skewY = parseFloat(skewY);\n            skewX += skewY;\n            rotation += skewY;\n        }\n        if (rotation || skewX) {\n            rotation *= _DEG2RAD;\n            skewX *= _DEG2RAD;\n            a11 = Math.cos(rotation) * scaleX;\n            a21 = Math.sin(rotation) * scaleX;\n            a12 = Math.sin(rotation - skewX) * -scaleY;\n            a22 = Math.cos(rotation - skewX) * scaleY;\n            if (skewX) {\n                skewY *= _DEG2RAD;\n                temp = Math.tan(skewX - skewY);\n                temp = Math.sqrt(1 + temp * temp);\n                a12 *= temp;\n                a22 *= temp;\n                if (skewY) {\n                    temp = Math.tan(skewY);\n                    temp = Math.sqrt(1 + temp * temp);\n                    a11 *= temp;\n                    a21 *= temp;\n                }\n            }\n            a11 = _round(a11);\n            a21 = _round(a21);\n            a12 = _round(a12);\n            a22 = _round(a22);\n        } else {\n            a11 = scaleX;\n            a22 = scaleY;\n            a21 = a12 = 0;\n        }\n        if (tx && !~(x + \"\").indexOf(\"px\") || ty && !~(y + \"\").indexOf(\"px\")) {\n            tx = _convertToUnit(target, \"x\", x, \"px\");\n            ty = _convertToUnit(target, \"y\", y, \"px\");\n        }\n        if (xOrigin || yOrigin || xOffset || yOffset) {\n            tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);\n            ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);\n        }\n        if (xPercent || yPercent) {\n            temp = target.getBBox();\n            tx = _round(tx + xPercent / 100 * temp.width);\n            ty = _round(ty + yPercent / 100 * temp.height);\n        }\n        temp = \"matrix(\" + a11 + \",\" + a21 + \",\" + a12 + \",\" + a22 + \",\" + tx + \",\" + ty + \")\";\n        target.setAttribute(\"transform\", temp);\n        forceCSS && (target.style[_transformProp] = temp);\n    }, _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {\n        var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf(\"rad\") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + \"deg\", direction, pt;\n        if (isString) {\n            direction = endValue.split(\"_\")[1];\n            if (direction === \"short\") {\n                change %= cap;\n                if (change !== change % (cap / 2)) {\n                    change += change < 0 ? cap : -cap;\n                }\n            }\n            if (direction === \"cw\" && change < 0) {\n                change = (change + cap * _bigNum$1) % cap - ~~(change / cap) * cap;\n            } else if (direction === \"ccw\" && change > 0) {\n                change = (change - cap * _bigNum$1) % cap - ~~(change / cap) * cap;\n            }\n        }\n        plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);\n        pt.e = finalValue;\n        pt.u = \"deg\";\n        plugin._props.push(property);\n        return pt;\n    }, _assign = function _assign(target, source) {\n        for(var p in source){\n            target[p] = source[p];\n        }\n        return target;\n    }, _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {\n        var startCache = _assign({}, target._gsap), exclude = \"perspective,force3D,transformOrigin,svgOrigin\", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;\n        if (startCache.svg) {\n            startValue = target.getAttribute(\"transform\");\n            target.setAttribute(\"transform\", \"\");\n            style[_transformProp] = transforms;\n            endCache = _parseTransform(target, 1);\n            _removeProperty(target, _transformProp);\n            target.setAttribute(\"transform\", startValue);\n        } else {\n            startValue = getComputedStyle(target)[_transformProp];\n            style[_transformProp] = transforms;\n            endCache = _parseTransform(target, 1);\n            style[_transformProp] = startValue;\n        }\n        for(p in _transformProps){\n            startValue = startCache[p];\n            endValue = endCache[p];\n            if (startValue !== endValue && exclude.indexOf(p) < 0) {\n                startUnit = getUnit(startValue);\n                endUnit = getUnit(endValue);\n                startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);\n                endNum = parseFloat(endValue);\n                plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);\n                plugin._pt.u = endUnit || 0;\n                plugin._props.push(p);\n            }\n        }\n        _assign(endCache, startCache);\n    };\n    _forEachName(\"padding,margin,Width,Radius\", function(name, index) {\n        var t = \"Top\", r = \"Right\", b = \"Bottom\", l = \"Left\", props = (index < 3 ? [\n            t,\n            r,\n            b,\n            l\n        ] : [\n            t + l,\n            t + r,\n            b + r,\n            b + l\n        ]).map(function(side) {\n            return index < 2 ? name + side : \"border\" + side + name;\n        });\n        _specialProps[index > 1 ? \"border\" + name : name] = function(plugin, target, property, endValue, tween) {\n            var a, vars;\n            if (arguments.length < 4) {\n                a = props.map(function(prop) {\n                    return _get(plugin, prop, property);\n                });\n                vars = a.join(\" \");\n                return vars.split(a[0]).length === 5 ? a[0] : vars;\n            }\n            a = (endValue + \"\").split(\" \");\n            vars = {};\n            props.forEach(function(prop, i) {\n                return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];\n            });\n            plugin.init(target, vars, tween);\n        };\n    });\n    var CSSPlugin = {\n        name: \"css\",\n        register: _initCore,\n        targetTest: function targetTest(target) {\n            return target.style && target.nodeType;\n        },\n        init: function init(target, vars, tween, index, targets) {\n            var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;\n            _pluginInitted || _initCore();\n            this.styles = this.styles || _getStyleSaver(target);\n            inlineProps = this.styles.props;\n            this.tween = tween;\n            for(p in vars){\n                if (p === \"autoRound\") {\n                    continue;\n                }\n                endValue = vars[p];\n                if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {\n                    continue;\n                }\n                type = typeof endValue;\n                specialProp = _specialProps[p];\n                if (type === \"function\") {\n                    endValue = endValue.call(tween, index, target, targets);\n                    type = typeof endValue;\n                }\n                if (type === \"string\" && ~endValue.indexOf(\"random(\")) {\n                    endValue = _replaceRandom(endValue);\n                }\n                if (specialProp) {\n                    specialProp(this, target, p, endValue, tween) && (hasPriority = 1);\n                } else if (p.substr(0, 2) === \"--\") {\n                    startValue = (getComputedStyle(target).getPropertyValue(p) + \"\").trim();\n                    endValue += \"\";\n                    _colorExp.lastIndex = 0;\n                    if (!_colorExp.test(startValue)) {\n                        startUnit = getUnit(startValue);\n                        endUnit = getUnit(endValue);\n                    }\n                    endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);\n                    this.add(style, \"setProperty\", startValue, endValue, index, targets, 0, 0, p);\n                    props.push(p);\n                    inlineProps.push(p, 0, style[p]);\n                } else if (type !== \"undefined\") {\n                    if (startAt && p in startAt) {\n                        startValue = typeof startAt[p] === \"function\" ? startAt[p].call(tween, index, target, targets) : startAt[p];\n                        _isString(startValue) && ~startValue.indexOf(\"random(\") && (startValue = _replaceRandom(startValue));\n                        getUnit(startValue + \"\") || startValue === \"auto\" || (startValue += _config.units[p] || getUnit(_get(target, p)) || \"\");\n                        (startValue + \"\").charAt(1) === \"=\" && (startValue = _get(target, p));\n                    } else {\n                        startValue = _get(target, p);\n                    }\n                    startNum = parseFloat(startValue);\n                    relative = type === \"string\" && endValue.charAt(1) === \"=\" && endValue.substr(0, 2);\n                    relative && (endValue = endValue.substr(2));\n                    endNum = parseFloat(endValue);\n                    if (p in _propertyAliases) {\n                        if (p === \"autoAlpha\") {\n                            if (startNum === 1 && _get(target, \"visibility\") === \"hidden\" && endNum) {\n                                startNum = 0;\n                            }\n                            inlineProps.push(\"visibility\", 0, style.visibility);\n                            _addNonTweeningPT(this, style, \"visibility\", startNum ? \"inherit\" : \"hidden\", endNum ? \"inherit\" : \"hidden\", !endNum);\n                        }\n                        if (p !== \"scale\" && p !== \"transform\") {\n                            p = _propertyAliases[p];\n                            ~p.indexOf(\",\") && (p = p.split(\",\")[0]);\n                        }\n                    }\n                    isTransformRelated = p in _transformProps;\n                    if (isTransformRelated) {\n                        this.styles.save(p);\n                        if (type === \"string\" && endValue.substring(0, 6) === \"var(--\") {\n                            endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(\")\")));\n                            endNum = parseFloat(endValue);\n                        }\n                        if (!transformPropTween) {\n                            cache = target._gsap;\n                            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);\n                            smooth = vars.smoothOrigin !== false && cache.smooth;\n                            transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);\n                            transformPropTween.dep = 1;\n                        }\n                        if (p === \"scale\") {\n                            this._pt = new PropTween(this._pt, cache, \"scaleY\", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);\n                            this._pt.u = 0;\n                            props.push(\"scaleY\", p);\n                            p += \"X\";\n                        } else if (p === \"transformOrigin\") {\n                            inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);\n                            endValue = _convertKeywordsToPercentages(endValue);\n                            if (cache.svg) {\n                                _applySVGOrigin(target, endValue, 0, smooth, 0, this);\n                            } else {\n                                endUnit = parseFloat(endValue.split(\" \")[2]) || 0;\n                                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, \"zOrigin\", cache.zOrigin, endUnit);\n                                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));\n                            }\n                            continue;\n                        } else if (p === \"svgOrigin\") {\n                            _applySVGOrigin(target, endValue, 1, smooth, 0, this);\n                            continue;\n                        } else if (p in _rotationalProperties) {\n                            _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);\n                            continue;\n                        } else if (p === \"smoothOrigin\") {\n                            _addNonTweeningPT(this, cache, \"smooth\", cache.smooth, endValue);\n                            continue;\n                        } else if (p === \"force3D\") {\n                            cache[p] = endValue;\n                            continue;\n                        } else if (p === \"transform\") {\n                            _addRawTransformPTs(this, endValue, target);\n                            continue;\n                        }\n                    } else if (!(p in style)) {\n                        p = _checkPropPrefix(p) || p;\n                    }\n                    if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {\n                        startUnit = (startValue + \"\").substr((startNum + \"\").length);\n                        endNum || (endNum = 0);\n                        endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);\n                        startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));\n                        this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === \"px\" || p === \"zIndex\") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);\n                        this._pt.u = endUnit || 0;\n                        if (startUnit !== endUnit && endUnit !== \"%\") {\n                            this._pt.b = startValue;\n                            this._pt.r = _renderCSSPropWithBeginning;\n                        }\n                    } else if (!(p in style)) {\n                        if (p in target) {\n                            this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);\n                        } else if (p !== \"parseTransform\") {\n                            _missingPlugin(p, endValue);\n                            continue;\n                        }\n                    } else {\n                        _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);\n                    }\n                    isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === \"function\" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));\n                    props.push(p);\n                }\n            }\n            hasPriority && _sortPropTweensByPriority(this);\n        },\n        render: function render(ratio, data) {\n            if (data.tween._time || !_reverting$1()) {\n                var pt = data._pt;\n                while(pt){\n                    pt.r(ratio, pt.d);\n                    pt = pt._next;\n                }\n            } else {\n                data.styles.revert();\n            }\n        },\n        get: _get,\n        aliases: _propertyAliases,\n        getSetter: function getSetter(target, property, plugin) {\n            var p = _propertyAliases[property];\n            p && p.indexOf(\",\") < 0 && (property = p);\n            return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, \"x\")) ? plugin && _recentSetterPlugin === plugin ? property === \"scale\" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === \"scale\" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf(\"-\") ? _setterCSSProp : _getSetter(target, property);\n        },\n        core: {\n            _removeProperty: _removeProperty,\n            _getMatrix: _getMatrix\n        }\n    };\n    gsap.utils.checkPrefix = _checkPropPrefix;\n    gsap.core.getStyleSaver = _getStyleSaver;\n    (function(positionAndScale, rotation, others, aliases) {\n        var all = _forEachName(positionAndScale + \",\" + rotation + \",\" + others, function(name) {\n            _transformProps[name] = 1;\n        });\n        _forEachName(rotation, function(name) {\n            _config.units[name] = \"deg\";\n            _rotationalProperties[name] = 1;\n        });\n        _propertyAliases[all[13]] = positionAndScale + \",\" + rotation;\n        _forEachName(aliases, function(name) {\n            var split = name.split(\":\");\n            _propertyAliases[split[1]] = all[split[0]];\n        });\n    })(\"x,y,z,scale,scaleX,scaleY,xPercent,yPercent\", \"rotation,rotationX,rotationY,skewX,skewY\", \"transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective\", \"0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY\");\n    _forEachName(\"x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective\", function(name) {\n        _config.units[name] = \"px\";\n    });\n    gsap.registerPlugin(CSSPlugin);\n    var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap, TweenMaxWithCSS = gsapWithCSS.core.Tween;\n    exports1.Back = Back;\n    exports1.Bounce = Bounce;\n    exports1.CSSPlugin = CSSPlugin;\n    exports1.Circ = Circ;\n    exports1.Cubic = Cubic;\n    exports1.Elastic = Elastic;\n    exports1.Expo = Expo;\n    exports1.Linear = Linear;\n    exports1.Power0 = Power0;\n    exports1.Power1 = Power1;\n    exports1.Power2 = Power2;\n    exports1.Power3 = Power3;\n    exports1.Power4 = Power4;\n    exports1.Quad = Quad;\n    exports1.Quart = Quart;\n    exports1.Quint = Quint;\n    exports1.Sine = Sine;\n    exports1.SteppedEase = SteppedEase;\n    exports1.Strong = Strong;\n    exports1.TimelineLite = Timeline;\n    exports1.TimelineMax = Timeline;\n    exports1.TweenLite = Tween;\n    exports1.TweenMax = TweenMaxWithCSS;\n    exports1.default = gsapWithCSS;\n    exports1.gsap = gsapWithCSS;\n    if (typeof window === \"undefined\" || window !== exports1) {\n        Object.defineProperty(exports1, \"__esModule\", {\n            value: true\n        });\n    } else {\n        delete window.default;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVEwakIsTUFBTSxHQUFHQTtJQUNqQjFqQixTQUFRaTFCLE1BQU0sR0FBR0E7SUFDakJqMUIsU0FBUWsxQixNQUFNLEdBQUdBO0lBQ2pCbDFCLFNBQVFtMUIsTUFBTSxHQUFHQTtJQUNqQm4xQixTQUFRbzFCLE1BQU0sR0FBR0E7SUFDakJwMUIsU0FBUXExQixNQUFNLEdBQUdBO0lBQ2pCcjFCLFNBQVFzMUIsSUFBSSxHQUFHQTtJQUNmdDFCLFNBQVF3MUIsS0FBSyxHQUFHQTtJQUNoQngxQixTQUFReTFCLEtBQUssR0FBR0E7SUFDaEJ6MUIsU0FBUTgxQixJQUFJLEdBQUdBO0lBQ2Y5MUIsU0FBUWdrQixXQUFXLEdBQUdBO0lBQ3RCaGtCLFNBQVEwMUIsTUFBTSxHQUFHQTtJQUNqQjExQixTQUFRdXdCLFlBQVksR0FBRy9lO0lBQ3ZCeFIsU0FBUXd3QixXQUFXLEdBQUdoZjtJQUN0QnhSLFNBQVFzd0IsU0FBUyxHQUFHM2Q7SUFDcEIzUyxTQUFRcXdCLFFBQVEsR0FBR3dVO0lBQ25CN2tDLFNBQVE4a0MsT0FBTyxHQUFHRjtJQUNsQjVrQyxTQUFRMEUsSUFBSSxHQUFHa2dDO0lBRWYsSUFBSSxPQUFPdmtDLFdBQVksZUFBZUEsV0FBV0wsVUFBUztRQUFDVSxPQUFPcWtDLGNBQWMsQ0FBQy9rQyxVQUFTLGNBQWM7WUFBRTJDLE9BQU87UUFBSztJQUFHLE9BQU87UUFBQyxPQUFPdEMsT0FBT3lrQyxPQUFPO0lBQUM7QUFFekoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnRlZ3JhdGlvbi1tb2R1bC1hcGFyYXQtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvZ3NhcC9kaXN0L2dzYXAuanM/ZmFhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwud2luZG93ID0gZ2xvYmFsLndpbmRvdyB8fCB7fSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gICAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICAgIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qIVxuICAgKiBHU0FQIDMuMTMuMFxuICAgKiBodHRwczovL2dzYXAuY29tXG4gICAqXG4gICAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjUsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAgICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlXG4gICAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuICAqL1xuICB2YXIgX2NvbmZpZyA9IHtcbiAgICBhdXRvU2xlZXA6IDEyMCxcbiAgICBmb3JjZTNEOiBcImF1dG9cIixcbiAgICBudWxsVGFyZ2V0V2FybjogMSxcbiAgICB1bml0czoge1xuICAgICAgbGluZUhlaWdodDogXCJcIlxuICAgIH1cbiAgfSxcbiAgICAgIF9kZWZhdWx0cyA9IHtcbiAgICBkdXJhdGlvbjogLjUsXG4gICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICBkZWxheTogMFxuICB9LFxuICAgICAgX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICAgIF9yZXZlcnRpbmcsXG4gICAgICBfY29udGV4dCxcbiAgICAgIF9iaWdOdW0gPSAxZTgsXG4gICAgICBfdGlueU51bSA9IDEgLyBfYmlnTnVtLFxuICAgICAgXzJQSSA9IE1hdGguUEkgKiAyLFxuICAgICAgX0hBTEZfUEkgPSBfMlBJIC8gNCxcbiAgICAgIF9nc0lEID0gMCxcbiAgICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgICAgX2NvcyA9IE1hdGguY29zLFxuICAgICAgX3NpbiA9IE1hdGguc2luLFxuICAgICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbiAgfSxcbiAgICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG4gIH0sXG4gICAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xuICB9LFxuICAgICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbiAgfSxcbiAgICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG4gIH0sXG4gICAgICBfaXNOb3RGYWxzZSA9IGZ1bmN0aW9uIF9pc05vdEZhbHNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbiAgfSxcbiAgICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICB9LFxuICAgICAgX2lzRnVuY09yU3RyaW5nID0gZnVuY3Rpb24gX2lzRnVuY09yU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSB8fCBfaXNTdHJpbmcodmFsdWUpO1xuICB9LFxuICAgICAgX2lzVHlwZWRBcnJheSA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiICYmIEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIF9zdHJpY3ROdW1FeHAgPSAvKD86LT9cXC4/XFxkfFxcLikrL2dpLFxuICAgICAgX251bUV4cCA9IC9bLSs9Ll0qXFxkK1suZVxcLStdKlxcZCpbZVxcLStdKlxcZCovZyxcbiAgICAgIF9udW1XaXRoVW5pdEV4cCA9IC9bLSs9Ll0qXFxkK1suZS1dKlxcZCpbYS16JV0qL2csXG4gICAgICBfY29tcGxleFN0cmluZ051bUV4cCA9IC9bLSs9Ll0qXFxkK1xcLj9cXGQqKD86ZS18ZVxcKyk/XFxkKi9naSxcbiAgICAgIF9yZWxFeHAgPSAvWystXT0tP1suXFxkXSsvLFxuICAgICAgX2RlbGltaXRlZFZhbHVlRXhwID0gL1teLCdcIlxcW1xcXVxcc10rL2dpLFxuICAgICAgX3VuaXRFeHAgPSAvXlsrXFwtPWVcXHNcXGRdKlxcZCtbLlxcZF0qKFthLXpdKnwlKVxccyokL2ksXG4gICAgICBfZ2xvYmFsVGltZWxpbmUsXG4gICAgICBfd2luLFxuICAgICAgX2NvcmVJbml0dGVkLFxuICAgICAgX2RvYyxcbiAgICAgIF9nbG9iYWxzID0ge30sXG4gICAgICBfaW5zdGFsbFNjb3BlID0ge30sXG4gICAgICBfY29yZVJlYWR5LFxuICAgICAgX2luc3RhbGwgPSBmdW5jdGlvbiBfaW5zdGFsbChzY29wZSkge1xuICAgIHJldHVybiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwO1xuICB9LFxuICAgICAgX21pc3NpbmdQbHVnaW4gPSBmdW5jdGlvbiBfbWlzc2luZ1BsdWdpbihwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgXCJzZXQgdG9cIiwgdmFsdWUsIFwiTWlzc2luZyBwbHVnaW4/IGdzYXAucmVnaXN0ZXJQbHVnaW4oKVwiKTtcbiAgfSxcbiAgICAgIF93YXJuID0gZnVuY3Rpb24gX3dhcm4obWVzc2FnZSwgc3VwcHJlc3MpIHtcbiAgICByZXR1cm4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgfSxcbiAgICAgIF9hZGRHbG9iYWwgPSBmdW5jdGlvbiBfYWRkR2xvYmFsKG5hbWUsIG9iaikge1xuICAgIHJldHVybiBuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikgfHwgX2dsb2JhbHM7XG4gIH0sXG4gICAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYygpIHtcbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgICAgIF9zdGFydEF0UmV2ZXJ0Q29uZmlnID0ge1xuICAgIHN1cHByZXNzRXZlbnRzOiB0cnVlLFxuICAgIGlzU3RhcnQ6IHRydWUsXG4gICAga2lsbDogZmFsc2VcbiAgfSxcbiAgICAgIF9yZXZlcnRDb25maWdOb0tpbGwgPSB7XG4gICAgc3VwcHJlc3NFdmVudHM6IHRydWUsXG4gICAga2lsbDogZmFsc2VcbiAgfSxcbiAgICAgIF9yZXZlcnRDb25maWcgPSB7XG4gICAgc3VwcHJlc3NFdmVudHM6IHRydWVcbiAgfSxcbiAgICAgIF9yZXNlcnZlZFByb3BzID0ge30sXG4gICAgICBfbGF6eVR3ZWVucyA9IFtdLFxuICAgICAgX2xhenlMb29rdXAgPSB7fSxcbiAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSxcbiAgICAgIF9wbHVnaW5zID0ge30sXG4gICAgICBfZWZmZWN0cyA9IHt9LFxuICAgICAgX25leHRHQ0ZyYW1lID0gMzAsXG4gICAgICBfaGFybmVzc1BsdWdpbnMgPSBbXSxcbiAgICAgIF9jYWxsYmFja05hbWVzID0gXCJcIixcbiAgICAgIF9oYXJuZXNzID0gZnVuY3Rpb24gX2hhcm5lc3ModGFyZ2V0cykge1xuICAgIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdLFxuICAgICAgICBoYXJuZXNzUGx1Z2luLFxuICAgICAgICBpO1xuICAgIF9pc09iamVjdCh0YXJnZXQpIHx8IF9pc0Z1bmN0aW9uKHRhcmdldCkgfHwgKHRhcmdldHMgPSBbdGFyZ2V0c10pO1xuXG4gICAgaWYgKCEoaGFybmVzc1BsdWdpbiA9ICh0YXJnZXQuX2dzYXAgfHwge30pLmhhcm5lc3MpKSB7XG4gICAgICBpID0gX2hhcm5lc3NQbHVnaW5zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSAmJiAhX2hhcm5lc3NQbHVnaW5zW2ldLnRhcmdldFRlc3QodGFyZ2V0KSkge31cblxuICAgICAgaGFybmVzc1BsdWdpbiA9IF9oYXJuZXNzUGx1Z2luc1tpXTtcbiAgICB9XG5cbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0YXJnZXRzW2ldICYmICh0YXJnZXRzW2ldLl9nc2FwIHx8ICh0YXJnZXRzW2ldLl9nc2FwID0gbmV3IEdTQ2FjaGUodGFyZ2V0c1tpXSwgaGFybmVzc1BsdWdpbikpKSB8fCB0YXJnZXRzLnNwbGljZShpLCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0cztcbiAgfSxcbiAgICAgIF9nZXRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRDYWNoZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0Ll9nc2FwIHx8IF9oYXJuZXNzKHRvQXJyYXkodGFyZ2V0KSlbMF0uX2dzYXA7XG4gIH0sXG4gICAgICBfZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0UHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgdikge1xuICAgIHJldHVybiAodiA9IHRhcmdldFtwcm9wZXJ0eV0pICYmIF9pc0Z1bmN0aW9uKHYpID8gdGFyZ2V0W3Byb3BlcnR5XSgpIDogX2lzVW5kZWZpbmVkKHYpICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShwcm9wZXJ0eSkgfHwgdjtcbiAgfSxcbiAgICAgIF9mb3JFYWNoTmFtZSA9IGZ1bmN0aW9uIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuYykge1xuICAgIHJldHVybiAobmFtZXMgPSBuYW1lcy5zcGxpdChcIixcIikpLmZvckVhY2goZnVuYykgfHwgbmFtZXM7XG4gIH0sXG4gICAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMCkgLyAxMDAwMDAgfHwgMDtcbiAgfSxcbiAgICAgIF9yb3VuZFByZWNpc2UgPSBmdW5jdGlvbiBfcm91bmRQcmVjaXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDAwMCkgLyAxMDAwMDAwMCB8fCAwO1xuICB9LFxuICAgICAgX3BhcnNlUmVsYXRpdmUgPSBmdW5jdGlvbiBfcGFyc2VSZWxhdGl2ZShzdGFydCwgdmFsdWUpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSB2YWx1ZS5jaGFyQXQoMCksXG4gICAgICAgIGVuZCA9IHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKTtcbiAgICBzdGFydCA9IHBhcnNlRmxvYXQoc3RhcnQpO1xuICAgIHJldHVybiBvcGVyYXRvciA9PT0gXCIrXCIgPyBzdGFydCArIGVuZCA6IG9wZXJhdG9yID09PSBcIi1cIiA/IHN0YXJ0IC0gZW5kIDogb3BlcmF0b3IgPT09IFwiKlwiID8gc3RhcnQgKiBlbmQgOiBzdGFydCAvIGVuZDtcbiAgfSxcbiAgICAgIF9hcnJheUNvbnRhaW5zQW55ID0gZnVuY3Rpb24gX2FycmF5Q29udGFpbnNBbnkodG9TZWFyY2gsIHRvRmluZCkge1xuICAgIHZhciBsID0gdG9GaW5kLmxlbmd0aCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICAgIHJldHVybiBpIDwgbDtcbiAgfSxcbiAgICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gICAgdmFyIGwgPSBfbGF6eVR3ZWVucy5sZW5ndGgsXG4gICAgICAgIGEgPSBfbGF6eVR3ZWVucy5zbGljZSgwKSxcbiAgICAgICAgaSxcbiAgICAgICAgdHdlZW47XG5cbiAgICBfbGF6eUxvb2t1cCA9IHt9O1xuICAgIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0d2VlbiA9IGFbaV07XG4gICAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgICB9XG4gIH0sXG4gICAgICBfaXNSZXZlcnRXb3J0aHkgPSBmdW5jdGlvbiBfaXNSZXZlcnRXb3J0aHkoYW5pbWF0aW9uKSB7XG4gICAgcmV0dXJuICEhKGFuaW1hdGlvbi5faW5pdHRlZCB8fCBhbmltYXRpb24uX3N0YXJ0QXQgfHwgYW5pbWF0aW9uLmFkZCk7XG4gIH0sXG4gICAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICBfbGF6eVR3ZWVucy5sZW5ndGggJiYgIV9yZXZlcnRpbmcgJiYgX2xhenlSZW5kZXIoKTtcbiAgICBhbmltYXRpb24ucmVuZGVyKHRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSB8fCAhIShfcmV2ZXJ0aW5nICYmIHRpbWUgPCAwICYmIF9pc1JldmVydFdvcnRoeShhbmltYXRpb24pKSk7XG4gICAgX2xhenlUd2VlbnMubGVuZ3RoICYmICFfcmV2ZXJ0aW5nICYmIF9sYXp5UmVuZGVyKCk7XG4gIH0sXG4gICAgICBfbnVtZXJpY0lmUG9zc2libGUgPSBmdW5jdGlvbiBfbnVtZXJpY0lmUG9zc2libGUodmFsdWUpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xuICB9LFxuICAgICAgX3Bhc3NUaHJvdWdoID0gZnVuY3Rpb24gX3Bhc3NUaHJvdWdoKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgICAgIF9zZXREZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXREZWZhdWx0cyhvYmosIGRlZmF1bHRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgICAgcCBpbiBvYmogfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqO1xuICB9LFxuICAgICAgX3NldEtleWZyYW1lRGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0S2V5ZnJhbWVEZWZhdWx0cyhleGNsdWRlRHVyYXRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgcCBpbiBvYmogfHwgcCA9PT0gXCJkdXJhdGlvblwiICYmIGV4Y2x1ZGVEdXJhdGlvbiB8fCBwID09PSBcImVhc2VcIiB8fCAob2JqW3BdID0gZGVmYXVsdHNbcF0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gICAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICAgIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgICAgYmFzZVtwXSA9IHRvTWVyZ2VbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U7XG4gIH0sXG4gICAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gICAgZm9yICh2YXIgcCBpbiB0b01lcmdlKSB7XG4gICAgICBwICE9PSBcIl9fcHJvdG9fX1wiICYmIHAgIT09IFwiY29uc3RydWN0b3JcIiAmJiBwICE9PSBcInByb3RvdHlwZVwiICYmIChiYXNlW3BdID0gX2lzT2JqZWN0KHRvTWVyZ2VbcF0pID8gX21lcmdlRGVlcChiYXNlW3BdIHx8IChiYXNlW3BdID0ge30pLCB0b01lcmdlW3BdKSA6IHRvTWVyZ2VbcF0pO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlO1xuICB9LFxuICAgICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICAgIHZhciBjb3B5ID0ge30sXG4gICAgICAgIHA7XG5cbiAgICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgICBwIGluIGV4Y2x1ZGluZyB8fCAoY29weVtwXSA9IG9ialtwXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHk7XG4gIH0sXG4gICAgICBfaW5oZXJpdERlZmF1bHRzID0gZnVuY3Rpb24gX2luaGVyaXREZWZhdWx0cyh2YXJzKSB7XG4gICAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgICAgZnVuYyA9IHZhcnMua2V5ZnJhbWVzID8gX3NldEtleWZyYW1lRGVmYXVsdHMoX2lzQXJyYXkodmFycy5rZXlmcmFtZXMpKSA6IF9zZXREZWZhdWx0cztcblxuICAgIGlmIChfaXNOb3RGYWxzZSh2YXJzLmluaGVyaXQpKSB7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGZ1bmModmFycywgcGFyZW50LnZhcnMuZGVmYXVsdHMpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50IHx8IHBhcmVudC5fZHA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhcnM7XG4gIH0sXG4gICAgICBfYXJyYXlzTWF0Y2ggPSBmdW5jdGlvbiBfYXJyYXlzTWF0Y2goYTEsIGEyKSB7XG4gICAgdmFyIGkgPSBhMS5sZW5ndGgsXG4gICAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gICAgd2hpbGUgKG1hdGNoICYmIGktLSAmJiBhMVtpXSA9PT0gYTJbaV0pIHt9XG5cbiAgICByZXR1cm4gaSA8IDA7XG4gIH0sXG4gICAgICBfYWRkTGlua2VkTGlzdEl0ZW0gPSBmdW5jdGlvbiBfYWRkTGlua2VkTGlzdEl0ZW0ocGFyZW50LCBjaGlsZCwgZmlyc3RQcm9wLCBsYXN0UHJvcCwgc29ydEJ5KSB7XG4gICAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICAgIH1cblxuICAgIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IHBhcmVudFtsYXN0UHJvcF0sXG4gICAgICAgIHQ7XG5cbiAgICBpZiAoc29ydEJ5KSB7XG4gICAgICB0ID0gY2hpbGRbc29ydEJ5XTtcblxuICAgICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgICBwcmV2ID0gcHJldi5fcHJldjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocHJldikge1xuICAgICAgY2hpbGQuX25leHQgPSBwcmV2Ll9uZXh0O1xuICAgICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZC5fbmV4dCA9IHBhcmVudFtmaXJzdFByb3BdO1xuICAgICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgICB9XG5cbiAgICBpZiAoY2hpbGQuX25leHQpIHtcbiAgICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudFtsYXN0UHJvcF0gPSBjaGlsZDtcbiAgICB9XG5cbiAgICBjaGlsZC5fcHJldiA9IHByZXY7XG4gICAgY2hpbGQucGFyZW50ID0gY2hpbGQuX2RwID0gcGFyZW50O1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSxcbiAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSA9IGZ1bmN0aW9uIF9yZW1vdmVMaW5rZWRMaXN0SXRlbShwYXJlbnQsIGNoaWxkLCBmaXJzdFByb3AsIGxhc3RQcm9wKSB7XG4gICAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICAgIH1cblxuICAgIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICBpZiAocHJldikge1xuICAgICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRbZmlyc3RQcm9wXSA9PT0gY2hpbGQpIHtcbiAgICAgIHBhcmVudFtmaXJzdFByb3BdID0gbmV4dDtcbiAgICB9XG5cbiAgICBpZiAobmV4dCkge1xuICAgICAgbmV4dC5fcHJldiA9IHByZXY7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgICAgcGFyZW50W2xhc3RQcm9wXSA9IHByZXY7XG4gICAgfVxuXG4gICAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7XG4gIH0sXG4gICAgICBfcmVtb3ZlRnJvbVBhcmVudCA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkLCBvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlKSB7XG4gICAgY2hpbGQucGFyZW50ICYmICghb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSB8fCBjaGlsZC5wYXJlbnQuYXV0b1JlbW92ZUNoaWxkcmVuKSAmJiBjaGlsZC5wYXJlbnQucmVtb3ZlICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICAgIGNoaWxkLl9hY3QgPSAwO1xuICB9LFxuICAgICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gICAgaWYgKGFuaW1hdGlvbiAmJiAoIWNoaWxkIHx8IGNoaWxkLl9lbmQgPiBhbmltYXRpb24uX2R1ciB8fCBjaGlsZC5fc3RhcnQgPCAwKSkge1xuICAgICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICAgIHdoaWxlIChhKSB7XG4gICAgICAgIGEuX2RpcnR5ID0gMTtcbiAgICAgICAgYSA9IGEucGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH0sXG4gICAgICBfcmVjYWNoZUFuY2VzdG9ycyA9IGZ1bmN0aW9uIF9yZWNhY2hlQW5jZXN0b3JzKGFuaW1hdGlvbikge1xuICAgIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQucGFyZW50KSB7XG4gICAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICAgIHBhcmVudC50b3RhbER1cmF0aW9uKCk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH0sXG4gICAgICBfcmV3aW5kU3RhcnRBdCA9IGZ1bmN0aW9uIF9yZXdpbmRTdGFydEF0KHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHJldHVybiB0d2Vlbi5fc3RhcnRBdCAmJiAoX3JldmVydGluZyA/IHR3ZWVuLl9zdGFydEF0LnJldmVydChfcmV2ZXJ0Q29uZmlnTm9LaWxsKSA6IHR3ZWVuLnZhcnMuaW1tZWRpYXRlUmVuZGVyICYmICF0d2Vlbi52YXJzLmF1dG9SZXZlcnQgfHwgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKHRvdGFsVGltZSwgdHJ1ZSwgZm9yY2UpKTtcbiAgfSxcbiAgICAgIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyA9IGZ1bmN0aW9uIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24pIHtcbiAgICByZXR1cm4gIWFuaW1hdGlvbiB8fCBhbmltYXRpb24uX3RzICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhhbmltYXRpb24ucGFyZW50KTtcbiAgfSxcbiAgICAgIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbiA9IGZ1bmN0aW9uIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbihhbmltYXRpb24pIHtcbiAgICByZXR1cm4gYW5pbWF0aW9uLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUoYW5pbWF0aW9uLl90VGltZSwgYW5pbWF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKyBhbmltYXRpb24uX3JEZWxheSkgKiBhbmltYXRpb24gOiAwO1xuICB9LFxuICAgICAgX2FuaW1hdGlvbkN5Y2xlID0gZnVuY3Rpb24gX2FuaW1hdGlvbkN5Y2xlKHRUaW1lLCBjeWNsZUR1cmF0aW9uKSB7XG4gICAgdmFyIHdob2xlID0gTWF0aC5mbG9vcih0VGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgLyBjeWNsZUR1cmF0aW9uKSk7XG4gICAgcmV0dXJuIHRUaW1lICYmIHdob2xlID09PSB0VGltZSA/IHdob2xlIC0gMSA6IHdob2xlO1xuICB9LFxuICAgICAgX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUgPSBmdW5jdGlvbiBfcGFyZW50VG9DaGlsZFRvdGFsVGltZShwYXJlbnRUaW1lLCBjaGlsZCkge1xuICAgIHJldHVybiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpO1xuICB9LFxuICAgICAgX3NldEVuZCA9IGZ1bmN0aW9uIF9zZXRFbmQoYW5pbWF0aW9uKSB7XG4gICAgcmV0dXJuIGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kUHJlY2lzZShhbmltYXRpb24uX3N0YXJ0ICsgKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pIHx8IDApKTtcbiAgfSxcbiAgICAgIF9hbGlnblBsYXloZWFkID0gZnVuY3Rpb24gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCB0b3RhbFRpbWUpIHtcbiAgICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLl9kcDtcblxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIGFuaW1hdGlvbi5fdHMpIHtcbiAgICAgIGFuaW1hdGlvbi5fc3RhcnQgPSBfcm91bmRQcmVjaXNlKHBhcmVudC5fdGltZSAtIChhbmltYXRpb24uX3RzID4gMCA/IHRvdGFsVGltZSAvIGFuaW1hdGlvbi5fdHMgOiAoKGFuaW1hdGlvbi5fZGlydHkgPyBhbmltYXRpb24udG90YWxEdXJhdGlvbigpIDogYW5pbWF0aW9uLl90RHVyKSAtIHRvdGFsVGltZSkgLyAtYW5pbWF0aW9uLl90cykpO1xuXG4gICAgICBfc2V0RW5kKGFuaW1hdGlvbik7XG5cbiAgICAgIHBhcmVudC5fZGlydHkgfHwgX3VuY2FjaGUocGFyZW50LCBhbmltYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRpb247XG4gIH0sXG4gICAgICBfcG9zdEFkZENoZWNrcyA9IGZ1bmN0aW9uIF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCkge1xuICAgIHZhciB0O1xuXG4gICAgaWYgKGNoaWxkLl90aW1lIHx8ICFjaGlsZC5fZHVyICYmIGNoaWxkLl9pbml0dGVkIHx8IGNoaWxkLl9zdGFydCA8IHRpbWVsaW5lLl90aW1lICYmIChjaGlsZC5fZHVyIHx8ICFjaGlsZC5hZGQpKSB7XG4gICAgICB0ID0gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGltZWxpbmUucmF3VGltZSgpLCBjaGlsZCk7XG5cbiAgICAgIGlmICghY2hpbGQuX2R1ciB8fCBfY2xhbXAoMCwgY2hpbGQudG90YWxEdXJhdGlvbigpLCB0KSAtIGNoaWxkLl90VGltZSA+IF90aW55TnVtKSB7XG4gICAgICAgIGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAgIGlmICh0aW1lbGluZS5fZHVyIDwgdGltZWxpbmUuZHVyYXRpb24oKSkge1xuICAgICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgICAgd2hpbGUgKHQuX2RwKSB7XG4gICAgICAgICAgdC5yYXdUaW1lKCkgPj0gMCAmJiB0LnRvdGFsVGltZSh0Ll90VGltZSk7XG4gICAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTtcbiAgICB9XG4gIH0sXG4gICAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgICBjaGlsZC5wYXJlbnQgJiYgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgIGNoaWxkLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoKF9pc051bWJlcihwb3NpdGlvbikgPyBwb3NpdGlvbiA6IHBvc2l0aW9uIHx8IHRpbWVsaW5lICE9PSBfZ2xvYmFsVGltZWxpbmUgPyBfcGFyc2VQb3NpdGlvbih0aW1lbGluZSwgcG9zaXRpb24sIGNoaWxkKSA6IHRpbWVsaW5lLl90aW1lKSArIGNoaWxkLl9kZWxheSk7XG4gICAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgICBfYWRkTGlua2VkTGlzdEl0ZW0odGltZWxpbmUsIGNoaWxkLCBcIl9maXJzdFwiLCBcIl9sYXN0XCIsIHRpbWVsaW5lLl9zb3J0ID8gXCJfc3RhcnRcIiA6IDApO1xuXG4gICAgX2lzRnJvbU9yRnJvbVN0YXJ0KGNoaWxkKSB8fCAodGltZWxpbmUuX3JlY2VudCA9IGNoaWxkKTtcbiAgICBza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG4gICAgdGltZWxpbmUuX3RzIDwgMCAmJiBfYWxpZ25QbGF5aGVhZCh0aW1lbGluZSwgdGltZWxpbmUuX3RUaW1lKTtcbiAgICByZXR1cm4gdGltZWxpbmU7XG4gIH0sXG4gICAgICBfc2Nyb2xsVHJpZ2dlciA9IGZ1bmN0aW9uIF9zY3JvbGxUcmlnZ2VyKGFuaW1hdGlvbiwgdHJpZ2dlcikge1xuICAgIHJldHVybiAoX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlciB8fCBfbWlzc2luZ1BsdWdpbihcInNjcm9sbFRyaWdnZXJcIiwgdHJpZ2dlcikpICYmIF9nbG9iYWxzLlNjcm9sbFRyaWdnZXIuY3JlYXRlKHRyaWdnZXIsIGFuaW1hdGlvbik7XG4gIH0sXG4gICAgICBfYXR0ZW1wdEluaXRUd2VlbiA9IGZ1bmN0aW9uIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSB7XG4gICAgX2luaXRUd2Vlbih0d2VlbiwgdGltZSwgdFRpbWUpO1xuXG4gICAgaWYgKCF0d2Vlbi5faW5pdHRlZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZSAmJiB0d2Vlbi5fcHQgJiYgIV9yZXZlcnRpbmcgJiYgKHR3ZWVuLl9kdXIgJiYgdHdlZW4udmFycy5sYXp5ICE9PSBmYWxzZSB8fCAhdHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkpICYmIF9sYXN0UmVuZGVyZWRGcmFtZSAhPT0gX3RpY2tlci5mcmFtZSkge1xuICAgICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cbiAgICAgIHR3ZWVuLl9sYXp5ID0gW3RUaW1lLCBzdXBwcmVzc0V2ZW50c107XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH0sXG4gICAgICBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChfcmVmKSB7XG4gICAgdmFyIHBhcmVudCA9IF9yZWYucGFyZW50O1xuICAgIHJldHVybiBwYXJlbnQgJiYgcGFyZW50Ll90cyAmJiBwYXJlbnQuX2luaXR0ZWQgJiYgIXBhcmVudC5fbG9jayAmJiAocGFyZW50LnJhd1RpbWUoKSA8IDAgfHwgX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChwYXJlbnQpKTtcbiAgfSxcbiAgICAgIF9pc0Zyb21PckZyb21TdGFydCA9IGZ1bmN0aW9uIF9pc0Zyb21PckZyb21TdGFydChfcmVmMikge1xuICAgIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgICByZXR1cm4gZGF0YSA9PT0gXCJpc0Zyb21TdGFydFwiIHx8IGRhdGEgPT09IFwiaXNTdGFydFwiO1xuICB9LFxuICAgICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICAgIHZhciBwcmV2UmF0aW8gPSB0d2Vlbi5yYXRpbyxcbiAgICAgICAgcmF0aW8gPSB0b3RhbFRpbWUgPCAwIHx8ICF0b3RhbFRpbWUgJiYgKCF0d2Vlbi5fc3RhcnQgJiYgX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydCh0d2VlbikgJiYgISghdHdlZW4uX2luaXR0ZWQgJiYgX2lzRnJvbU9yRnJvbVN0YXJ0KHR3ZWVuKSkgfHwgKHR3ZWVuLl90cyA8IDAgfHwgdHdlZW4uX2RwLl90cyA8IDApICYmICFfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSA/IDAgOiAxLFxuICAgICAgICByZXBlYXREZWxheSA9IHR3ZWVuLl9yRGVsYXksXG4gICAgICAgIHRUaW1lID0gMCxcbiAgICAgICAgcHQsXG4gICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgcHJldkl0ZXJhdGlvbjtcblxuICAgIGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7XG4gICAgICB0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcbiAgICAgIGl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0VGltZSwgcmVwZWF0RGVsYXkpO1xuICAgICAgdHdlZW4uX3lveW8gJiYgaXRlcmF0aW9uICYgMSAmJiAocmF0aW8gPSAxIC0gcmF0aW8pO1xuXG4gICAgICBpZiAoaXRlcmF0aW9uICE9PSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSkpIHtcbiAgICAgICAgcHJldlJhdGlvID0gMSAtIHJhdGlvO1xuICAgICAgICB0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IF9yZXZlcnRpbmcgfHwgZm9yY2UgfHwgdHdlZW4uX3pUaW1lID09PSBfdGlueU51bSB8fCAhdG90YWxUaW1lICYmIHR3ZWVuLl96VGltZSkge1xuICAgICAgaWYgKCF0d2Vlbi5faW5pdHRlZCAmJiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHByZXZJdGVyYXRpb24gPSB0d2Vlbi5felRpbWU7XG4gICAgICB0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWUgfHwgKHN1cHByZXNzRXZlbnRzID8gX3RpbnlOdW0gOiAwKTtcbiAgICAgIHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7XG4gICAgICB0d2Vlbi5yYXRpbyA9IHJhdGlvO1xuICAgICAgdHdlZW4uX2Zyb20gJiYgKHJhdGlvID0gMSAtIHJhdGlvKTtcbiAgICAgIHR3ZWVuLl90aW1lID0gMDtcbiAgICAgIHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuICAgICAgcHQgPSB0d2Vlbi5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdG90YWxUaW1lIDwgMCAmJiBfcmV3aW5kU3RhcnRBdCh0d2VlbiwgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgdHJ1ZSk7XG4gICAgICB0d2Vlbi5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICAgIHRUaW1lICYmIHR3ZWVuLl9yZXBlYXQgJiYgIXN1cHByZXNzRXZlbnRzICYmIHR3ZWVuLnBhcmVudCAmJiBfY2FsbGJhY2sodHdlZW4sIFwib25SZXBlYXRcIik7XG5cbiAgICAgIGlmICgodG90YWxUaW1lID49IHR3ZWVuLl90RHVyIHx8IHRvdGFsVGltZSA8IDApICYmIHR3ZWVuLnJhdGlvID09PSByYXRpbykge1xuICAgICAgICByYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cbiAgICAgICAgaWYgKCFzdXBwcmVzc0V2ZW50cyAmJiAhX3JldmVydGluZykge1xuICAgICAgICAgIF9jYWxsYmFjayh0d2VlbiwgcmF0aW8gPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICB0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdHdlZW4uX3pUaW1lKSB7XG4gICAgICB0d2Vlbi5felRpbWUgPSB0b3RhbFRpbWU7XG4gICAgfVxuICB9LFxuICAgICAgX2ZpbmROZXh0UGF1c2VUd2VlbiA9IGZ1bmN0aW9uIF9maW5kTmV4dFBhdXNlVHdlZW4oYW5pbWF0aW9uLCBwcmV2VGltZSwgdGltZSkge1xuICAgIHZhciBjaGlsZDtcblxuICAgIGlmICh0aW1lID4gcHJldlRpbWUpIHtcbiAgICAgIGNoaWxkID0gYW5pbWF0aW9uLl9maXJzdDtcblxuICAgICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA8PSB0aW1lKSB7XG4gICAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xuICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gYW5pbWF0aW9uLl9sYXN0O1xuXG4gICAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0ID49IHRpbWUpIHtcbiAgICAgICAgaWYgKGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiICYmIGNoaWxkLl9zdGFydCA8IHByZXZUaW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5fcHJldjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICAgICBfc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpIHtcbiAgICB2YXIgcmVwZWF0ID0gYW5pbWF0aW9uLl9yZXBlYXQsXG4gICAgICAgIGR1ciA9IF9yb3VuZFByZWNpc2UoZHVyYXRpb24pIHx8IDAsXG4gICAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICAgIHRvdGFsUHJvZ3Jlc3MgJiYgIWxlYXZlUGxheWhlYWQgJiYgKGFuaW1hdGlvbi5fdGltZSAqPSBkdXIgLyBhbmltYXRpb24uX2R1cik7XG4gICAgYW5pbWF0aW9uLl9kdXIgPSBkdXI7XG4gICAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kUHJlY2lzZShkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG4gICAgdG90YWxQcm9ncmVzcyA+IDAgJiYgIWxlYXZlUGxheWhlYWQgJiYgX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCBhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcyk7XG4gICAgYW5pbWF0aW9uLnBhcmVudCAmJiBfc2V0RW5kKGFuaW1hdGlvbik7XG4gICAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9LFxuICAgICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgcmV0dXJuIGFuaW1hdGlvbiBpbnN0YW5jZW9mIFRpbWVsaW5lID8gX3VuY2FjaGUoYW5pbWF0aW9uKSA6IF9zZXREdXJhdGlvbihhbmltYXRpb24sIGFuaW1hdGlvbi5fZHVyKTtcbiAgfSxcbiAgICAgIF96ZXJvUG9zaXRpb24gPSB7XG4gICAgX3N0YXJ0OiAwLFxuICAgIGVuZFRpbWU6IF9lbXB0eUZ1bmMsXG4gICAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xuICB9LFxuICAgICAgX3BhcnNlUG9zaXRpb24gPSBmdW5jdGlvbiBfcGFyc2VQb3NpdGlvbihhbmltYXRpb24sIHBvc2l0aW9uLCBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICAgIHJlY2VudCA9IGFuaW1hdGlvbi5fcmVjZW50IHx8IF96ZXJvUG9zaXRpb24sXG4gICAgICAgIGNsaXBwZWREdXJhdGlvbiA9IGFuaW1hdGlvbi5kdXJhdGlvbigpID49IF9iaWdOdW0gPyByZWNlbnQuZW5kVGltZShmYWxzZSkgOiBhbmltYXRpb24uX2R1cixcbiAgICAgICAgaSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBpc1BlcmNlbnQ7XG5cbiAgICBpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IHBvc2l0aW9uIGluIGxhYmVscykpIHtcbiAgICAgIG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcbiAgICAgIGlzUGVyY2VudCA9IHBvc2l0aW9uLnN1YnN0cigtMSkgPT09IFwiJVwiO1xuICAgICAgaSA9IHBvc2l0aW9uLmluZGV4T2YoXCI9XCIpO1xuXG4gICAgICBpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG4gICAgICAgIGkgPj0gMCAmJiAocG9zaXRpb24gPSBwb3NpdGlvbi5yZXBsYWNlKC89LywgXCJcIikpO1xuICAgICAgICByZXR1cm4gKG9mZnNldCA9PT0gXCI8XCIgPyByZWNlbnQuX3N0YXJ0IDogcmVjZW50LmVuZFRpbWUocmVjZW50Ll9yZXBlYXQgPj0gMCkpICsgKHBhcnNlRmxvYXQocG9zaXRpb24uc3Vic3RyKDEpKSB8fCAwKSAqIChpc1BlcmNlbnQgPyAoaSA8IDAgPyByZWNlbnQgOiBwZXJjZW50QW5pbWF0aW9uKS50b3RhbER1cmF0aW9uKCkgLyAxMDAgOiAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgIHBvc2l0aW9uIGluIGxhYmVscyB8fCAobGFiZWxzW3Bvc2l0aW9uXSA9IGNsaXBwZWREdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgICAgfVxuXG4gICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KHBvc2l0aW9uLmNoYXJBdChpIC0gMSkgKyBwb3NpdGlvbi5zdWJzdHIoaSArIDEpKTtcblxuICAgICAgaWYgKGlzUGVyY2VudCAmJiBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCAvIDEwMCAqIChfaXNBcnJheShwZXJjZW50QW5pbWF0aW9uKSA/IHBlcmNlbnRBbmltYXRpb25bMF0gOiBwZXJjZW50QW5pbWF0aW9uKS50b3RhbER1cmF0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uID09IG51bGwgPyBjbGlwcGVkRHVyYXRpb24gOiArcG9zaXRpb247XG4gIH0sXG4gICAgICBfY3JlYXRlVHdlZW5UeXBlID0gZnVuY3Rpb24gX2NyZWF0ZVR3ZWVuVHlwZSh0eXBlLCBwYXJhbXMsIHRpbWVsaW5lKSB7XG4gICAgdmFyIGlzTGVnYWN5ID0gX2lzTnVtYmVyKHBhcmFtc1sxXSksXG4gICAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgICAgdmFycyA9IHBhcmFtc1t2YXJzSW5kZXhdLFxuICAgICAgICBpclZhcnMsXG4gICAgICAgIHBhcmVudDtcblxuICAgIGlzTGVnYWN5ICYmICh2YXJzLmR1cmF0aW9uID0gcGFyYW1zWzFdKTtcbiAgICB2YXJzLnBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlyVmFycyA9IHZhcnM7XG4gICAgICBwYXJlbnQgPSB0aW1lbGluZTtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkge1xuICAgICAgICBpclZhcnMgPSBwYXJlbnQudmFycy5kZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgcGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShpclZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICAgIHR5cGUgPCAyID8gdmFycy5ydW5CYWNrd2FyZHMgPSAxIDogdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgVHdlZW4ocGFyYW1zWzBdLCB2YXJzLCBwYXJhbXNbdmFyc0luZGV4ICsgMV0pO1xuICB9LFxuICAgICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gICAgcmV0dXJuIHZhbHVlIHx8IHZhbHVlID09PSAwID8gZnVuYyh2YWx1ZSkgOiBmdW5jO1xuICB9LFxuICAgICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG4gIH0sXG4gICAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSwgdikge1xuICAgIHJldHVybiAhX2lzU3RyaW5nKHZhbHVlKSB8fCAhKHYgPSBfdW5pdEV4cC5leGVjKHZhbHVlKSkgPyBcIlwiIDogdlsxXTtcbiAgfSxcbiAgICAgIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiBfY2xhbXAobWluLCBtYXgsIHYpO1xuICAgIH0pO1xuICB9LFxuICAgICAgX3NsaWNlID0gW10uc2xpY2UsXG4gICAgICBfaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBfaXNBcnJheUxpa2UodmFsdWUsIG5vbkVtcHR5KSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIF9pc09iamVjdCh2YWx1ZSkgJiYgXCJsZW5ndGhcIiBpbiB2YWx1ZSAmJiAoIW5vbkVtcHR5ICYmICF2YWx1ZS5sZW5ndGggfHwgdmFsdWUubGVuZ3RoIC0gMSBpbiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWVbMF0pKSAmJiAhdmFsdWUubm9kZVR5cGUgJiYgdmFsdWUgIT09IF93aW47XG4gIH0sXG4gICAgICBfZmxhdHRlbiA9IGZ1bmN0aW9uIF9mbGF0dGVuKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yKSB7XG4gICAgaWYgKGFjY3VtdWxhdG9yID09PSB2b2lkIDApIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICB2YXIgX2FjY3VtdWxhdG9yO1xuXG4gICAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzIHx8IF9pc0FycmF5TGlrZSh2YWx1ZSwgMSkgPyAoX2FjY3VtdWxhdG9yID0gYWNjdW11bGF0b3IpLnB1c2guYXBwbHkoX2FjY3VtdWxhdG9yLCB0b0FycmF5KHZhbHVlKSkgOiBhY2N1bXVsYXRvci5wdXNoKHZhbHVlKTtcbiAgICB9KSB8fCBhY2N1bXVsYXRvcjtcbiAgfSxcbiAgICAgIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KHZhbHVlLCBzY29wZSwgbGVhdmVTdHJpbmdzKSB7XG4gICAgcmV0dXJuIF9jb250ZXh0ICYmICFzY29wZSAmJiBfY29udGV4dC5zZWxlY3RvciA/IF9jb250ZXh0LnNlbGVjdG9yKHZhbHVlKSA6IF9pc1N0cmluZyh2YWx1ZSkgJiYgIWxlYXZlU3RyaW5ncyAmJiAoX2NvcmVJbml0dGVkIHx8ICFfd2FrZSgpKSA/IF9zbGljZS5jYWxsKChzY29wZSB8fCBfZG9jKS5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSwgMCkgOiBfaXNBcnJheSh2YWx1ZSkgPyBfZmxhdHRlbih2YWx1ZSwgbGVhdmVTdHJpbmdzKSA6IF9pc0FycmF5TGlrZSh2YWx1ZSkgPyBfc2xpY2UuY2FsbCh2YWx1ZSwgMCkgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXTtcbiAgfSxcbiAgICAgIHNlbGVjdG9yID0gZnVuY3Rpb24gc2VsZWN0b3IodmFsdWUpIHtcbiAgICB2YWx1ZSA9IHRvQXJyYXkodmFsdWUpWzBdIHx8IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgIHZhciBlbCA9IHZhbHVlLmN1cnJlbnQgfHwgdmFsdWUubmF0aXZlRWxlbWVudCB8fCB2YWx1ZTtcbiAgICAgIHJldHVybiB0b0FycmF5KHYsIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlbCA6IGVsID09PSB2YWx1ZSA/IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiB2YWx1ZSk7XG4gICAgfTtcbiAgfSxcbiAgICAgIHNodWZmbGUgPSBmdW5jdGlvbiBzaHVmZmxlKGEpIHtcbiAgICByZXR1cm4gYS5zb3J0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAuNSAtIE1hdGgucmFuZG9tKCk7XG4gICAgfSk7XG4gIH0sXG4gICAgICBkaXN0cmlidXRlID0gZnVuY3Rpb24gZGlzdHJpYnV0ZSh2KSB7XG4gICAgaWYgKF9pc0Z1bmN0aW9uKHYpKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICB2YXIgdmFycyA9IF9pc09iamVjdCh2KSA/IHYgOiB7XG4gICAgICBlYWNoOiB2XG4gICAgfSxcbiAgICAgICAgZWFzZSA9IF9wYXJzZUVhc2UodmFycy5lYXNlKSxcbiAgICAgICAgZnJvbSA9IHZhcnMuZnJvbSB8fCAwLFxuICAgICAgICBiYXNlID0gcGFyc2VGbG9hdCh2YXJzLmJhc2UpIHx8IDAsXG4gICAgICAgIGNhY2hlID0ge30sXG4gICAgICAgIGlzRGVjaW1hbCA9IGZyb20gPiAwICYmIGZyb20gPCAxLFxuICAgICAgICByYXRpb3MgPSBpc05hTihmcm9tKSB8fCBpc0RlY2ltYWwsXG4gICAgICAgIGF4aXMgPSB2YXJzLmF4aXMsXG4gICAgICAgIHJhdGlvWCA9IGZyb20sXG4gICAgICAgIHJhdGlvWSA9IGZyb207XG5cbiAgICBpZiAoX2lzU3RyaW5nKGZyb20pKSB7XG4gICAgICByYXRpb1ggPSByYXRpb1kgPSB7XG4gICAgICAgIGNlbnRlcjogLjUsXG4gICAgICAgIGVkZ2VzOiAuNSxcbiAgICAgICAgZW5kOiAxXG4gICAgICB9W2Zyb21dIHx8IDA7XG4gICAgfSBlbHNlIGlmICghaXNEZWNpbWFsICYmIHJhdGlvcykge1xuICAgICAgcmF0aW9YID0gZnJvbVswXTtcbiAgICAgIHJhdGlvWSA9IGZyb21bMV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpLCB0YXJnZXQsIGEpIHtcbiAgICAgIHZhciBsID0gKGEgfHwgdmFycykubGVuZ3RoLFxuICAgICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdLFxuICAgICAgICAgIG9yaWdpblgsXG4gICAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgICB4LFxuICAgICAgICAgIHksXG4gICAgICAgICAgZCxcbiAgICAgICAgICBqLFxuICAgICAgICAgIG1heCxcbiAgICAgICAgICBtaW4sXG4gICAgICAgICAgd3JhcEF0O1xuXG4gICAgICBpZiAoIWRpc3RhbmNlcykge1xuICAgICAgICB3cmFwQXQgPSB2YXJzLmdyaWQgPT09IFwiYXV0b1wiID8gMCA6ICh2YXJzLmdyaWQgfHwgWzEsIF9iaWdOdW1dKVsxXTtcblxuICAgICAgICBpZiAoIXdyYXBBdCkge1xuICAgICAgICAgIG1heCA9IC1fYmlnTnVtO1xuXG4gICAgICAgICAgd2hpbGUgKG1heCA8IChtYXggPSBhW3dyYXBBdCsrXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSAmJiB3cmFwQXQgPCBsKSB7fVxuXG4gICAgICAgICAgd3JhcEF0IDwgbCAmJiB3cmFwQXQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdID0gW107XG4gICAgICAgIG9yaWdpblggPSByYXRpb3MgPyBNYXRoLm1pbih3cmFwQXQsIGwpICogcmF0aW9YIC0gLjUgOiBmcm9tICUgd3JhcEF0O1xuICAgICAgICBvcmlnaW5ZID0gd3JhcEF0ID09PSBfYmlnTnVtID8gMCA6IHJhdGlvcyA/IGwgKiByYXRpb1kgLyB3cmFwQXQgLSAuNSA6IGZyb20gLyB3cmFwQXQgfCAwO1xuICAgICAgICBtYXggPSAwO1xuICAgICAgICBtaW4gPSBfYmlnTnVtO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICB4ID0gaiAlIHdyYXBBdCAtIG9yaWdpblg7XG4gICAgICAgICAgeSA9IG9yaWdpblkgLSAoaiAvIHdyYXBBdCB8IDApO1xuICAgICAgICAgIGRpc3RhbmNlc1tqXSA9IGQgPSAhYXhpcyA/IF9zcXJ0KHggKiB4ICsgeSAqIHkpIDogTWF0aC5hYnMoYXhpcyA9PT0gXCJ5XCIgPyB5IDogeCk7XG4gICAgICAgICAgZCA+IG1heCAmJiAobWF4ID0gZCk7XG4gICAgICAgICAgZCA8IG1pbiAmJiAobWluID0gZCk7XG4gICAgICAgIH1cblxuICAgICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgICAgZGlzdGFuY2VzLm1heCA9IG1heCAtIG1pbjtcbiAgICAgICAgZGlzdGFuY2VzLm1pbiA9IG1pbjtcbiAgICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICAgIGRpc3RhbmNlcy5iID0gbCA8IDAgPyBiYXNlIC0gbCA6IGJhc2U7XG4gICAgICAgIGRpc3RhbmNlcy51ID0gZ2V0VW5pdCh2YXJzLmFtb3VudCB8fCB2YXJzLmVhY2gpIHx8IDA7XG4gICAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgICAgfVxuXG4gICAgICBsID0gKGRpc3RhbmNlc1tpXSAtIGRpc3RhbmNlcy5taW4pIC8gZGlzdGFuY2VzLm1heCB8fCAwO1xuICAgICAgcmV0dXJuIF9yb3VuZFByZWNpc2UoZGlzdGFuY2VzLmIgKyAoZWFzZSA/IGVhc2UobCkgOiBsKSAqIGRpc3RhbmNlcy52KSArIGRpc3RhbmNlcy51O1xuICAgIH07XG4gIH0sXG4gICAgICBfcm91bmRNb2RpZmllciA9IGZ1bmN0aW9uIF9yb3VuZE1vZGlmaWVyKHYpIHtcbiAgICB2YXIgcCA9IE1hdGgucG93KDEwLCAoKHYgKyBcIlwiKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHJhdykge1xuICAgICAgdmFyIG4gPSBfcm91bmRQcmVjaXNlKE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcCk7XG5cbiAgICAgIHJldHVybiAobiAtIG4gJSAxKSAvIHAgKyAoX2lzTnVtYmVyKHJhdykgPyAwIDogZ2V0VW5pdChyYXcpKTtcbiAgICB9O1xuICB9LFxuICAgICAgc25hcCA9IGZ1bmN0aW9uIHNuYXAoc25hcFRvLCB2YWx1ZSkge1xuICAgIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBpczJEO1xuXG4gICAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgICByYWRpdXMgPSBpc0FycmF5ID0gc25hcFRvLnJhZGl1cyB8fCBfYmlnTnVtO1xuXG4gICAgICBpZiAoc25hcFRvLnZhbHVlcykge1xuICAgICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICAgIGlmIChpczJEID0gIV9pc051bWJlcihzbmFwVG9bMF0pKSB7XG4gICAgICAgICAgcmFkaXVzICo9IHJhZGl1cztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc25hcFRvID0gX3JvdW5kTW9kaWZpZXIoc25hcFRvLmluY3JlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgIWlzQXJyYXkgPyBfcm91bmRNb2RpZmllcihzbmFwVG8pIDogX2lzRnVuY3Rpb24oc25hcFRvKSA/IGZ1bmN0aW9uIChyYXcpIHtcbiAgICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICAgIHJldHVybiBNYXRoLmFicyhpczJEIC0gcmF3KSA8PSByYWRpdXMgPyBpczJEIDogcmF3O1xuICAgIH0gOiBmdW5jdGlvbiAocmF3KSB7XG4gICAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgICB5ID0gcGFyc2VGbG9hdChpczJEID8gcmF3LnkgOiAwKSxcbiAgICAgICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICAgIGkgPSBzbmFwVG8ubGVuZ3RoLFxuICAgICAgICAgIGR4LFxuICAgICAgICAgIGR5O1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChpczJEKSB7XG4gICAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgICAgZHkgPSBzbmFwVG9baV0ueSAtIHk7XG4gICAgICAgICAgZHggPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkeCA9IE1hdGguYWJzKHNuYXBUb1tpXSAtIHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgICAgbWluID0gZHg7XG4gICAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2xvc2VzdCA9ICFyYWRpdXMgfHwgbWluIDw9IHJhZGl1cyA/IHNuYXBUb1tjbG9zZXN0XSA6IHJhdztcbiAgICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICAgIH0pO1xuICB9LFxuICAgICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKF9pc0FycmF5KG1pbikgPyAhbWF4IDogcm91bmRpbmdJbmNyZW1lbnQgPT09IHRydWUgPyAhIShyb3VuZGluZ0luY3JlbWVudCA9IDApIDogIXJldHVybkZ1bmN0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2lzQXJyYXkobWluKSA/IG1pblt+fihNYXRoLnJhbmRvbSgpICogbWluLmxlbmd0aCldIDogKHJvdW5kaW5nSW5jcmVtZW50ID0gcm91bmRpbmdJbmNyZW1lbnQgfHwgMWUtNSkgJiYgKHJldHVybkZ1bmN0aW9uID0gcm91bmRpbmdJbmNyZW1lbnQgPCAxID8gTWF0aC5wb3coMTAsIChyb3VuZGluZ0luY3JlbWVudCArIFwiXCIpLmxlbmd0aCAtIDIpIDogMSkgJiYgTWF0aC5mbG9vcihNYXRoLnJvdW5kKChtaW4gLSByb3VuZGluZ0luY3JlbWVudCAvIDIgKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIHJvdW5kaW5nSW5jcmVtZW50ICogLjk5KSkgLyByb3VuZGluZ0luY3JlbWVudCkgKiByb3VuZGluZ0luY3JlbWVudCAqIHJldHVybkZ1bmN0aW9uKSAvIHJldHVybkZ1bmN0aW9uO1xuICAgIH0pO1xuICB9LFxuICAgICAgcGlwZSA9IGZ1bmN0aW9uIHBpcGUoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGZ1bmN0aW9uc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb25zLnJlZHVjZShmdW5jdGlvbiAodiwgZikge1xuICAgICAgICByZXR1cm4gZih2KTtcbiAgICAgIH0sIHZhbHVlKTtcbiAgICB9O1xuICB9LFxuICAgICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jKHBhcnNlRmxvYXQodmFsdWUpKSArICh1bml0IHx8IGdldFVuaXQodmFsdWUpKTtcbiAgICB9O1xuICB9LFxuICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAgIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xuICB9LFxuICAgICAgX3dyYXBBcnJheSA9IGZ1bmN0aW9uIF93cmFwQXJyYXkoYSwgd3JhcHBlciwgdmFsdWUpIHtcbiAgICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHJldHVybiBhW35+d3JhcHBlcihpbmRleCldO1xuICAgIH0pO1xuICB9LFxuICAgICAgd3JhcCA9IGZ1bmN0aW9uIHdyYXAobWluLCBtYXgsIHZhbHVlKSB7XG4gICAgdmFyIHJhbmdlID0gbWF4IC0gbWluO1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gX3dyYXBBcnJheShtaW4sIHdyYXAoMCwgbWluLmxlbmd0aCksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgICB9KTtcbiAgfSxcbiAgICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gICAgdmFyIHJhbmdlID0gbWF4IC0gbWluLFxuICAgICAgICB0b3RhbCA9IHJhbmdlICogMjtcbiAgICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAodG90YWwgKyAodmFsdWUgLSBtaW4pICUgdG90YWwpICUgdG90YWwgfHwgMDtcbiAgICAgIHJldHVybiBtaW4gKyAodmFsdWUgPiByYW5nZSA/IHRvdGFsIC0gdmFsdWUgOiB2YWx1ZSk7XG4gICAgfSk7XG4gIH0sXG4gICAgICBfcmVwbGFjZVJhbmRvbSA9IGZ1bmN0aW9uIF9yZXBsYWNlUmFuZG9tKHZhbHVlKSB7XG4gICAgdmFyIHByZXYgPSAwLFxuICAgICAgICBzID0gXCJcIixcbiAgICAgICAgaSxcbiAgICAgICAgbnVtcyxcbiAgICAgICAgZW5kLFxuICAgICAgICBpc0FycmF5O1xuXG4gICAgd2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuICAgICAgZW5kID0gdmFsdWUuaW5kZXhPZihcIilcIiwgaSk7XG4gICAgICBpc0FycmF5ID0gdmFsdWUuY2hhckF0KGkgKyA3KSA9PT0gXCJbXCI7XG4gICAgICBudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuICAgICAgcyArPSB2YWx1ZS5zdWJzdHIocHJldiwgaSAtIHByZXYpICsgcmFuZG9tKGlzQXJyYXkgPyBudW1zIDogK251bXNbMF0sIGlzQXJyYXkgPyAwIDogK251bXNbMV0sICtudW1zWzJdIHx8IDFlLTUpO1xuICAgICAgcHJldiA9IGVuZCArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMgKyB2YWx1ZS5zdWJzdHIocHJldiwgdmFsdWUubGVuZ3RoIC0gcHJldik7XG4gIH0sXG4gICAgICBtYXBSYW5nZSA9IGZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gICAgdmFyIGluUmFuZ2UgPSBpbk1heCAtIGluTWluLFxuICAgICAgICBvdXRSYW5nZSA9IG91dE1heCAtIG91dE1pbjtcbiAgICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBvdXRNaW4gKyAoKHZhbHVlIC0gaW5NaW4pIC8gaW5SYW5nZSAqIG91dFJhbmdlIHx8IDApO1xuICAgIH0pO1xuICB9LFxuICAgICAgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZShzdGFydCwgZW5kLCBwcm9ncmVzcywgbXV0YXRlKSB7XG4gICAgdmFyIGZ1bmMgPSBpc05hTihzdGFydCArIGVuZCkgPyAwIDogZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAoMSAtIHApICogc3RhcnQgKyBwICogZW5kO1xuICAgIH07XG5cbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG4gICAgICAgICAgbWFzdGVyID0ge30sXG4gICAgICAgICAgcCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGludGVycG9sYXRvcnMsXG4gICAgICAgICAgbCxcbiAgICAgICAgICBpbDtcblxuICAgICAgcHJvZ3Jlc3MgPT09IHRydWUgJiYgKG11dGF0ZSA9IDEpICYmIChwcm9ncmVzcyA9IG51bGwpO1xuXG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgcDogc3RhcnRcbiAgICAgICAgfTtcbiAgICAgICAgZW5kID0ge1xuICAgICAgICAgIHA6IGVuZFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgaW50ZXJwb2xhdG9ycyA9IFtdO1xuICAgICAgICBsID0gc3RhcnQubGVuZ3RoO1xuICAgICAgICBpbCA9IGwgLSAyO1xuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpbnRlcnBvbGF0b3JzLnB1c2goaW50ZXJwb2xhdGUoc3RhcnRbaSAtIDFdLCBzdGFydFtpXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbC0tO1xuXG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiBmdW5jKHApIHtcbiAgICAgICAgICBwICo9IGw7XG4gICAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdG9yc1tpXShwIC0gaSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcHJvZ3Jlc3MgPSBlbmQ7XG4gICAgICB9IGVsc2UgaWYgKCFtdXRhdGUpIHtcbiAgICAgICAgc3RhcnQgPSBfbWVyZ2UoX2lzQXJyYXkoc3RhcnQpID8gW10gOiB7fSwgc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWludGVycG9sYXRvcnMpIHtcbiAgICAgICAgZm9yIChwIGluIGVuZCkge1xuICAgICAgICAgIF9hZGRQcm9wVHdlZW4uY2FsbChtYXN0ZXIsIHN0YXJ0LCBwLCBcImdldFwiLCBlbmRbcF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMocCkge1xuICAgICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihwcm9ncmVzcywgZnVuYyk7XG4gIH0sXG4gICAgICBfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRpbWVsaW5lLCBmcm9tVGltZSwgYmFja3dhcmQpIHtcbiAgICB2YXIgbGFiZWxzID0gdGltZWxpbmUubGFiZWxzLFxuICAgICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgICBwLFxuICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgbGFiZWw7XG5cbiAgICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgICBkaXN0YW5jZSA9IGxhYmVsc1twXSAtIGZyb21UaW1lO1xuXG4gICAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcbiAgICAgICAgbGFiZWwgPSBwO1xuICAgICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGFiZWw7XG4gIH0sXG4gICAgICBfY2FsbGJhY2sgPSBmdW5jdGlvbiBfY2FsbGJhY2soYW5pbWF0aW9uLCB0eXBlLCBleGVjdXRlTGF6eUZpcnN0KSB7XG4gICAgdmFyIHYgPSBhbmltYXRpb24udmFycyxcbiAgICAgICAgY2FsbGJhY2sgPSB2W3R5cGVdLFxuICAgICAgICBwcmV2Q29udGV4dCA9IF9jb250ZXh0LFxuICAgICAgICBjb250ZXh0ID0gYW5pbWF0aW9uLl9jdHgsXG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgc2NvcGUsXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwYXJhbXMgPSB2W3R5cGUgKyBcIlBhcmFtc1wiXTtcbiAgICBzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XG4gICAgZXhlY3V0ZUxhenlGaXJzdCAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcbiAgICBjb250ZXh0ICYmIChfY29udGV4dCA9IGNvbnRleHQpO1xuICAgIHJlc3VsdCA9IHBhcmFtcyA/IGNhbGxiYWNrLmFwcGx5KHNjb3BlLCBwYXJhbXMpIDogY2FsbGJhY2suY2FsbChzY29wZSk7XG4gICAgX2NvbnRleHQgPSBwcmV2Q29udGV4dDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICAgICAgX2ludGVycnVwdCA9IGZ1bmN0aW9uIF9pbnRlcnJ1cHQoYW5pbWF0aW9uKSB7XG4gICAgX3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblxuICAgIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyICYmIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyLmtpbGwoISFfcmV2ZXJ0aW5nKTtcbiAgICBhbmltYXRpb24ucHJvZ3Jlc3MoKSA8IDEgJiYgX2NhbGxiYWNrKGFuaW1hdGlvbiwgXCJvbkludGVycnVwdFwiKTtcbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9LFxuICAgICAgX3F1aWNrVHdlZW4sXG4gICAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZSA9IFtdLFxuICAgICAgX2NyZWF0ZVBsdWdpbiA9IGZ1bmN0aW9uIF9jcmVhdGVQbHVnaW4oY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcpIHJldHVybjtcbiAgICBjb25maWcgPSAhY29uZmlnLm5hbWUgJiYgY29uZmlnW1wiZGVmYXVsdFwiXSB8fCBjb25maWc7XG5cbiAgICBpZiAoX3dpbmRvd0V4aXN0cygpIHx8IGNvbmZpZy5oZWFkbGVzcykge1xuICAgICAgdmFyIG5hbWUgPSBjb25maWcubmFtZSxcbiAgICAgICAgICBpc0Z1bmMgPSBfaXNGdW5jdGlvbihjb25maWcpLFxuICAgICAgICAgIFBsdWdpbiA9IG5hbWUgJiYgIWlzRnVuYyAmJiBjb25maWcuaW5pdCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBbXTtcbiAgICAgIH0gOiBjb25maWcsXG4gICAgICAgICAgaW5zdGFuY2VEZWZhdWx0cyA9IHtcbiAgICAgICAgaW5pdDogX2VtcHR5RnVuYyxcbiAgICAgICAgcmVuZGVyOiBfcmVuZGVyUHJvcFR3ZWVucyxcbiAgICAgICAgYWRkOiBfYWRkUHJvcFR3ZWVuLFxuICAgICAgICBraWxsOiBfa2lsbFByb3BUd2VlbnNPZixcbiAgICAgICAgbW9kaWZpZXI6IF9hZGRQbHVnaW5Nb2RpZmllcixcbiAgICAgICAgcmF3VmFyczogMFxuICAgICAgfSxcbiAgICAgICAgICBzdGF0aWNzID0ge1xuICAgICAgICB0YXJnZXRUZXN0OiAwLFxuICAgICAgICBnZXQ6IDAsXG4gICAgICAgIGdldFNldHRlcjogX2dldFNldHRlcixcbiAgICAgICAgYWxpYXNlczoge30sXG4gICAgICAgIHJlZ2lzdGVyOiAwXG4gICAgICB9O1xuXG4gICAgICBfd2FrZSgpO1xuXG4gICAgICBpZiAoY29uZmlnICE9PSBQbHVnaW4pIHtcbiAgICAgICAgaWYgKF9wbHVnaW5zW25hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTtcblxuICAgICAgICBfbWVyZ2UoUGx1Z2luLnByb3RvdHlwZSwgX21lcmdlKGluc3RhbmNlRGVmYXVsdHMsIF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgc3RhdGljcykpKTtcblxuICAgICAgICBfcGx1Z2luc1tQbHVnaW4ucHJvcCA9IG5hbWVdID0gUGx1Z2luO1xuXG4gICAgICAgIGlmIChjb25maWcudGFyZ2V0VGVzdCkge1xuICAgICAgICAgIF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XG5cbiAgICAgICAgICBfcmVzZXJ2ZWRQcm9wc1tuYW1lXSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gKG5hbWUgPT09IFwiY3NzXCIgPyBcIkNTU1wiIDogbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKSArIFwiUGx1Z2luXCI7XG4gICAgICB9XG5cbiAgICAgIF9hZGRHbG9iYWwobmFtZSwgUGx1Z2luKTtcblxuICAgICAgY29uZmlnLnJlZ2lzdGVyICYmIGNvbmZpZy5yZWdpc3Rlcihnc2FwLCBQbHVnaW4sIFByb3BUd2Vlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9yZWdpc3RlclBsdWdpblF1ZXVlLnB1c2goY29uZmlnKTtcbiAgICB9XG4gIH0sXG4gICAgICBfMjU1ID0gMjU1LFxuICAgICAgX2NvbG9yTG9va3VwID0ge1xuICAgIGFxdWE6IFswLCBfMjU1LCBfMjU1XSxcbiAgICBsaW1lOiBbMCwgXzI1NSwgMF0sXG4gICAgc2lsdmVyOiBbMTkyLCAxOTIsIDE5Ml0sXG4gICAgYmxhY2s6IFswLCAwLCAwXSxcbiAgICBtYXJvb246IFsxMjgsIDAsIDBdLFxuICAgIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gICAgYmx1ZTogWzAsIDAsIF8yNTVdLFxuICAgIG5hdnk6IFswLCAwLCAxMjhdLFxuICAgIHdoaXRlOiBbXzI1NSwgXzI1NSwgXzI1NV0sXG4gICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgeWVsbG93OiBbXzI1NSwgXzI1NSwgMF0sXG4gICAgb3JhbmdlOiBbXzI1NSwgMTY1LCAwXSxcbiAgICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgcHVycGxlOiBbMTI4LCAwLCAxMjhdLFxuICAgIGdyZWVuOiBbMCwgMTI4LCAwXSxcbiAgICByZWQ6IFtfMjU1LCAwLCAwXSxcbiAgICBwaW5rOiBbXzI1NSwgMTkyLCAyMDNdLFxuICAgIGN5YW46IFswLCBfMjU1LCBfMjU1XSxcbiAgICB0cmFuc3BhcmVudDogW18yNTUsIF8yNTUsIF8yNTUsIDBdXG4gIH0sXG4gICAgICBfaHVlID0gZnVuY3Rpb24gX2h1ZShoLCBtMSwgbTIpIHtcbiAgICBoICs9IGggPCAwID8gMSA6IGggPiAxID8gLTEgOiAwO1xuICAgIHJldHVybiAoaCAqIDYgPCAxID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IGggPCAuNSA/IG0yIDogaCAqIDMgPCAyID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiBfMjU1ICsgLjUgfCAwO1xuICB9LFxuICAgICAgc3BsaXRDb2xvciA9IGZ1bmN0aW9uIHNwbGl0Q29sb3IodiwgdG9IU0wsIGZvcmNlQWxwaGEpIHtcbiAgICB2YXIgYSA9ICF2ID8gX2NvbG9yTG9va3VwLmJsYWNrIDogX2lzTnVtYmVyKHYpID8gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXG4gICAgICAgIHIsXG4gICAgICAgIGcsXG4gICAgICAgIGIsXG4gICAgICAgIGgsXG4gICAgICAgIHMsXG4gICAgICAgIGwsXG4gICAgICAgIG1heCxcbiAgICAgICAgbWluLFxuICAgICAgICBkLFxuICAgICAgICB3YXNIU0w7XG5cbiAgICBpZiAoIWEpIHtcbiAgICAgIGlmICh2LnN1YnN0cigtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgIHYgPSB2LnN1YnN0cigwLCB2Lmxlbmd0aCAtIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2NvbG9yTG9va3VwW3ZdKSB7XG4gICAgICAgIGEgPSBfY29sb3JMb29rdXBbdl07XG4gICAgICB9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICBpZiAodi5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgciA9IHYuY2hhckF0KDEpO1xuICAgICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcbiAgICAgICAgICBiID0gdi5jaGFyQXQoMyk7XG4gICAgICAgICAgdiA9IFwiI1wiICsgciArIHIgKyBnICsgZyArIGIgKyBiICsgKHYubGVuZ3RoID09PSA1ID8gdi5jaGFyQXQoNCkgKyB2LmNoYXJBdCg0KSA6IFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYubGVuZ3RoID09PSA5KSB7XG4gICAgICAgICAgYSA9IHBhcnNlSW50KHYuc3Vic3RyKDEsIDYpLCAxNik7XG4gICAgICAgICAgcmV0dXJuIFthID4+IDE2LCBhID4+IDggJiBfMjU1LCBhICYgXzI1NSwgcGFyc2VJbnQodi5zdWJzdHIoNyksIDE2KSAvIDI1NV07XG4gICAgICAgIH1cblxuICAgICAgICB2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcbiAgICAgICAgYSA9IFt2ID4+IDE2LCB2ID4+IDggJiBfMjU1LCB2ICYgXzI1NV07XG4gICAgICB9IGVsc2UgaWYgKHYuc3Vic3RyKDAsIDMpID09PSBcImhzbFwiKSB7XG4gICAgICAgIGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApO1xuXG4gICAgICAgIGlmICghdG9IU0wpIHtcbiAgICAgICAgICBoID0gK2FbMF0gJSAzNjAgLyAzNjA7XG4gICAgICAgICAgcyA9ICthWzFdIC8gMTAwO1xuICAgICAgICAgIGwgPSArYVsyXSAvIDEwMDtcbiAgICAgICAgICBnID0gbCA8PSAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICByID0gbCAqIDIgLSBnO1xuICAgICAgICAgIGEubGVuZ3RoID4gMyAmJiAoYVszXSAqPSAxKTtcbiAgICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuICAgICAgICAgIGFbMV0gPSBfaHVlKGgsIHIsIGcpO1xuICAgICAgICAgIGFbMl0gPSBfaHVlKGggLSAxIC8gMywgciwgZyk7XG4gICAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcbiAgICAgICAgICBhID0gdi5tYXRjaChfbnVtRXhwKTtcbiAgICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gdi5tYXRjaChfc3RyaWN0TnVtRXhwKSB8fCBfY29sb3JMb29rdXAudHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGEgPSBhLm1hcChOdW1iZXIpO1xuICAgIH1cblxuICAgIGlmICh0b0hTTCAmJiAhd2FzSFNMKSB7XG4gICAgICByID0gYVswXSAvIF8yNTU7XG4gICAgICBnID0gYVsxXSAvIF8yNTU7XG4gICAgICBiID0gYVsyXSAvIF8yNTU7XG4gICAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgICAgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSBzID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgaCA9IG1heCA9PT0gciA/IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApIDogbWF4ID09PSBnID8gKGIgLSByKSAvIGQgKyAyIDogKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgICBoICo9IDYwO1xuICAgICAgfVxuXG4gICAgICBhWzBdID0gfn4oaCArIC41KTtcbiAgICAgIGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuICAgICAgYVsyXSA9IH5+KGwgKiAxMDAgKyAuNSk7XG4gICAgfVxuXG4gICAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgICAgIF9jb2xvck9yZGVyRGF0YSA9IGZ1bmN0aW9uIF9jb2xvck9yZGVyRGF0YSh2KSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdLFxuICAgICAgICBjID0gW10sXG4gICAgICAgIGkgPSAtMTtcbiAgICB2LnNwbGl0KF9jb2xvckV4cCkuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgdmFyIGEgPSB2Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gICAgICB2YWx1ZXMucHVzaC5hcHBseSh2YWx1ZXMsIGEpO1xuICAgICAgYy5wdXNoKGkgKz0gYS5sZW5ndGggKyAxKTtcbiAgICB9KTtcbiAgICB2YWx1ZXMuYyA9IGM7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSxcbiAgICAgIF9mb3JtYXRDb2xvcnMgPSBmdW5jdGlvbiBfZm9ybWF0Q29sb3JzKHMsIHRvSFNMLCBvcmRlck1hdGNoRGF0YSkge1xuICAgIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgICBjb2xvcnMgPSAocyArIHJlc3VsdCkubWF0Y2goX2NvbG9yRXhwKSxcbiAgICAgICAgdHlwZSA9IHRvSFNMID8gXCJoc2xhKFwiIDogXCJyZ2JhKFwiLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgYyxcbiAgICAgICAgc2hlbGwsXG4gICAgICAgIGQsXG4gICAgICAgIGw7XG5cbiAgICBpZiAoIWNvbG9ycykge1xuICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgY29sb3JzID0gY29sb3JzLm1hcChmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgIHJldHVybiAoY29sb3IgPSBzcGxpdENvbG9yKGNvbG9yLCB0b0hTTCwgMSkpICYmIHR5cGUgKyAodG9IU0wgPyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIiUsXCIgKyBjb2xvclsyXSArIFwiJSxcIiArIGNvbG9yWzNdIDogY29sb3Iuam9pbihcIixcIikpICsgXCIpXCI7XG4gICAgfSk7XG5cbiAgICBpZiAob3JkZXJNYXRjaERhdGEpIHtcbiAgICAgIGQgPSBfY29sb3JPcmRlckRhdGEocyk7XG4gICAgICBjID0gb3JkZXJNYXRjaERhdGEuYztcblxuICAgICAgaWYgKGMuam9pbihyZXN1bHQpICE9PSBkLmMuam9pbihyZXN1bHQpKSB7XG4gICAgICAgIHNoZWxsID0gcy5yZXBsYWNlKF9jb2xvckV4cCwgXCIxXCIpLnNwbGl0KF9udW1XaXRoVW5pdEV4cCk7XG4gICAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgKH5jLmluZGV4T2YoaSkgPyBjb2xvcnMuc2hpZnQoKSB8fCB0eXBlICsgXCIwLDAsMCwwKVwiIDogKGQubGVuZ3RoID8gZCA6IGNvbG9ycy5sZW5ndGggPyBjb2xvcnMgOiBvcmRlck1hdGNoRGF0YSkuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNoZWxsKSB7XG4gICAgICBzaGVsbCA9IHMuc3BsaXQoX2NvbG9yRXhwKTtcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyBjb2xvcnNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdCArIHNoZWxsW2xdO1xuICB9LFxuICAgICAgX2NvbG9yRXhwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzID0gXCIoPzpcXFxcYig/Oig/OnJnYnxyZ2JhfGhzbHxoc2xhKVxcXFwoLis/XFxcXCkpfFxcXFxCIyg/OlswLTlhLWZdezMsNH0pezEsMn1cXFxcYlwiLFxuICAgICAgICBwO1xuXG4gICAgZm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuICAgICAgcyArPSBcInxcIiArIHAgKyBcIlxcXFxiXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocyArIFwiKVwiLCBcImdpXCIpO1xuICB9KCksXG4gICAgICBfaHNsRXhwID0gL2hzbFthXT9cXCgvLFxuICAgICAgX2NvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24gX2NvbG9yU3RyaW5nRmlsdGVyKGEpIHtcbiAgICB2YXIgY29tYmluZWQgPSBhLmpvaW4oXCIgXCIpLFxuICAgICAgICB0b0hTTDtcbiAgICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICAgIGlmIChfY29sb3JFeHAudGVzdChjb21iaW5lZCkpIHtcbiAgICAgIHRvSFNMID0gX2hzbEV4cC50ZXN0KGNvbWJpbmVkKTtcbiAgICAgIGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcbiAgICAgIGFbMF0gPSBfZm9ybWF0Q29sb3JzKGFbMF0sIHRvSFNMLCBfY29sb3JPcmRlckRhdGEoYVsxXSkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LFxuICAgICAgX3RpY2tlckFjdGl2ZSxcbiAgICAgIF90aWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgICAgIF9sYWdUaHJlc2hvbGQgPSA1MDAsXG4gICAgICAgIF9hZGp1c3RlZExhZyA9IDMzLFxuICAgICAgICBfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcbiAgICAgICAgX2xhc3RVcGRhdGUgPSBfc3RhcnRUaW1lLFxuICAgICAgICBfZ2FwID0gMTAwMCAvIDI0MCxcbiAgICAgICAgX25leHRUaW1lID0gX2dhcCxcbiAgICAgICAgX2xpc3RlbmVycyA9IFtdLFxuICAgICAgICBfaWQsXG4gICAgICAgIF9yZXEsXG4gICAgICAgIF9yYWYsXG4gICAgICAgIF9zZWxmLFxuICAgICAgICBfZGVsdGEsXG4gICAgICAgIF9pLFxuICAgICAgICBfdGljayA9IGZ1bmN0aW9uIF90aWNrKHYpIHtcbiAgICAgIHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuICAgICAgICAgIG1hbnVhbCA9IHYgPT09IHRydWUsXG4gICAgICAgICAgb3ZlcmxhcCxcbiAgICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgICB0aW1lLFxuICAgICAgICAgIGZyYW1lO1xuXG4gICAgICAoZWxhcHNlZCA+IF9sYWdUaHJlc2hvbGQgfHwgZWxhcHNlZCA8IDApICYmIChfc3RhcnRUaW1lICs9IGVsYXBzZWQgLSBfYWRqdXN0ZWRMYWcpO1xuICAgICAgX2xhc3RVcGRhdGUgKz0gZWxhcHNlZDtcbiAgICAgIHRpbWUgPSBfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWU7XG4gICAgICBvdmVybGFwID0gdGltZSAtIF9uZXh0VGltZTtcblxuICAgICAgaWYgKG92ZXJsYXAgPiAwIHx8IG1hbnVhbCkge1xuICAgICAgICBmcmFtZSA9ICsrX3NlbGYuZnJhbWU7XG4gICAgICAgIF9kZWx0YSA9IHRpbWUgLSBfc2VsZi50aW1lICogMTAwMDtcbiAgICAgICAgX3NlbGYudGltZSA9IHRpbWUgPSB0aW1lIC8gMTAwMDtcbiAgICAgICAgX25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gNCA6IF9nYXAgLSBvdmVybGFwKTtcbiAgICAgICAgZGlzcGF0Y2ggPSAxO1xuICAgICAgfVxuXG4gICAgICBtYW51YWwgfHwgKF9pZCA9IF9yZXEoX3RpY2spKTtcblxuICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGZvciAoX2kgPSAwOyBfaSA8IF9saXN0ZW5lcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgX2xpc3RlbmVyc1tfaV0odGltZSwgX2RlbHRhLCBmcmFtZSwgdik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3NlbGYgPSB7XG4gICAgICB0aW1lOiAwLFxuICAgICAgZnJhbWU6IDAsXG4gICAgICB0aWNrOiBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgICBfdGljayh0cnVlKTtcbiAgICAgIH0sXG4gICAgICBkZWx0YVJhdGlvOiBmdW5jdGlvbiBkZWx0YVJhdGlvKGZwcykge1xuICAgICAgICByZXR1cm4gX2RlbHRhIC8gKDEwMDAgLyAoZnBzIHx8IDYwKSk7XG4gICAgICB9LFxuICAgICAgd2FrZTogZnVuY3Rpb24gd2FrZSgpIHtcbiAgICAgICAgaWYgKF9jb3JlUmVhZHkpIHtcbiAgICAgICAgICBpZiAoIV9jb3JlSW5pdHRlZCAmJiBfd2luZG93RXhpc3RzKCkpIHtcbiAgICAgICAgICAgIF93aW4gPSBfY29yZUluaXR0ZWQgPSB3aW5kb3c7XG4gICAgICAgICAgICBfZG9jID0gX3dpbi5kb2N1bWVudCB8fCB7fTtcbiAgICAgICAgICAgIF9nbG9iYWxzLmdzYXAgPSBnc2FwO1xuICAgICAgICAgICAgKF93aW4uZ3NhcFZlcnNpb25zIHx8IChfd2luLmdzYXBWZXJzaW9ucyA9IFtdKSkucHVzaChnc2FwLnZlcnNpb24pO1xuXG4gICAgICAgICAgICBfaW5zdGFsbChfaW5zdGFsbFNjb3BlIHx8IF93aW4uR3JlZW5Tb2NrR2xvYmFscyB8fCAhX3dpbi5nc2FwICYmIF93aW4gfHwge30pO1xuXG4gICAgICAgICAgICBfcmVnaXN0ZXJQbHVnaW5RdWV1ZS5mb3JFYWNoKF9jcmVhdGVQbHVnaW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9yYWYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgICBfaWQgJiYgX3NlbGYuc2xlZXAoKTtcblxuICAgICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChmLCBfbmV4dFRpbWUgLSBfc2VsZi50aW1lICogMTAwMCArIDEgfCAwKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgX3RpY2tlckFjdGl2ZSA9IDE7XG5cbiAgICAgICAgICBfdGljaygyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNsZWVwOiBmdW5jdGlvbiBzbGVlcCgpIHtcbiAgICAgICAgKF9yYWYgPyBjYW5jZWxBbmltYXRpb25GcmFtZSA6IGNsZWFyVGltZW91dCkoX2lkKTtcbiAgICAgICAgX3RpY2tlckFjdGl2ZSA9IDA7XG4gICAgICAgIF9yZXEgPSBfZW1wdHlGdW5jO1xuICAgICAgfSxcbiAgICAgIGxhZ1Ntb290aGluZzogZnVuY3Rpb24gbGFnU21vb3RoaW5nKHRocmVzaG9sZCwgYWRqdXN0ZWRMYWcpIHtcbiAgICAgICAgX2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCBJbmZpbml0eTtcbiAgICAgICAgX2FkanVzdGVkTGFnID0gTWF0aC5taW4oYWRqdXN0ZWRMYWcgfHwgMzMsIF9sYWdUaHJlc2hvbGQpO1xuICAgICAgfSxcbiAgICAgIGZwczogZnVuY3Rpb24gZnBzKF9mcHMpIHtcbiAgICAgICAgX2dhcCA9IDEwMDAgLyAoX2ZwcyB8fCAyNDApO1xuICAgICAgICBfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG4gICAgICB9LFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoY2FsbGJhY2ssIG9uY2UsIHByaW9yaXRpemUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBvbmNlID8gZnVuY3Rpb24gKHQsIGQsIGYsIHYpIHtcbiAgICAgICAgICBjYWxsYmFjayh0LCBkLCBmLCB2KTtcblxuICAgICAgICAgIF9zZWxmLnJlbW92ZShmdW5jKTtcbiAgICAgICAgfSA6IGNhbGxiYWNrO1xuXG4gICAgICAgIF9zZWxmLnJlbW92ZShjYWxsYmFjayk7XG5cbiAgICAgICAgX2xpc3RlbmVyc1twcmlvcml0aXplID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIl0oZnVuYyk7XG5cbiAgICAgICAgX3dha2UoKTtcblxuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShjYWxsYmFjaywgaSkge1xuICAgICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgICB9LFxuICAgICAgX2xpc3RlbmVyczogX2xpc3RlbmVyc1xuICAgIH07XG4gICAgcmV0dXJuIF9zZWxmO1xuICB9KCksXG4gICAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICAgIHJldHVybiAhX3RpY2tlckFjdGl2ZSAmJiBfdGlja2VyLndha2UoKTtcbiAgfSxcbiAgICAgIF9lYXNlTWFwID0ge30sXG4gICAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgICAgX3F1b3Rlc0V4cCA9IC9bXCInXS9nLFxuICAgICAgX3BhcnNlT2JqZWN0SW5TdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VPYmplY3RJblN0cmluZyh2YWx1ZSkge1xuICAgIHZhciBvYmogPSB7fSxcbiAgICAgICAgc3BsaXQgPSB2YWx1ZS5zdWJzdHIoMSwgdmFsdWUubGVuZ3RoIC0gMykuc3BsaXQoXCI6XCIpLFxuICAgICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgICAgaSA9IDEsXG4gICAgICAgIGwgPSBzcGxpdC5sZW5ndGgsXG4gICAgICAgIGluZGV4LFxuICAgICAgICB2YWwsXG4gICAgICAgIHBhcnNlZFZhbDtcblxuICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YWwgPSBzcGxpdFtpXTtcbiAgICAgIGluZGV4ID0gaSAhPT0gbCAtIDEgPyB2YWwubGFzdEluZGV4T2YoXCIsXCIpIDogdmFsLmxlbmd0aDtcbiAgICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgICAgb2JqW2tleV0gPSBpc05hTihwYXJzZWRWYWwpID8gcGFyc2VkVmFsLnJlcGxhY2UoX3F1b3Rlc0V4cCwgXCJcIikudHJpbSgpIDogK3BhcnNlZFZhbDtcbiAgICAgIGtleSA9IHZhbC5zdWJzdHIoaW5kZXggKyAxKS50cmltKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfSxcbiAgICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gICAgdmFyIG9wZW4gPSB2YWx1ZS5pbmRleE9mKFwiKFwiKSArIDEsXG4gICAgICAgIGNsb3NlID0gdmFsdWUuaW5kZXhPZihcIilcIiksXG4gICAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcob3Blbiwgfm5lc3RlZCAmJiBuZXN0ZWQgPCBjbG9zZSA/IHZhbHVlLmluZGV4T2YoXCIpXCIsIGNsb3NlICsgMSkgOiBjbG9zZSk7XG4gIH0sXG4gICAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAgIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgICBlYXNlID0gX2Vhc2VNYXBbc3BsaXRbMF1dO1xuICAgIHJldHVybiBlYXNlICYmIHNwbGl0Lmxlbmd0aCA+IDEgJiYgZWFzZS5jb25maWcgPyBlYXNlLmNvbmZpZy5hcHBseShudWxsLCB+bmFtZS5pbmRleE9mKFwie1wiKSA/IFtfcGFyc2VPYmplY3RJblN0cmluZyhzcGxpdFsxXSldIDogX3ZhbHVlSW5QYXJlbnRoZXNlcyhuYW1lKS5zcGxpdChcIixcIikubWFwKF9udW1lcmljSWZQb3NzaWJsZSkpIDogX2Vhc2VNYXAuX0NFICYmIF9jdXN0b21FYXNlRXhwLnRlc3QobmFtZSkgPyBfZWFzZU1hcC5fQ0UoXCJcIiwgbmFtZSkgOiBlYXNlO1xuICB9LFxuICAgICAgX2ludmVydEVhc2UgPSBmdW5jdGlvbiBfaW52ZXJ0RWFzZShlYXNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICAgIH07XG4gIH0sXG4gICAgICBfcHJvcGFnYXRlWW95b0Vhc2UgPSBmdW5jdGlvbiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95bykge1xuICAgIHZhciBjaGlsZCA9IHRpbWVsaW5lLl9maXJzdCxcbiAgICAgICAgZWFzZTtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC52YXJzLnlveW9FYXNlICYmICghY2hpbGQuX3lveW8gfHwgIWNoaWxkLl9yZXBlYXQpICYmIGNoaWxkLl95b3lvICE9PSBpc1lveW8pIHtcbiAgICAgICAgaWYgKGNoaWxkLnRpbWVsaW5lKSB7XG4gICAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVhc2UgPSBjaGlsZC5fZWFzZTtcbiAgICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgICBjaGlsZC5feUVhc2UgPSBlYXNlO1xuICAgICAgICAgIGNoaWxkLl95b3lvID0gaXNZb3lvO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9LFxuICAgICAgX3BhcnNlRWFzZSA9IGZ1bmN0aW9uIF9wYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xuICB9LFxuICAgICAgX2luc2VydEVhc2UgPSBmdW5jdGlvbiBfaW5zZXJ0RWFzZShuYW1lcywgZWFzZUluLCBlYXNlT3V0LCBlYXNlSW5PdXQpIHtcbiAgICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICAgIHJldHVybiAxIC0gZWFzZUluKDEgLSBwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGVhc2VJbk91dCA9PT0gdm9pZCAwKSB7XG4gICAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgICByZXR1cm4gcCA8IC41ID8gZWFzZUluKHAgKiAyKSAvIDIgOiAxIC0gZWFzZUluKCgxIC0gcCkgKiAyKSAvIDI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBlYXNlID0ge1xuICAgICAgZWFzZUluOiBlYXNlSW4sXG4gICAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgICAgZWFzZUluT3V0OiBlYXNlSW5PdXRcbiAgICB9LFxuICAgICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gICAgX2ZvckVhY2hOYW1lKG5hbWVzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX2Vhc2VNYXBbbmFtZV0gPSBfZ2xvYmFsc1tuYW1lXSA9IGVhc2U7XG4gICAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICAgIGZvciAodmFyIHAgaW4gZWFzZSkge1xuICAgICAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lICsgKHAgPT09IFwiZWFzZUluXCIgPyBcIi5pblwiIDogcCA9PT0gXCJlYXNlT3V0XCIgPyBcIi5vdXRcIiA6IFwiLmluT3V0XCIpXSA9IF9lYXNlTWFwW25hbWUgKyBcIi5cIiArIHBdID0gZWFzZVtwXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlYXNlO1xuICB9LFxuICAgICAgX2Vhc2VJbk91dEZyb21PdXQgPSBmdW5jdGlvbiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgICB9O1xuICB9LFxuICAgICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgIHZhciBwMSA9IGFtcGxpdHVkZSA+PSAxID8gYW1wbGl0dWRlIDogMSxcbiAgICAgICAgcDIgPSAocGVyaW9kIHx8ICh0eXBlID8gLjMgOiAuNDUpKSAvIChhbXBsaXR1ZGUgPCAxID8gYW1wbGl0dWRlIDogMSksXG4gICAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICByZXR1cm4gcCA9PT0gMSA/IDEgOiBwMSAqIE1hdGgucG93KDIsIC0xMCAqIHApICogX3NpbigocCAtIHAzKSAqIHAyKSArIDE7XG4gICAgfSxcbiAgICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gICAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gICAgcDIgPSBfMlBJIC8gcDI7XG5cbiAgICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICAgICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVhc2U7XG4gIH0sXG4gICAgICBfY29uZmlnQmFjayA9IGZ1bmN0aW9uIF9jb25maWdCYWNrKHR5cGUsIG92ZXJzaG9vdCkge1xuICAgIGlmIChvdmVyc2hvb3QgPT09IHZvaWQgMCkge1xuICAgICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgICB9XG5cbiAgICB2YXIgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gICAgfSxcbiAgICAgICAgZWFzZSA9IHR5cGUgPT09IFwib3V0XCIgPyBlYXNlT3V0IDogdHlwZSA9PT0gXCJpblwiID8gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gICAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gICAgZWFzZS5jb25maWcgPSBmdW5jdGlvbiAob3ZlcnNob290KSB7XG4gICAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGVhc2U7XG4gIH07XG5cbiAgX2ZvckVhY2hOYW1lKFwiTGluZWFyLFF1YWQsQ3ViaWMsUXVhcnQsUXVpbnQsU3Ryb25nXCIsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgdmFyIHBvd2VyID0gaSA8IDUgPyBpICsgMSA6IGk7XG5cbiAgICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyhwLCBwb3dlcik7XG4gICAgfSA6IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcDtcbiAgICB9LCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIDEgLSBNYXRoLnBvdygxIC0gcCwgcG93ZXIpO1xuICAgIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gcCA8IC41ID8gTWF0aC5wb3cocCAqIDIsIHBvd2VyKSAvIDIgOiAxIC0gTWF0aC5wb3coKDEgLSBwKSAqIDIsIHBvd2VyKSAvIDI7XG4gICAgfSk7XG4gIH0pO1xuXG4gIF9lYXNlTWFwLkxpbmVhci5lYXNlTm9uZSA9IF9lYXNlTWFwLm5vbmUgPSBfZWFzZU1hcC5MaW5lYXIuZWFzZUluO1xuXG4gIF9pbnNlcnRFYXNlKFwiRWxhc3RpY1wiLCBfY29uZmlnRWxhc3RpYyhcImluXCIpLCBfY29uZmlnRWxhc3RpYyhcIm91dFwiKSwgX2NvbmZpZ0VsYXN0aWMoKSk7XG5cbiAgKGZ1bmN0aW9uIChuLCBjKSB7XG4gICAgdmFyIG4xID0gMSAvIGMsXG4gICAgICAgIG4yID0gMiAqIG4xLFxuICAgICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgICBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgICByZXR1cm4gcCA8IG4xID8gbiAqIHAgKiBwIDogcCA8IG4yID8gbiAqIE1hdGgucG93KHAgLSAxLjUgLyBjLCAyKSArIC43NSA6IHAgPCBuMyA/IG4gKiAocCAtPSAyLjI1IC8gYykgKiBwICsgLjkzNzUgOiBuICogTWF0aC5wb3cocCAtIDIuNjI1IC8gYywgMikgKyAuOTg0Mzc1O1xuICAgIH07XG5cbiAgICBfaW5zZXJ0RWFzZShcIkJvdW5jZVwiLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgICB9LCBlYXNlT3V0KTtcbiAgfSkoNy41NjI1LCAyLjc1KTtcblxuICBfaW5zZXJ0RWFzZShcIkV4cG9cIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiAocCAtIDEpKSAqIHAgKyBwICogcCAqIHAgKiBwICogcCAqIHAgKiAoMSAtIHApO1xuICB9KTtcblxuICBfaW5zZXJ0RWFzZShcIkNpcmNcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG4gIH0pO1xuXG4gIF9pbnNlcnRFYXNlKFwiU2luZVwiLCBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xuICB9KTtcblxuICBfaW5zZXJ0RWFzZShcIkJhY2tcIiwgX2NvbmZpZ0JhY2soXCJpblwiKSwgX2NvbmZpZ0JhY2soXCJvdXRcIiksIF9jb25maWdCYWNrKCkpO1xuXG4gIF9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyhzdGVwcywgaW1tZWRpYXRlU3RhcnQpIHtcbiAgICAgIGlmIChzdGVwcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0ZXBzID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIHAxID0gMSAvIHN0ZXBzLFxuICAgICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgICAgcDMgPSBpbW1lZGlhdGVTdGFydCA/IDEgOiAwLFxuICAgICAgICAgIG1heCA9IDEgLSBfdGlueU51bTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gKChwMiAqIF9jbGFtcCgwLCBtYXgsIHApIHwgMCkgKyBwMykgKiBwMTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBfZGVmYXVsdHMuZWFzZSA9IF9lYXNlTWFwW1wicXVhZC5vdXRcIl07XG5cbiAgX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIF9jYWxsYmFja05hbWVzICs9IG5hbWUgKyBcIixcIiArIG5hbWUgKyBcIlBhcmFtcyxcIjtcbiAgfSk7XG5cbiAgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICAgIHRoaXMuaWQgPSBfZ3NJRCsrO1xuICAgIHRhcmdldC5fZ3NhcCA9IHRoaXM7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5oYXJuZXNzID0gaGFybmVzcztcbiAgICB0aGlzLmdldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldCA6IF9nZXRQcm9wZXJ0eTtcbiAgICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG4gIH07XG4gIHZhciBBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQW5pbWF0aW9uKHZhcnMpIHtcbiAgICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgICB0aGlzLl9kZWxheSA9ICt2YXJzLmRlbGF5IHx8IDA7XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQgPSB2YXJzLnJlcGVhdCA9PT0gSW5maW5pdHkgPyAtMiA6IHZhcnMucmVwZWF0IHx8IDApIHtcbiAgICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgICB0aGlzLl95b3lvID0gISF2YXJzLnlveW8gfHwgISF2YXJzLnlveW9FYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90cyA9IDE7XG5cbiAgICAgIF9zZXREdXJhdGlvbih0aGlzLCArdmFycy5kdXJhdGlvbiwgMSwgMSk7XG5cbiAgICAgIHRoaXMuZGF0YSA9IHZhcnMuZGF0YTtcblxuICAgICAgaWYgKF9jb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX2N0eCA9IF9jb250ZXh0O1xuXG4gICAgICAgIF9jb250ZXh0LmRhdGEucHVzaCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgX3RpY2tlckFjdGl2ZSB8fCBfdGlja2VyLndha2UoKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5kZWxheSA9IGZ1bmN0aW9uIGRlbGF5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgICAgdGhpcy5fZGVsYXkgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9kZWxheTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbER1cmF0aW9uKHRoaXMuX3JlcGVhdCA+IDAgPyB2YWx1ZSArICh2YWx1ZSArIHRoaXMuX3JEZWxheSkgKiB0aGlzLl9yZXBlYXQgOiB2YWx1ZSkgOiB0aGlzLnRvdGFsRHVyYXRpb24oKSAmJiB0aGlzLl9kdXI7XG4gICAgfTtcblxuICAgIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90RHVyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kaXJ0eSA9IDA7XG4gICAgICByZXR1cm4gX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX3JlcGVhdCA8IDAgPyB2YWx1ZSA6ICh2YWx1ZSAtIHRoaXMuX3JlcGVhdCAqIHRoaXMuX3JEZWxheSkgLyAodGhpcy5fcmVwZWF0ICsgMSkpO1xuICAgIH07XG5cbiAgICBfcHJvdG8udG90YWxUaW1lID0gZnVuY3Rpb24gdG90YWxUaW1lKF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBfd2FrZSgpO1xuXG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nICYmIHRoaXMuX3RzKSB7XG4gICAgICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIF90b3RhbFRpbWUpO1xuXG4gICAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTtcblxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICAgIHBhcmVudC50b3RhbFRpbWUocGFyZW50Ll90VGltZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQgJiYgdGhpcy5fZHAuYXV0b1JlbW92ZUNoaWxkcmVuICYmICh0aGlzLl90cyA+IDAgJiYgX3RvdGFsVGltZSA8IHRoaXMuX3REdXIgfHwgdGhpcy5fdHMgPCAwICYmIF90b3RhbFRpbWUgPiAwIHx8ICF0aGlzLl90RHVyICYmICFfdG90YWxUaW1lKSkge1xuICAgICAgICAgIF9hZGRUb1RpbWVsaW5lKHRoaXMuX2RwLCB0aGlzLCB0aGlzLl9zdGFydCAtIHRoaXMuX2RlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fdFRpbWUgIT09IF90b3RhbFRpbWUgfHwgIXRoaXMuX2R1ciAmJiAhc3VwcHJlc3NFdmVudHMgfHwgdGhpcy5faW5pdHRlZCAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgPT09IF90aW55TnVtIHx8ICFfdG90YWxUaW1lICYmICF0aGlzLl9pbml0dGVkICYmICh0aGlzLmFkZCB8fCB0aGlzLl9wdExvb2t1cCkpIHtcbiAgICAgICAgdGhpcy5fdHMgfHwgKHRoaXMuX3BUaW1lID0gX3RvdGFsVGltZSk7XG5cbiAgICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90by50aW1lID0gZnVuY3Rpb24gdGltZSh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lO1xuICAgIH07XG5cbiAgICBfcHJvdG8udG90YWxQcm9ncmVzcyA9IGZ1bmN0aW9uIHRvdGFsUHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF3VGltZSgpID49IDAgJiYgdGhpcy5faW5pdHRlZCA/IDEgOiAwO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBwcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUodGhpcy5kdXJhdGlvbigpICogKHRoaXMuX3lveW8gJiYgISh0aGlzLml0ZXJhdGlvbigpICYgMSkgPyAxIC0gdmFsdWUgOiB2YWx1ZSkgKyBfZWxhcHNlZEN5Y2xlRHVyYXRpb24odGhpcyksIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuZHVyYXRpb24oKSA/IE1hdGgubWluKDEsIHRoaXMuX3RpbWUgLyB0aGlzLl9kdXIpIDogdGhpcy5yYXdUaW1lKCkgPiAwID8gMSA6IDA7XG4gICAgfTtcblxuICAgIF9wcm90by5pdGVyYXRpb24gPSBmdW5jdGlvbiBpdGVyYXRpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICB2YXIgY3ljbGVEdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24oKSArIHRoaXMuX3JEZWxheTtcblxuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLl90aW1lICsgKHZhbHVlIC0gMSkgKiBjeWNsZUR1cmF0aW9uLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl9yZXBlYXQgPyBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pICsgMSA6IDE7XG4gICAgfTtcblxuICAgIF9wcm90by50aW1lU2NhbGUgPSBmdW5jdGlvbiB0aW1lU2NhbGUodmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0cyA9PT0gLV90aW55TnVtID8gMCA6IHRoaXMuX3J0cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3J0cyA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciB0VGltZSA9IHRoaXMucGFyZW50ICYmIHRoaXMuX3RzID8gX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUodGhpcy5wYXJlbnQuX3RpbWUsIHRoaXMpIDogdGhpcy5fdFRpbWU7XG4gICAgICB0aGlzLl9ydHMgPSArdmFsdWUgfHwgMDtcbiAgICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7XG4gICAgICB0aGlzLnRvdGFsVGltZShfY2xhbXAoLU1hdGguYWJzKHRoaXMuX2RlbGF5KSwgdGhpcy50b3RhbER1cmF0aW9uKCksIHRUaW1lKSwgc3VwcHJlc3NFdmVudHMgIT09IGZhbHNlKTtcblxuICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgcmV0dXJuIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucGF1c2VkID0gZnVuY3Rpb24gcGF1c2VkKHZhbHVlKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BzO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3BzID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTtcbiAgICAgICAgICB0aGlzLl90cyA9IHRoaXMuX2FjdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3dha2UoKTtcblxuICAgICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzO1xuICAgICAgICAgIHRoaXMudG90YWxUaW1lKHRoaXMucGFyZW50ICYmICF0aGlzLnBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyA/IHRoaXMucmF3VGltZSgpIDogdGhpcy5fdFRpbWUgfHwgdGhpcy5fcFRpbWUsIHRoaXMucHJvZ3Jlc3MoKSA9PT0gMSAmJiBNYXRoLmFicyh0aGlzLl96VGltZSkgIT09IF90aW55TnVtICYmICh0aGlzLl90VGltZSAtPSBfdGlueU51bSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9zdGFydCA9IHZhbHVlO1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICAgIHBhcmVudCAmJiAocGFyZW50Ll9zb3J0IHx8ICF0aGlzLnBhcmVudCkgJiYgX2FkZFRvVGltZWxpbmUocGFyZW50LCB0aGlzLCB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9zdGFydDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhcnQgKyAoX2lzTm90RmFsc2UoaW5jbHVkZVJlcGVhdHMpID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLmR1cmF0aW9uKCkpIC8gTWF0aC5hYnModGhpcy5fdHMgfHwgMSk7XG4gICAgfTtcblxuICAgIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwO1xuICAgICAgcmV0dXJuICFwYXJlbnQgPyB0aGlzLl90VGltZSA6IHdyYXBSZXBlYXRzICYmICghdGhpcy5fdHMgfHwgdGhpcy5fcmVwZWF0ICYmIHRoaXMuX3RpbWUgJiYgdGhpcy50b3RhbFByb2dyZXNzKCkgPCAxKSA/IHRoaXMuX3RUaW1lICUgKHRoaXMuX2R1ciArIHRoaXMuX3JEZWxheSkgOiAhdGhpcy5fdHMgPyB0aGlzLl90VGltZSA6IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudC5yYXdUaW1lKHdyYXBSZXBlYXRzKSwgdGhpcyk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uZmlnID0gX3JldmVydENvbmZpZztcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJc1JldmVydGluZyA9IF9yZXZlcnRpbmc7XG4gICAgICBfcmV2ZXJ0aW5nID0gY29uZmlnO1xuXG4gICAgICBpZiAoX2lzUmV2ZXJ0V29ydGh5KHRoaXMpKSB7XG4gICAgICAgIHRoaXMudGltZWxpbmUgJiYgdGhpcy50aW1lbGluZS5yZXZlcnQoY29uZmlnKTtcbiAgICAgICAgdGhpcy50b3RhbFRpbWUoLTAuMDEsIGNvbmZpZy5zdXBwcmVzc0V2ZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSAhPT0gXCJuZXN0ZWRcIiAmJiBjb25maWcua2lsbCAhPT0gZmFsc2UgJiYgdGhpcy5raWxsKCk7XG4gICAgICBfcmV2ZXJ0aW5nID0gcHJldklzUmV2ZXJ0aW5nO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90by5nbG9iYWxUaW1lID0gZnVuY3Rpb24gZ2xvYmFsVGltZShyYXdUaW1lKSB7XG4gICAgICB2YXIgYW5pbWF0aW9uID0gdGhpcyxcbiAgICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgICB3aGlsZSAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHRpbWUgPSBhbmltYXRpb24uX3N0YXJ0ICsgdGltZSAvIChNYXRoLmFicyhhbmltYXRpb24uX3RzKSB8fCAxKTtcbiAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uLl9kcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICF0aGlzLnBhcmVudCAmJiB0aGlzLl9zYXQgPyB0aGlzLl9zYXQuZ2xvYmFsVGltZShyYXdUaW1lKSA6IHRpbWU7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHZhbHVlID09PSBJbmZpbml0eSA/IC0yIDogdmFsdWU7XG4gICAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVwZWF0ID09PSAtMiA/IEluZmluaXR5IDogdGhpcy5fcmVwZWF0O1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmVwZWF0RGVsYXkgPSBmdW5jdGlvbiByZXBlYXREZWxheSh2YWx1ZSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgICB0aGlzLl9yRGVsYXkgPSB2YWx1ZTtcblxuICAgICAgICBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aW1lID8gdGhpcy50aW1lKHRpbWUpIDogdGhpcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3JEZWxheTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnlveW8gPSBmdW5jdGlvbiB5b3lvKHZhbHVlKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl95b3lvID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5feW95bztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnNlZWsgPSBmdW5jdGlvbiBzZWVrKHBvc2l0aW9uLCBzdXBwcmVzc0V2ZW50cykge1xuICAgICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlc3RhcnQgPSBmdW5jdGlvbiByZXN0YXJ0KGluY2x1ZGVEZWxheSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIHRoaXMucGxheSgpLnRvdGFsVGltZShpbmNsdWRlRGVsYXkgPyAtdGhpcy5fZGVsYXkgOiAwLCBfaXNOb3RGYWxzZShzdXBwcmVzc0V2ZW50cykpO1xuICAgICAgdGhpcy5fZHVyIHx8ICh0aGlzLl96VGltZSA9IC1fdGlueU51bSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnBsYXkgPSBmdW5jdGlvbiBwbGF5KGZyb20sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2VkKGZhbHNlKS5wYXVzZWQoZmFsc2UpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIGZyb20gIT0gbnVsbCAmJiB0aGlzLnNlZWsoZnJvbSB8fCB0aGlzLnRvdGFsRHVyYXRpb24oKSwgc3VwcHJlc3NFdmVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZWQodHJ1ZSkucGF1c2VkKGZhbHNlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgICAgYXRUaW1lICE9IG51bGwgJiYgdGhpcy5zZWVrKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2VkID0gZnVuY3Rpb24gcmV2ZXJzZWQodmFsdWUpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICEhdmFsdWUgIT09IHRoaXMucmV2ZXJzZWQoKSAmJiB0aGlzLnRpbWVTY2FsZSgtdGhpcy5fcnRzIHx8ICh2YWx1ZSA/IC1fdGlueU51bSA6IDApKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gICAgICB0aGlzLl9pbml0dGVkID0gdGhpcy5fYWN0ID0gMDtcbiAgICAgIHRoaXMuX3pUaW1lID0gLV90aW55TnVtO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90by5pc0FjdGl2ZSA9IGZ1bmN0aW9uIGlzQWN0aXZlKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXMuX2RwLFxuICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG4gICAgICAgICAgcmF3VGltZTtcbiAgICAgIHJldHVybiAhISghcGFyZW50IHx8IHRoaXMuX3RzICYmIHRoaXMuX2luaXR0ZWQgJiYgcGFyZW50LmlzQWN0aXZlKCkgJiYgKHJhd1RpbWUgPSBwYXJlbnQucmF3VGltZSh0cnVlKSkgPj0gc3RhcnQgJiYgcmF3VGltZSA8IHRoaXMuZW5kVGltZSh0cnVlKSAtIF90aW55TnVtKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmV2ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiBldmVudENhbGxiYWNrKHR5cGUsIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICAgIHZhciB2YXJzID0gdGhpcy52YXJzO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgIGRlbGV0ZSB2YXJzW3R5cGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhcnNbdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgICBwYXJhbXMgJiYgKHZhcnNbdHlwZSArIFwiUGFyYW1zXCJdID0gcGFyYW1zKTtcbiAgICAgICAgICB0eXBlID09PSBcIm9uVXBkYXRlXCIgJiYgKHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YXJzW3R5cGVdO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICB2YXIgZiA9IF9pc0Z1bmN0aW9uKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogX3Bhc3NUaHJvdWdoLFxuICAgICAgICAgICAgX3Jlc29sdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZSgpIHtcbiAgICAgICAgICB2YXIgX3RoZW4gPSBzZWxmLnRoZW47XG4gICAgICAgICAgc2VsZi50aGVuID0gbnVsbDtcbiAgICAgICAgICBfaXNGdW5jdGlvbihmKSAmJiAoZiA9IGYoc2VsZikpICYmIChmLnRoZW4gfHwgZiA9PT0gc2VsZikgJiYgKHNlbGYudGhlbiA9IF90aGVuKTtcbiAgICAgICAgICByZXNvbHZlKGYpO1xuICAgICAgICAgIHNlbGYudGhlbiA9IF90aGVuO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzZWxmLl9pbml0dGVkICYmIHNlbGYudG90YWxQcm9ncmVzcygpID09PSAxICYmIHNlbGYuX3RzID49IDAgfHwgIXNlbGYuX3RUaW1lICYmIHNlbGYuX3RzIDwgMCkge1xuICAgICAgICAgIF9yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5fcHJvbSA9IF9yZXNvbHZlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgX2ludGVycnVwdCh0aGlzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEFuaW1hdGlvbjtcbiAgfSgpO1xuXG4gIF9zZXREZWZhdWx0cyhBbmltYXRpb24ucHJvdG90eXBlLCB7XG4gICAgX3RpbWU6IDAsXG4gICAgX3N0YXJ0OiAwLFxuICAgIF9lbmQ6IDAsXG4gICAgX3RUaW1lOiAwLFxuICAgIF90RHVyOiAwLFxuICAgIF9kaXJ0eTogMCxcbiAgICBfcmVwZWF0OiAwLFxuICAgIF95b3lvOiBmYWxzZSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgX2luaXR0ZWQ6IGZhbHNlLFxuICAgIF9yRGVsYXk6IDAsXG4gICAgX3RzOiAxLFxuICAgIF9kcDogMCxcbiAgICByYXRpbzogMCxcbiAgICBfelRpbWU6IC1fdGlueU51bSxcbiAgICBfcHJvbTogMCxcbiAgICBfcHM6IGZhbHNlLFxuICAgIF9ydHM6IDFcbiAgfSk7XG5cbiAgdmFyIFRpbWVsaW5lID0gZnVuY3Rpb24gKF9BbmltYXRpb24pIHtcbiAgICBfaW5oZXJpdHNMb29zZShUaW1lbGluZSwgX0FuaW1hdGlvbik7XG5cbiAgICBmdW5jdGlvbiBUaW1lbGluZSh2YXJzLCBwb3NpdGlvbikge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhcnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMgPSBfQW5pbWF0aW9uLmNhbGwodGhpcywgdmFycykgfHwgdGhpcztcbiAgICAgIF90aGlzLmxhYmVscyA9IHt9O1xuICAgICAgX3RoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAhIXZhcnMuc21vb3RoQ2hpbGRUaW1pbmc7XG4gICAgICBfdGhpcy5hdXRvUmVtb3ZlQ2hpbGRyZW4gPSAhIXZhcnMuYXV0b1JlbW92ZUNoaWxkcmVuO1xuICAgICAgX3RoaXMuX3NvcnQgPSBfaXNOb3RGYWxzZSh2YXJzLnNvcnRDaGlsZHJlbik7XG4gICAgICBfZ2xvYmFsVGltZWxpbmUgJiYgX2FkZFRvVGltZWxpbmUodmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgcG9zaXRpb24pO1xuICAgICAgdmFycy5yZXZlcnNlZCAmJiBfdGhpcy5yZXZlcnNlKCk7XG4gICAgICB2YXJzLnBhdXNlZCAmJiBfdGhpcy5wYXVzZWQodHJ1ZSk7XG4gICAgICB2YXJzLnNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhcnMuc2Nyb2xsVHJpZ2dlcik7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzIgPSBUaW1lbGluZS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8yLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgIF9jcmVhdGVUd2VlblR5cGUoMCwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuZnJvbSA9IGZ1bmN0aW9uIGZyb20odGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG4gICAgICBfY3JlYXRlVHdlZW5UeXBlKDIsIGFyZ3VtZW50cywgdGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLnNldCA9IGZ1bmN0aW9uIHNldCh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgICAgdmFycy5kdXJhdGlvbiA9IDA7XG4gICAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLnJlcGVhdERlbGF5IHx8ICh2YXJzLnJlcGVhdCA9IDApO1xuICAgICAgdmFycy5pbW1lZGlhdGVSZW5kZXIgPSAhIXZhcnMuaW1tZWRpYXRlUmVuZGVyO1xuICAgICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5jYWxsID0gZnVuY3Rpb24gY2FsbChjYWxsYmFjaywgcGFyYW1zLCBwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIFR3ZWVuLmRlbGF5ZWRDYWxsKDAsIGNhbGxiYWNrLCBwYXJhbXMpLCBwb3NpdGlvbik7XG4gICAgfTtcblxuICAgIF9wcm90bzIuc3RhZ2dlclRvID0gZnVuY3Rpb24gc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgICAgdmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgdmFycy5zdGFnZ2VyID0gdmFycy5zdGFnZ2VyIHx8IHN0YWdnZXI7XG4gICAgICB2YXJzLm9uQ29tcGxldGUgPSBvbkNvbXBsZXRlQWxsO1xuICAgICAgdmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcbiAgICAgIHZhcnMucGFyZW50ID0gdGhpcztcbiAgICAgIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuc3RhZ2dlckZyb20gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbSh0YXJnZXRzLCBkdXJhdGlvbiwgdmFycywgc3RhZ2dlciwgcG9zaXRpb24sIG9uQ29tcGxldGVBbGwsIG9uQ29tcGxldGVBbGxQYXJhbXMpIHtcbiAgICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICAgIF9pbmhlcml0RGVmYXVsdHModmFycykuaW1tZWRpYXRlUmVuZGVyID0gX2lzTm90RmFsc2UodmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gICAgfTtcblxuICAgIF9wcm90bzIuc3RhZ2dlckZyb21UbyA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tVG8odGFyZ2V0cywgZHVyYXRpb24sIGZyb21WYXJzLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgICB0b1ZhcnMuc3RhcnRBdCA9IGZyb21WYXJzO1xuICAgICAgX2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhZ2dlclRvKHRhcmdldHMsIGR1cmF0aW9uLCB0b1ZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgICAgdER1ciA9IHRoaXMuX2RpcnR5ID8gdGhpcy50b3RhbER1cmF0aW9uKCkgOiB0aGlzLl90RHVyLFxuICAgICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgICB0VGltZSA9IHRvdGFsVGltZSA8PSAwID8gMCA6IF9yb3VuZFByZWNpc2UodG90YWxUaW1lKSxcbiAgICAgICAgICBjcm9zc2luZ1N0YXJ0ID0gdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwICYmICh0aGlzLl9pbml0dGVkIHx8ICFkdXIpLFxuICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgbmV4dCxcbiAgICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgICAgY3ljbGVEdXJhdGlvbixcbiAgICAgICAgICBwcmV2UGF1c2VkLFxuICAgICAgICAgIHBhdXNlVHdlZW4sXG4gICAgICAgICAgdGltZVNjYWxlLFxuICAgICAgICAgIHByZXZTdGFydCxcbiAgICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICAgIHlveW8sXG4gICAgICAgICAgaXNZb3lvO1xuICAgICAgdGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRUaW1lID4gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCAmJiAodFRpbWUgPSB0RHVyKTtcblxuICAgICAgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCBmb3JjZSB8fCBjcm9zc2luZ1N0YXJ0KSB7XG4gICAgICAgIGlmIChwcmV2VGltZSAhPT0gdGhpcy5fdGltZSAmJiBkdXIpIHtcbiAgICAgICAgICB0VGltZSArPSB0aGlzLl90aW1lIC0gcHJldlRpbWU7XG4gICAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgICAgcHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIHRpbWVTY2FsZSA9IHRoaXMuX3RzO1xuICAgICAgICBwcmV2UGF1c2VkID0gIXRpbWVTY2FsZTtcblxuICAgICAgICBpZiAoY3Jvc3NpbmdTdGFydCkge1xuICAgICAgICAgIGR1ciB8fCAocHJldlRpbWUgPSB0aGlzLl96VGltZSk7XG4gICAgICAgICAgKHRvdGFsVGltZSB8fCAhc3VwcHJlc3NFdmVudHMpICYmICh0aGlzLl96VGltZSA9IHRvdGFsVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgICAgeW95byA9IHRoaXMuX3lveW87XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblxuICAgICAgICAgIGlmICh0aGlzLl9yZXBlYXQgPCAtMSAmJiB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lID0gX3JvdW5kUHJlY2lzZSh0VGltZSAlIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmV2SXRlcmF0aW9uID0gX3JvdW5kUHJlY2lzZSh0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuICAgICAgICAgICAgaXRlcmF0aW9uID0gfn5wcmV2SXRlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgICBpdGVyYXRpb24tLTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG4gICAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiB0aGlzLl90VGltZSAtIHByZXZJdGVyYXRpb24gKiBjeWNsZUR1cmF0aW9uIC0gdGhpcy5fZHVyIDw9IDAgJiYgKHByZXZJdGVyYXRpb24gPSBpdGVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKHlveW8gJiYgaXRlcmF0aW9uICYgMSkge1xuICAgICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgICBpc1lveW8gPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICAgIHZhciByZXdpbmRpbmcgPSB5b3lvICYmIHByZXZJdGVyYXRpb24gJiAxLFxuICAgICAgICAgICAgICAgIGRvZXNXcmFwID0gcmV3aW5kaW5nID09PSAoeW95byAmJiBpdGVyYXRpb24gJiAxKTtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyAwIDogdFRpbWUgJSBkdXIgPyBkdXIgOiB0VGltZTtcbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAxO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIocHJldlRpbWUgfHwgKGlzWW95byA/IDAgOiBfcm91bmRQcmVjaXNlKGl0ZXJhdGlvbiAqIGN5Y2xlRHVyYXRpb24pKSwgc3VwcHJlc3NFdmVudHMsICFkdXIpLl9sb2NrID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICAgICAgICAhc3VwcHJlc3NFdmVudHMgJiYgdGhpcy5wYXJlbnQgJiYgX2NhbGxiYWNrKHRoaXMsIFwib25SZXBlYXRcIik7XG4gICAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmICh0aGlzLmludmFsaWRhdGUoKS5fbG9jayA9IDEpO1xuXG4gICAgICAgICAgICBpZiAocHJldlRpbWUgJiYgcHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzIHx8IHRoaXMudmFycy5vblJlcGVhdCAmJiAhdGhpcy5wYXJlbnQgJiYgIXRoaXMuX2FjdCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHVyID0gdGhpcy5fZHVyO1xuICAgICAgICAgICAgdER1ciA9IHRoaXMuX3REdXI7XG5cbiAgICAgICAgICAgIGlmIChkb2VzV3JhcCkge1xuICAgICAgICAgICAgICB0aGlzLl9sb2NrID0gMjtcbiAgICAgICAgICAgICAgcHJldlRpbWUgPSByZXdpbmRpbmcgPyBkdXIgOiAtMC4wMDAxO1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfcHJvcGFnYXRlWW95b0Vhc2UodGhpcywgaXNZb3lvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFzUGF1c2UgJiYgIXRoaXMuX2ZvcmNpbmcgJiYgdGhpcy5fbG9jayA8IDIpIHtcbiAgICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmRQcmVjaXNlKHByZXZUaW1lKSwgX3JvdW5kUHJlY2lzZSh0aW1lKSk7XG5cbiAgICAgICAgICBpZiAocGF1c2VUd2Vlbikge1xuICAgICAgICAgICAgdFRpbWUgLT0gdGltZSAtICh0aW1lID0gcGF1c2VUd2Vlbi5fc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgICAgICB0aGlzLl9hY3QgPSAhdGltZVNjYWxlO1xuXG4gICAgICAgIGlmICghdGhpcy5faW5pdHRlZCkge1xuICAgICAgICAgIHRoaXMuX29uVXBkYXRlID0gdGhpcy52YXJzLm9uVXBkYXRlO1xuICAgICAgICAgIHRoaXMuX2luaXR0ZWQgPSAxO1xuICAgICAgICAgIHRoaXMuX3pUaW1lID0gdG90YWxUaW1lO1xuICAgICAgICAgIHByZXZUaW1lID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJldlRpbWUgJiYgdFRpbWUgJiYgIXN1cHByZXNzRXZlbnRzICYmICFwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aW1lID49IHByZXZUaW1lICYmIHRvdGFsVGltZSA+PSAwKSB7XG4gICAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdDtcblxuICAgICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gICAgICAgICAgICBpZiAoKGNoaWxkLl9hY3QgfHwgdGltZSA+PSBjaGlsZC5fc3RhcnQpICYmIGNoaWxkLl90cyAmJiBwYXVzZVR3ZWVuICE9PSBjaGlsZCkge1xuICAgICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNoaWxkLnJlbmRlcihjaGlsZC5fdHMgPiAwID8gKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzIDogKGNoaWxkLl9kaXJ0eSA/IGNoaWxkLnRvdGFsRHVyYXRpb24oKSA6IGNoaWxkLl90RHVyKSArICh0aW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgICBuZXh0ICYmICh0VGltZSArPSB0aGlzLl96VGltZSA9IC1fdGlueU51bSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGlsZCA9IHRoaXMuX2xhc3Q7XG4gICAgICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lO1xuXG4gICAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgICBuZXh0ID0gY2hpbGQuX3ByZXY7XG5cbiAgICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlIHx8IF9yZXZlcnRpbmcgJiYgX2lzUmV2ZXJ0V29ydGh5KGNoaWxkKSk7XG5cbiAgICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSBhZGp1c3RlZFRpbWUgPyAtX3RpbnlOdW0gOiBfdGlueU51bSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXVzZVR3ZWVuICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICAgIGlmICh0aGlzLl90cykge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBwcmV2U3RhcnQ7XG5cbiAgICAgICAgICAgIF9zZXRFbmQodGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIgJiYgdGhpcy5fdFRpbWUgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkgfHwgIXRUaW1lICYmIHByZXZUaW1lKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydCB8fCBNYXRoLmFicyh0aW1lU2NhbGUpICE9PSBNYXRoLmFicyh0aGlzLl90cykpIGlmICghdGhpcy5fbG9jaykge1xuICAgICAgICAgICh0b3RhbFRpbWUgfHwgIWR1cikgJiYgKHRUaW1lID09PSB0RHVyICYmIHRoaXMuX3RzID4gMCB8fCAhdFRpbWUgJiYgdGhpcy5fdHMgPCAwKSAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0aGlzLCAxKTtcblxuICAgICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8ICF0RHVyKSkge1xuICAgICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIHRUaW1lID09PSB0RHVyICYmIHRvdGFsVGltZSA+PSAwID8gXCJvbkNvbXBsZXRlXCIgOiBcIm9uUmV2ZXJzZUNvbXBsZXRlXCIsIHRydWUpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9tICYmICEodFRpbWUgPCB0RHVyICYmIHRoaXMudGltZVNjYWxlKCkgPiAwKSAmJiB0aGlzLl9wcm9tKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmFkZCA9IGZ1bmN0aW9uIGFkZChjaGlsZCwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBfaXNOdW1iZXIocG9zaXRpb24pIHx8IChwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uLCBjaGlsZCkpO1xuXG4gICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEFuaW1hdGlvbikpIHtcbiAgICAgICAgaWYgKF9pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgIGNoaWxkLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5hZGQob2JqLCBwb3NpdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFkZExhYmVsKGNoaWxkLCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgICAgY2hpbGQgPSBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjaGlsZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuZ2V0Q2hpbGRyZW4gPSBmdW5jdGlvbiBnZXRDaGlsZHJlbihuZXN0ZWQsIHR3ZWVucywgdGltZWxpbmVzLCBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICBpZiAobmVzdGVkID09PSB2b2lkIDApIHtcbiAgICAgICAgbmVzdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR3ZWVucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHR3ZWVucyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lbGluZXMgPT09IHZvaWQgMCkge1xuICAgICAgICB0aW1lbGluZXMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWdub3JlQmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcbiAgICAgIH1cblxuICAgICAgdmFyIGEgPSBbXSxcbiAgICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgICAgIHR3ZWVucyAmJiBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIG5lc3RlZCAmJiBhLnB1c2guYXBwbHkoYSwgY2hpbGQuZ2V0Q2hpbGRyZW4odHJ1ZSwgdHdlZW5zLCB0aW1lbGluZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5nZXRCeUlkID0gZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmdldENoaWxkcmVuKDEsIDEsIDEpLFxuICAgICAgICAgIGkgPSBhbmltYXRpb25zLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuICAgICAgICAgIHJldHVybiBhbmltYXRpb25zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKGNoaWxkKSB7XG4gICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVMYWJlbChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2lsbFR3ZWVuc09mKGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQucGFyZW50ID09PSB0aGlzICYmIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCA9PT0gdGhpcy5fcmVjZW50KSB7XG4gICAgICAgIHRoaXMuX3JlY2VudCA9IHRoaXMuX2xhc3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi50b3RhbFRpbWUgPSBmdW5jdGlvbiB0b3RhbFRpbWUoX3RvdGFsVGltZTIsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RUaW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mb3JjaW5nID0gMTtcblxuICAgICAgaWYgKCF0aGlzLl9kcCAmJiB0aGlzLl90cykge1xuICAgICAgICB0aGlzLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoX3RpY2tlci50aW1lIC0gKHRoaXMuX3RzID4gMCA/IF90b3RhbFRpbWUyIC8gdGhpcy5fdHMgOiAodGhpcy50b3RhbER1cmF0aW9uKCkgLSBfdG90YWxUaW1lMikgLyAtdGhpcy5fdHMpKTtcbiAgICAgIH1cblxuICAgICAgX0FuaW1hdGlvbi5wcm90b3R5cGUudG90YWxUaW1lLmNhbGwodGhpcywgX3RvdGFsVGltZTIsIHN1cHByZXNzRXZlbnRzKTtcblxuICAgICAgdGhpcy5fZm9yY2luZyA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5hZGRMYWJlbCA9IGZ1bmN0aW9uIGFkZExhYmVsKGxhYmVsLCBwb3NpdGlvbikge1xuICAgICAgdGhpcy5sYWJlbHNbbGFiZWxdID0gX3BhcnNlUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChsYWJlbCkge1xuICAgICAgZGVsZXRlIHRoaXMubGFiZWxzW2xhYmVsXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmFkZFBhdXNlID0gZnVuY3Rpb24gYWRkUGF1c2UocG9zaXRpb24sIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICAgIHZhciB0ID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2sgfHwgX2VtcHR5RnVuYywgcGFyYW1zKTtcbiAgICAgIHQuZGF0YSA9IFwiaXNQYXVzZVwiO1xuICAgICAgdGhpcy5faGFzUGF1c2UgPSAxO1xuICAgICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIHQsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVtb3ZlUGF1c2UgPSBmdW5jdGlvbiByZW1vdmVQYXVzZShwb3NpdGlvbikge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgICBwb3NpdGlvbiA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZC5fc3RhcnQgPT09IHBvc2l0aW9uICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG4gICAgICAgICAgX3JlbW92ZUZyb21QYXJlbnQoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvMi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICAgIHZhciB0d2VlbnMgPSB0aGlzLmdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpLFxuICAgICAgICAgIGkgPSB0d2VlbnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuICE9PSB0d2VlbnNbaV0gJiYgdHdlZW5zW2ldLmtpbGwodGFyZ2V0cywgcHJvcHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5nZXRUd2VlbnNPZiA9IGZ1bmN0aW9uIGdldFR3ZWVuc09mKHRhcmdldHMsIG9ubHlBY3RpdmUpIHtcbiAgICAgIHZhciBhID0gW10sXG4gICAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgICAgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgICBpc0dsb2JhbFRpbWUgPSBfaXNOdW1iZXIob25seUFjdGl2ZSksXG4gICAgICAgICAgY2hpbGRyZW47XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUd2Vlbikge1xuICAgICAgICAgIGlmIChfYXJyYXlDb250YWluc0FueShjaGlsZC5fdGFyZ2V0cywgcGFyc2VkVGFyZ2V0cykgJiYgKGlzR2xvYmFsVGltZSA/ICghX292ZXJ3cml0aW5nVHdlZW4gfHwgY2hpbGQuX2luaXR0ZWQgJiYgY2hpbGQuX3RzKSAmJiBjaGlsZC5nbG9iYWxUaW1lKDApIDw9IG9ubHlBY3RpdmUgJiYgY2hpbGQuZ2xvYmFsVGltZShjaGlsZC50b3RhbER1cmF0aW9uKCkpID4gb25seUFjdGl2ZSA6ICFvbmx5QWN0aXZlIHx8IGNoaWxkLmlzQWN0aXZlKCkpKSB7XG4gICAgICAgICAgICBhLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgoY2hpbGRyZW4gPSBjaGlsZC5nZXRUd2VlbnNPZihwYXJzZWRUYXJnZXRzLCBvbmx5QWN0aXZlKSkubGVuZ3RoKSB7XG4gICAgICAgICAgYS5wdXNoLmFwcGx5KGEsIGNoaWxkcmVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLnR3ZWVuVG8gPSBmdW5jdGlvbiB0d2VlblRvKHBvc2l0aW9uLCB2YXJzKSB7XG4gICAgICB2YXJzID0gdmFycyB8fCB7fTtcblxuICAgICAgdmFyIHRsID0gdGhpcyxcbiAgICAgICAgICBlbmRUaW1lID0gX3BhcnNlUG9zaXRpb24odGwsIHBvc2l0aW9uKSxcbiAgICAgICAgICBfdmFycyA9IHZhcnMsXG4gICAgICAgICAgc3RhcnRBdCA9IF92YXJzLnN0YXJ0QXQsXG4gICAgICAgICAgX29uU3RhcnQgPSBfdmFycy5vblN0YXJ0LFxuICAgICAgICAgIG9uU3RhcnRQYXJhbXMgPSBfdmFycy5vblN0YXJ0UGFyYW1zLFxuICAgICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF92YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgICBpbml0dGVkLFxuICAgICAgICAgIHR3ZWVuID0gVHdlZW4udG8odGwsIF9zZXREZWZhdWx0cyh7XG4gICAgICAgIGVhc2U6IHZhcnMuZWFzZSB8fCBcIm5vbmVcIixcbiAgICAgICAgbGF6eTogZmFsc2UsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogZmFsc2UsXG4gICAgICAgIHRpbWU6IGVuZFRpbWUsXG4gICAgICAgIG92ZXJ3cml0ZTogXCJhdXRvXCIsXG4gICAgICAgIGR1cmF0aW9uOiB2YXJzLmR1cmF0aW9uIHx8IE1hdGguYWJzKChlbmRUaW1lIC0gKHN0YXJ0QXQgJiYgXCJ0aW1lXCIgaW4gc3RhcnRBdCA/IHN0YXJ0QXQudGltZSA6IHRsLl90aW1lKSkgLyB0bC50aW1lU2NhbGUoKSkgfHwgX3RpbnlOdW0sXG4gICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgICAgdGwucGF1c2UoKTtcblxuICAgICAgICAgIGlmICghaW5pdHRlZCkge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uID0gdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpO1xuICAgICAgICAgICAgdHdlZW4uX2R1ciAhPT0gZHVyYXRpb24gJiYgX3NldER1cmF0aW9uKHR3ZWVuLCBkdXJhdGlvbiwgMCwgMSkucmVuZGVyKHR3ZWVuLl90aW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGluaXR0ZWQgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9vblN0YXJ0ICYmIF9vblN0YXJ0LmFwcGx5KHR3ZWVuLCBvblN0YXJ0UGFyYW1zIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgfSwgdmFycykpO1xuXG4gICAgICByZXR1cm4gaW1tZWRpYXRlUmVuZGVyID8gdHdlZW4ucmVuZGVyKDApIDogdHdlZW47XG4gICAgfTtcblxuICAgIF9wcm90bzIudHdlZW5Gcm9tVG8gPSBmdW5jdGlvbiB0d2VlbkZyb21Ubyhmcm9tUG9zaXRpb24sIHRvUG9zaXRpb24sIHZhcnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnR3ZWVuVG8odG9Qb3NpdGlvbiwgX3NldERlZmF1bHRzKHtcbiAgICAgICAgc3RhcnRBdDoge1xuICAgICAgICAgIHRpbWU6IF9wYXJzZVBvc2l0aW9uKHRoaXMsIGZyb21Qb3NpdGlvbilcbiAgICAgICAgfVxuICAgICAgfSwgdmFycykpO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLnJlY2VudCA9IGZ1bmN0aW9uIHJlY2VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWNlbnQ7XG4gICAgfTtcblxuICAgIF9wcm90bzIubmV4dExhYmVsID0gZnVuY3Rpb24gbmV4dExhYmVsKGFmdGVyVGltZSkge1xuICAgICAgaWYgKGFmdGVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGFmdGVyVGltZSA9IHRoaXMuX3RpbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBhZnRlclRpbWUpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5wcmV2aW91c0xhYmVsID0gZnVuY3Rpb24gcHJldmlvdXNMYWJlbChiZWZvcmVUaW1lKSB7XG4gICAgICBpZiAoYmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGJlZm9yZVRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xuICAgIH07XG5cbiAgICBfcHJvdG8yLmN1cnJlbnRMYWJlbCA9IGZ1bmN0aW9uIGN1cnJlbnRMYWJlbCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNlZWsodmFsdWUsIHRydWUpIDogdGhpcy5wcmV2aW91c0xhYmVsKHRoaXMuX3RpbWUgKyBfdGlueU51bSk7XG4gICAgfTtcblxuICAgIF9wcm90bzIuc2hpZnRDaGlsZHJlbiA9IGZ1bmN0aW9uIHNoaWZ0Q2hpbGRyZW4oYW1vdW50LCBhZGp1c3RMYWJlbHMsIGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgICAgaWdub3JlQmVmb3JlVGltZSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICAgIGxhYmVscyA9IHRoaXMubGFiZWxzLFxuICAgICAgICAgIHA7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgICBjaGlsZC5fc3RhcnQgKz0gYW1vdW50O1xuICAgICAgICAgIGNoaWxkLl9lbmQgKz0gYW1vdW50O1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkanVzdExhYmVscykge1xuICAgICAgICBmb3IgKHAgaW4gbGFiZWxzKSB7XG4gICAgICAgICAgaWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgICAgICBsYWJlbHNbcF0gKz0gYW1vdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3VuY2FjaGUodGhpcyk7XG4gICAgfTtcblxuICAgIF9wcm90bzIuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIGludmFsaWRhdGUoc29mdCkge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgICB0aGlzLl9sb2NrID0gMDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLmludmFsaWRhdGUoc29mdCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcywgc29mdCk7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcihpbmNsdWRlTGFiZWxzKSB7XG4gICAgICBpZiAoaW5jbHVkZUxhYmVscyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluY2x1ZGVMYWJlbHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgICBuZXh0O1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuICAgICAgICB0aGlzLnJlbW92ZShjaGlsZCk7XG4gICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZHAgJiYgKHRoaXMuX3RpbWUgPSB0aGlzLl90VGltZSA9IHRoaXMuX3BUaW1lID0gMCk7XG4gICAgICBpbmNsdWRlTGFiZWxzICYmICh0aGlzLmxhYmVscyA9IHt9KTtcbiAgICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIG1heCA9IDAsXG4gICAgICAgICAgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgY2hpbGQgPSBzZWxmLl9sYXN0LFxuICAgICAgICAgIHByZXZTdGFydCA9IF9iaWdOdW0sXG4gICAgICAgICAgcHJldixcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRpbWVTY2FsZSgoc2VsZi5fcmVwZWF0IDwgMCA/IHNlbGYuZHVyYXRpb24oKSA6IHNlbGYudG90YWxEdXJhdGlvbigpKSAvIChzZWxmLnJldmVyc2VkKCkgPyAtdmFsdWUgOiB2YWx1ZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5fZGlydHkpIHtcbiAgICAgICAgcGFyZW50ID0gc2VsZi5wYXJlbnQ7XG5cbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgcHJldiA9IGNoaWxkLl9wcmV2O1xuICAgICAgICAgIGNoaWxkLl9kaXJ0eSAmJiBjaGlsZC50b3RhbER1cmF0aW9uKCk7XG4gICAgICAgICAgc3RhcnQgPSBjaGlsZC5fc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoc3RhcnQgPiBwcmV2U3RhcnQgJiYgc2VsZi5fc29ydCAmJiBjaGlsZC5fdHMgJiYgIXNlbGYuX2xvY2spIHtcbiAgICAgICAgICAgIHNlbGYuX2xvY2sgPSAxO1xuICAgICAgICAgICAgX2FkZFRvVGltZWxpbmUoc2VsZiwgY2hpbGQsIHN0YXJ0IC0gY2hpbGQuX2RlbGF5LCAxKS5fbG9jayA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGFydCA8IDAgJiYgY2hpbGQuX3RzKSB7XG4gICAgICAgICAgICBtYXggLT0gc3RhcnQ7XG5cbiAgICAgICAgICAgIGlmICghcGFyZW50ICYmICFzZWxmLl9kcCB8fCBwYXJlbnQgJiYgcGFyZW50LnNtb290aENoaWxkVGltaW5nKSB7XG4gICAgICAgICAgICAgIHNlbGYuX3N0YXJ0ICs9IHN0YXJ0IC8gc2VsZi5fdHM7XG4gICAgICAgICAgICAgIHNlbGYuX3RpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgICAgIHNlbGYuX3RUaW1lIC09IHN0YXJ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxmLnNoaWZ0Q2hpbGRyZW4oLXN0YXJ0LCBmYWxzZSwgLTFlOTk5KTtcbiAgICAgICAgICAgIHByZXZTdGFydCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2hpbGQuX2VuZCA+IG1heCAmJiBjaGlsZC5fdHMgJiYgKG1heCA9IGNoaWxkLl9lbmQpO1xuICAgICAgICAgIGNoaWxkID0gcHJldjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXREdXJhdGlvbihzZWxmLCBzZWxmID09PSBfZ2xvYmFsVGltZWxpbmUgJiYgc2VsZi5fdGltZSA+IG1heCA/IHNlbGYuX3RpbWUgOiBtYXgsIDEsIDEpO1xuXG4gICAgICAgIHNlbGYuX2RpcnR5ID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGYuX3REdXI7XG4gICAgfTtcblxuICAgIFRpbWVsaW5lLnVwZGF0ZVJvb3QgPSBmdW5jdGlvbiB1cGRhdGVSb290KHRpbWUpIHtcbiAgICAgIGlmIChfZ2xvYmFsVGltZWxpbmUuX3RzKSB7XG4gICAgICAgIF9sYXp5U2FmZVJlbmRlcihfZ2xvYmFsVGltZWxpbmUsIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWUsIF9nbG9iYWxUaW1lbGluZSkpO1xuXG4gICAgICAgIF9sYXN0UmVuZGVyZWRGcmFtZSA9IF90aWNrZXIuZnJhbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfdGlja2VyLmZyYW1lID49IF9uZXh0R0NGcmFtZSkge1xuICAgICAgICBfbmV4dEdDRnJhbWUgKz0gX2NvbmZpZy5hdXRvU2xlZXAgfHwgMTIwO1xuICAgICAgICB2YXIgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuICAgICAgICBpZiAoIWNoaWxkIHx8ICFjaGlsZC5fdHMpIGlmIChfY29uZmlnLmF1dG9TbGVlcCAmJiBfdGlja2VyLl9saXN0ZW5lcnMubGVuZ3RoIDwgMikge1xuICAgICAgICAgIHdoaWxlIChjaGlsZCAmJiAhY2hpbGQuX3RzKSB7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkIHx8IF90aWNrZXIuc2xlZXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gVGltZWxpbmU7XG4gIH0oQW5pbWF0aW9uKTtcblxuICBfc2V0RGVmYXVsdHMoVGltZWxpbmUucHJvdG90eXBlLCB7XG4gICAgX2xvY2s6IDAsXG4gICAgX2hhc1BhdXNlOiAwLFxuICAgIF9mb3JjaW5nOiAwXG4gIH0pO1xuXG4gIHZhciBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgc2V0dGVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSkge1xuICAgIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIG51bGwsIHNldHRlciksXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc3RhcnROdW1zLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBjaHVuayxcbiAgICAgICAgc3RhcnROdW0sXG4gICAgICAgIGhhc1JhbmRvbSxcbiAgICAgICAgYTtcbiAgICBwdC5iID0gc3RhcnQ7XG4gICAgcHQuZSA9IGVuZDtcbiAgICBzdGFydCArPSBcIlwiO1xuICAgIGVuZCArPSBcIlwiO1xuXG4gICAgaWYgKGhhc1JhbmRvbSA9IH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cmluZ0ZpbHRlcikge1xuICAgICAgYSA9IFtzdGFydCwgZW5kXTtcbiAgICAgIHN0cmluZ0ZpbHRlcihhLCB0YXJnZXQsIHByb3ApO1xuICAgICAgc3RhcnQgPSBhWzBdO1xuICAgICAgZW5kID0gYVsxXTtcbiAgICB9XG5cbiAgICBzdGFydE51bXMgPSBzdGFydC5tYXRjaChfY29tcGxleFN0cmluZ051bUV4cCkgfHwgW107XG5cbiAgICB3aGlsZSAocmVzdWx0ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmROdW0gPSByZXN1bHRbMF07XG4gICAgICBjaHVuayA9IGVuZC5zdWJzdHJpbmcoaW5kZXgsIHJlc3VsdC5pbmRleCk7XG5cbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBjb2xvciA9IChjb2xvciArIDEpICUgNTtcbiAgICAgIH0gZWxzZSBpZiAoY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJyZ2JhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZE51bSAhPT0gc3RhcnROdW1zW21hdGNoSW5kZXgrK10pIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0TnVtc1ttYXRjaEluZGV4IC0gMV0pIHx8IDA7XG4gICAgICAgIHB0Ll9wdCA9IHtcbiAgICAgICAgICBfbmV4dDogcHQuX3B0LFxuICAgICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAgIHM6IHN0YXJ0TnVtLFxuICAgICAgICAgIGM6IGVuZE51bS5jaGFyQXQoMSkgPT09IFwiPVwiID8gX3BhcnNlUmVsYXRpdmUoc3RhcnROdW0sIGVuZE51bSkgLSBzdGFydE51bSA6IHBhcnNlRmxvYXQoZW5kTnVtKSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCA/IE1hdGgucm91bmQgOiAwXG4gICAgICAgIH07XG4gICAgICAgIGluZGV4ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAubGFzdEluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7XG4gICAgcHQuZnAgPSBmdW5jUGFyYW07XG5cbiAgICBpZiAoX3JlbEV4cC50ZXN0KGVuZCkgfHwgaGFzUmFuZG9tKSB7XG4gICAgICBwdC5lID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLl9wdCA9IHB0O1xuICAgIHJldHVybiBwdDtcbiAgfSxcbiAgICAgIF9hZGRQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUHJvcFR3ZWVuKHRhcmdldCwgcHJvcCwgc3RhcnQsIGVuZCwgaW5kZXgsIHRhcmdldHMsIG1vZGlmaWVyLCBzdHJpbmdGaWx0ZXIsIGZ1bmNQYXJhbSwgb3B0aW9uYWwpIHtcbiAgICBfaXNGdW5jdGlvbihlbmQpICYmIChlbmQgPSBlbmQoaW5kZXggfHwgMCwgdGFyZ2V0LCB0YXJnZXRzKSk7XG4gICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXSxcbiAgICAgICAgcGFyc2VkU3RhcnQgPSBzdGFydCAhPT0gXCJnZXRcIiA/IHN0YXJ0IDogIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBjdXJyZW50VmFsdWUgOiBmdW5jUGFyYW0gPyB0YXJnZXRbcHJvcC5pbmRleE9mKFwic2V0XCIpIHx8ICFfaXNGdW5jdGlvbih0YXJnZXRbXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXSkgPyBwcm9wIDogXCJnZXRcIiArIHByb3Auc3Vic3RyKDMpXShmdW5jUGFyYW0pIDogdGFyZ2V0W3Byb3BdKCksXG4gICAgICAgIHNldHRlciA9ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gX3NldHRlclBsYWluIDogZnVuY1BhcmFtID8gX3NldHRlckZ1bmNXaXRoUGFyYW0gOiBfc2V0dGVyRnVuYyxcbiAgICAgICAgcHQ7XG5cbiAgICBpZiAoX2lzU3RyaW5nKGVuZCkpIHtcbiAgICAgIGlmICh+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQuY2hhckF0KDEpID09PSBcIj1cIikge1xuICAgICAgICBwdCA9IF9wYXJzZVJlbGF0aXZlKHBhcnNlZFN0YXJ0LCBlbmQpICsgKGdldFVuaXQocGFyc2VkU3RhcnQpIHx8IDApO1xuXG4gICAgICAgIGlmIChwdCB8fCBwdCA9PT0gMCkge1xuICAgICAgICAgIGVuZCA9IHB0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25hbCB8fCBwYXJzZWRTdGFydCAhPT0gZW5kIHx8IF9mb3JjZUFsbFByb3BUd2VlbnMpIHtcbiAgICAgIGlmICghaXNOYU4ocGFyc2VkU3RhcnQgKiBlbmQpICYmIGVuZCAhPT0gXCJcIikge1xuICAgICAgICBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldCwgcHJvcCwgK3BhcnNlZFN0YXJ0IHx8IDAsIGVuZCAtIChwYXJzZWRTdGFydCB8fCAwKSwgdHlwZW9mIGN1cnJlbnRWYWx1ZSA9PT0gXCJib29sZWFuXCIgPyBfcmVuZGVyQm9vbGVhbiA6IF9yZW5kZXJQbGFpbiwgMCwgc2V0dGVyKTtcbiAgICAgICAgZnVuY1BhcmFtICYmIChwdC5mcCA9IGZ1bmNQYXJhbSk7XG4gICAgICAgIG1vZGlmaWVyICYmIHB0Lm1vZGlmaWVyKG1vZGlmaWVyLCB0aGlzLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHQgPSBwdDtcbiAgICAgIH1cblxuICAgICAgIWN1cnJlbnRWYWx1ZSAmJiAhKHByb3AgaW4gdGFyZ2V0KSAmJiBfbWlzc2luZ1BsdWdpbihwcm9wLCBlbmQpO1xuICAgICAgcmV0dXJuIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodGhpcywgdGFyZ2V0LCBwcm9wLCBwYXJzZWRTdGFydCwgZW5kLCBzZXR0ZXIsIHN0cmluZ0ZpbHRlciB8fCBfY29uZmlnLnN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKTtcbiAgICB9XG4gIH0sXG4gICAgICBfcHJvY2Vzc1ZhcnMgPSBmdW5jdGlvbiBfcHJvY2Vzc1ZhcnModmFycywgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pIHtcbiAgICBfaXNGdW5jdGlvbih2YXJzKSAmJiAodmFycyA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpO1xuXG4gICAgaWYgKCFfaXNPYmplY3QodmFycykgfHwgdmFycy5zdHlsZSAmJiB2YXJzLm5vZGVUeXBlIHx8IF9pc0FycmF5KHZhcnMpIHx8IF9pc1R5cGVkQXJyYXkodmFycykpIHtcbiAgICAgIHJldHVybiBfaXNTdHJpbmcodmFycykgPyBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFycztcbiAgICB9XG5cbiAgICB2YXIgY29weSA9IHt9LFxuICAgICAgICBwO1xuXG4gICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgIGNvcHlbcF0gPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFyc1twXSwgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3B5O1xuICB9LFxuICAgICAgX2NoZWNrUGx1Z2luID0gZnVuY3Rpb24gX2NoZWNrUGx1Z2luKHByb3BlcnR5LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykge1xuICAgIHZhciBwbHVnaW4sIHB0LCBwdExvb2t1cCwgaTtcblxuICAgIGlmIChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgKHBsdWdpbiA9IG5ldyBfcGx1Z2luc1twcm9wZXJ0eV0oKSkuaW5pdCh0YXJnZXQsIHBsdWdpbi5yYXdWYXJzID8gdmFyc1twcm9wZXJ0eV0gOiBfcHJvY2Vzc1ZhcnModmFyc1twcm9wZXJ0eV0sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMsIHR3ZWVuKSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSAhPT0gZmFsc2UpIHtcbiAgICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgICAgaWYgKHR3ZWVuICE9PSBfcXVpY2tUd2Vlbikge1xuICAgICAgICBwdExvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cFt0d2Vlbi5fdGFyZ2V0cy5pbmRleE9mKHRhcmdldCldO1xuICAgICAgICBpID0gcGx1Z2luLl9wcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHB0TG9va3VwW3BsdWdpbi5fcHJvcHNbaV1dID0gcHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGx1Z2luO1xuICB9LFxuICAgICAgX292ZXJ3cml0aW5nVHdlZW4sXG4gICAgICBfZm9yY2VBbGxQcm9wVHdlZW5zLFxuICAgICAgX2luaXRUd2VlbiA9IGZ1bmN0aW9uIF9pbml0VHdlZW4odHdlZW4sIHRpbWUsIHRUaW1lKSB7XG4gICAgdmFyIHZhcnMgPSB0d2Vlbi52YXJzLFxuICAgICAgICBlYXNlID0gdmFycy5lYXNlLFxuICAgICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXIgPSB2YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgbGF6eSA9IHZhcnMubGF6eSxcbiAgICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgICBydW5CYWNrd2FyZHMgPSB2YXJzLnJ1bkJhY2t3YXJkcyxcbiAgICAgICAgeW95b0Vhc2UgPSB2YXJzLnlveW9FYXNlLFxuICAgICAgICBrZXlmcmFtZXMgPSB2YXJzLmtleWZyYW1lcyxcbiAgICAgICAgYXV0b1JldmVydCA9IHZhcnMuYXV0b1JldmVydCxcbiAgICAgICAgZHVyID0gdHdlZW4uX2R1cixcbiAgICAgICAgcHJldlN0YXJ0QXQgPSB0d2Vlbi5fc3RhcnRBdCxcbiAgICAgICAgdGFyZ2V0cyA9IHR3ZWVuLl90YXJnZXRzLFxuICAgICAgICBwYXJlbnQgPSB0d2Vlbi5wYXJlbnQsXG4gICAgICAgIGZ1bGxUYXJnZXRzID0gcGFyZW50ICYmIHBhcmVudC5kYXRhID09PSBcIm5lc3RlZFwiID8gcGFyZW50LnZhcnMudGFyZ2V0cyA6IHRhcmdldHMsXG4gICAgICAgIGF1dG9PdmVyd3JpdGUgPSB0d2Vlbi5fb3ZlcndyaXRlID09PSBcImF1dG9cIiAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICAgICAgdGwgPSB0d2Vlbi50aW1lbGluZSxcbiAgICAgICAgY2xlYW5WYXJzLFxuICAgICAgICBpLFxuICAgICAgICBwLFxuICAgICAgICBwdCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBoYXNQcmlvcml0eSxcbiAgICAgICAgZ3NEYXRhLFxuICAgICAgICBoYXJuZXNzLFxuICAgICAgICBwbHVnaW4sXG4gICAgICAgIHB0TG9va3VwLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgaGFybmVzc1ZhcnMsXG4gICAgICAgIG92ZXJ3cml0dGVuO1xuICAgIHRsICYmICgha2V5ZnJhbWVzIHx8ICFlYXNlKSAmJiAoZWFzZSA9IFwibm9uZVwiKTtcbiAgICB0d2Vlbi5fZWFzZSA9IF9wYXJzZUVhc2UoZWFzZSwgX2RlZmF1bHRzLmVhc2UpO1xuICAgIHR3ZWVuLl95RWFzZSA9IHlveW9FYXNlID8gX2ludmVydEVhc2UoX3BhcnNlRWFzZSh5b3lvRWFzZSA9PT0gdHJ1ZSA/IGVhc2UgOiB5b3lvRWFzZSwgX2RlZmF1bHRzLmVhc2UpKSA6IDA7XG5cbiAgICBpZiAoeW95b0Vhc2UgJiYgdHdlZW4uX3lveW8gJiYgIXR3ZWVuLl9yZXBlYXQpIHtcbiAgICAgIHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xuICAgICAgdHdlZW4uX3lFYXNlID0gdHdlZW4uX2Vhc2U7XG4gICAgICB0d2Vlbi5fZWFzZSA9IHlveW9FYXNlO1xuICAgIH1cblxuICAgIHR3ZWVuLl9mcm9tID0gIXRsICYmICEhdmFycy5ydW5CYWNrd2FyZHM7XG5cbiAgICBpZiAoIXRsIHx8IGtleWZyYW1lcyAmJiAhdmFycy5zdGFnZ2VyKSB7XG4gICAgICBoYXJuZXNzID0gdGFyZ2V0c1swXSA/IF9nZXRDYWNoZSh0YXJnZXRzWzBdKS5oYXJuZXNzIDogMDtcbiAgICAgIGhhcm5lc3NWYXJzID0gaGFybmVzcyAmJiB2YXJzW2hhcm5lc3MucHJvcF07XG4gICAgICBjbGVhblZhcnMgPSBfY29weUV4Y2x1ZGluZyh2YXJzLCBfcmVzZXJ2ZWRQcm9wcyk7XG5cbiAgICAgIGlmIChwcmV2U3RhcnRBdCkge1xuICAgICAgICBwcmV2U3RhcnRBdC5felRpbWUgPCAwICYmIHByZXZTdGFydEF0LnByb2dyZXNzKDEpO1xuICAgICAgICB0aW1lIDwgMCAmJiBydW5CYWNrd2FyZHMgJiYgaW1tZWRpYXRlUmVuZGVyICYmICFhdXRvUmV2ZXJ0ID8gcHJldlN0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSA6IHByZXZTdGFydEF0LnJldmVydChydW5CYWNrd2FyZHMgJiYgZHVyID8gX3JldmVydENvbmZpZ05vS2lsbCA6IF9zdGFydEF0UmV2ZXJ0Q29uZmlnKTtcbiAgICAgICAgcHJldlN0YXJ0QXQuX2xhenkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRBdCkge1xuICAgICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgICAgIGRhdGE6IFwiaXNTdGFydFwiLFxuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgaW1tZWRpYXRlUmVuZGVyOiB0cnVlLFxuICAgICAgICAgIGxhenk6ICFwcmV2U3RhcnRBdCAmJiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgICBzdGFydEF0OiBudWxsLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIG9uVXBkYXRlOiBvblVwZGF0ZSAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2NhbGxiYWNrKHR3ZWVuLCBcIm9uVXBkYXRlXCIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhZ2dlcjogMFxuICAgICAgICB9LCBzdGFydEF0KSkpO1xuXG4gICAgICAgIHR3ZWVuLl9zdGFydEF0Ll9kcCA9IDA7XG4gICAgICAgIHR3ZWVuLl9zdGFydEF0Ll9zYXQgPSB0d2VlbjtcbiAgICAgICAgdGltZSA8IDAgJiYgKF9yZXZlcnRpbmcgfHwgIWltbWVkaWF0ZVJlbmRlciAmJiAhYXV0b1JldmVydCkgJiYgdHdlZW4uX3N0YXJ0QXQucmV2ZXJ0KF9yZXZlcnRDb25maWdOb0tpbGwpO1xuXG4gICAgICAgIGlmIChpbW1lZGlhdGVSZW5kZXIpIHtcbiAgICAgICAgICBpZiAoZHVyICYmIHRpbWUgPD0gMCAmJiB0VGltZSA8PSAwKSB7XG4gICAgICAgICAgICB0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnVuQmFja3dhcmRzICYmIGR1cikge1xuICAgICAgICBpZiAoIXByZXZTdGFydEF0KSB7XG4gICAgICAgICAgdGltZSAmJiAoaW1tZWRpYXRlUmVuZGVyID0gZmFsc2UpO1xuICAgICAgICAgIHAgPSBfc2V0RGVmYXVsdHMoe1xuICAgICAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgICAgICAgIGRhdGE6IFwiaXNGcm9tU3RhcnRcIixcbiAgICAgICAgICAgIGxhenk6IGltbWVkaWF0ZVJlbmRlciAmJiAhcHJldlN0YXJ0QXQgJiYgX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IGltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgICAgIHN0YWdnZXI6IDAsXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudFxuICAgICAgICAgIH0sIGNsZWFuVmFycyk7XG4gICAgICAgICAgaGFybmVzc1ZhcnMgJiYgKHBbaGFybmVzcy5wcm9wXSA9IGhhcm5lc3NWYXJzKTtcblxuICAgICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIHApKTtcblxuICAgICAgICAgIHR3ZWVuLl9zdGFydEF0Ll9kcCA9IDA7XG4gICAgICAgICAgdHdlZW4uX3N0YXJ0QXQuX3NhdCA9IHR3ZWVuO1xuICAgICAgICAgIHRpbWUgPCAwICYmIChfcmV2ZXJ0aW5nID8gdHdlZW4uX3N0YXJ0QXQucmV2ZXJ0KF9yZXZlcnRDb25maWdOb0tpbGwpIDogdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKSk7XG4gICAgICAgICAgdHdlZW4uX3pUaW1lID0gdGltZTtcblxuICAgICAgICAgIGlmICghaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgICAgICBfaW5pdFR3ZWVuKHR3ZWVuLl9zdGFydEF0LCBfdGlueU51bSwgX3RpbnlOdW0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHdlZW4uX3B0ID0gdHdlZW4uX3B0Q2FjaGUgPSAwO1xuICAgICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldHNbaV07XG4gICAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgICAgdHdlZW4uX3B0TG9va3VwW2ldID0gcHRMb29rdXAgPSB7fTtcbiAgICAgICAgX2xhenlMb29rdXBbZ3NEYXRhLmlkXSAmJiBfbGF6eVR3ZWVucy5sZW5ndGggJiYgX2xhenlSZW5kZXIoKTtcbiAgICAgICAgaW5kZXggPSBmdWxsVGFyZ2V0cyA9PT0gdGFyZ2V0cyA/IGkgOiBmdWxsVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgICAgICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcGx1Z2luLm5hbWUsIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgICAgICAgIHBsdWdpbi5fcHJvcHMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcHRMb29rdXBbbmFtZV0gPSBwdDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFybmVzcyB8fCBoYXJuZXNzVmFycykge1xuICAgICAgICAgIGZvciAocCBpbiBjbGVhblZhcnMpIHtcbiAgICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcbiAgICAgICAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHR3ZWVuLl9vcCAmJiB0d2Vlbi5fb3BbaV0gJiYgdHdlZW4ua2lsbCh0YXJnZXQsIHR3ZWVuLl9vcFtpXSk7XG5cbiAgICAgICAgaWYgKGF1dG9PdmVyd3JpdGUgJiYgdHdlZW4uX3B0KSB7XG4gICAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSB0d2VlbjtcblxuICAgICAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0LCBwdExvb2t1cCwgdHdlZW4uZ2xvYmFsVGltZSh0aW1lKSk7XG5cbiAgICAgICAgICBvdmVyd3JpdHRlbiA9ICF0d2Vlbi5wYXJlbnQ7XG4gICAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdHdlZW4uX3B0ICYmIGxhenkgJiYgKF9sYXp5TG9va3VwW2dzRGF0YS5pZF0gPSAxKTtcbiAgICAgIH1cblxuICAgICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0d2Vlbik7XG4gICAgICB0d2Vlbi5fb25Jbml0ICYmIHR3ZWVuLl9vbkluaXQodHdlZW4pO1xuICAgIH1cblxuICAgIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICAgIHR3ZWVuLl9pbml0dGVkID0gKCF0d2Vlbi5fb3AgfHwgdHdlZW4uX3B0KSAmJiAhb3ZlcndyaXR0ZW47XG4gICAga2V5ZnJhbWVzICYmIHRpbWUgPD0gMCAmJiB0bC5yZW5kZXIoX2JpZ051bSwgdHJ1ZSwgdHJ1ZSk7XG4gIH0sXG4gICAgICBfdXBkYXRlUHJvcFR3ZWVucyA9IGZ1bmN0aW9uIF91cGRhdGVQcm9wVHdlZW5zKHR3ZWVuLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHJhdGlvLCB0aW1lLCBza2lwUmVjdXJzaW9uKSB7XG4gICAgdmFyIHB0Q2FjaGUgPSAodHdlZW4uX3B0ICYmIHR3ZWVuLl9wdENhY2hlIHx8ICh0d2Vlbi5fcHRDYWNoZSA9IHt9KSlbcHJvcGVydHldLFxuICAgICAgICBwdCxcbiAgICAgICAgcm9vdFBULFxuICAgICAgICBsb29rdXAsXG4gICAgICAgIGk7XG5cbiAgICBpZiAoIXB0Q2FjaGUpIHtcbiAgICAgIHB0Q2FjaGUgPSB0d2Vlbi5fcHRDYWNoZVtwcm9wZXJ0eV0gPSBbXTtcbiAgICAgIGxvb2t1cCA9IHR3ZWVuLl9wdExvb2t1cDtcbiAgICAgIGkgPSB0d2Vlbi5fdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgcHQgPSBsb29rdXBbaV1bcHJvcGVydHldO1xuXG4gICAgICAgIGlmIChwdCAmJiBwdC5kICYmIHB0LmQuX3B0KSB7XG4gICAgICAgICAgcHQgPSBwdC5kLl9wdDtcblxuICAgICAgICAgIHdoaWxlIChwdCAmJiBwdC5wICE9PSBwcm9wZXJ0eSAmJiBwdC5mcCAhPT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgIF9mb3JjZUFsbFByb3BUd2VlbnMgPSAxO1xuICAgICAgICAgIHR3ZWVuLnZhcnNbcHJvcGVydHldID0gXCIrPTBcIjtcblxuICAgICAgICAgIF9pbml0VHdlZW4odHdlZW4sIHRpbWUpO1xuXG4gICAgICAgICAgX2ZvcmNlQWxsUHJvcFR3ZWVucyA9IDA7XG4gICAgICAgICAgcmV0dXJuIHNraXBSZWN1cnNpb24gPyBfd2Fybihwcm9wZXJ0eSArIFwiIG5vdCBlbGlnaWJsZSBmb3IgcmVzZXRcIikgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcHRDYWNoZS5wdXNoKHB0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpID0gcHRDYWNoZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByb290UFQgPSBwdENhY2hlW2ldO1xuICAgICAgcHQgPSByb290UFQuX3B0IHx8IHJvb3RQVDtcbiAgICAgIHB0LnMgPSAoc3RhcnQgfHwgc3RhcnQgPT09IDApICYmICFzdGFydElzUmVsYXRpdmUgPyBzdGFydCA6IHB0LnMgKyAoc3RhcnQgfHwgMCkgKyByYXRpbyAqIHB0LmM7XG4gICAgICBwdC5jID0gdmFsdWUgLSBwdC5zO1xuICAgICAgcm9vdFBULmUgJiYgKHJvb3RQVC5lID0gX3JvdW5kKHZhbHVlKSArIGdldFVuaXQocm9vdFBULmUpKTtcbiAgICAgIHJvb3RQVC5iICYmIChyb290UFQuYiA9IHB0LnMgKyBnZXRVbml0KHJvb3RQVC5iKSk7XG4gICAgfVxuICB9LFxuICAgICAgX2FkZEFsaWFzZXNUb1ZhcnMgPSBmdW5jdGlvbiBfYWRkQWxpYXNlc1RvVmFycyh0YXJnZXRzLCB2YXJzKSB7XG4gICAgdmFyIGhhcm5lc3MgPSB0YXJnZXRzWzBdID8gX2dldENhY2hlKHRhcmdldHNbMF0pLmhhcm5lc3MgOiAwLFxuICAgICAgICBwcm9wZXJ0eUFsaWFzZXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyxcbiAgICAgICAgY29weSxcbiAgICAgICAgcCxcbiAgICAgICAgaSxcbiAgICAgICAgYWxpYXNlcztcblxuICAgIGlmICghcHJvcGVydHlBbGlhc2VzKSB7XG4gICAgICByZXR1cm4gdmFycztcbiAgICB9XG5cbiAgICBjb3B5ID0gX21lcmdlKHt9LCB2YXJzKTtcblxuICAgIGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICAgIGlmIChwIGluIGNvcHkpIHtcbiAgICAgICAgYWxpYXNlcyA9IHByb3BlcnR5QWxpYXNlc1twXS5zcGxpdChcIixcIik7XG4gICAgICAgIGkgPSBhbGlhc2VzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgY29weVthbGlhc2VzW2ldXSA9IGNvcHlbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29weTtcbiAgfSxcbiAgICAgIF9wYXJzZUtleWZyYW1lID0gZnVuY3Rpb24gX3BhcnNlS2V5ZnJhbWUocHJvcCwgb2JqLCBhbGxQcm9wcywgZWFzZUVhY2gpIHtcbiAgICB2YXIgZWFzZSA9IG9iai5lYXNlIHx8IGVhc2VFYWNoIHx8IFwicG93ZXIxLmluT3V0XCIsXG4gICAgICAgIHAsXG4gICAgICAgIGE7XG5cbiAgICBpZiAoX2lzQXJyYXkob2JqKSkge1xuICAgICAgYSA9IGFsbFByb3BzW3Byb3BdIHx8IChhbGxQcm9wc1twcm9wXSA9IFtdKTtcbiAgICAgIG9iai5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgICAgICByZXR1cm4gYS5wdXNoKHtcbiAgICAgICAgICB0OiBpIC8gKG9iai5sZW5ndGggLSAxKSAqIDEwMCxcbiAgICAgICAgICB2OiB2YWx1ZSxcbiAgICAgICAgICBlOiBlYXNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAocCBpbiBvYmopIHtcbiAgICAgICAgYSA9IGFsbFByb3BzW3BdIHx8IChhbGxQcm9wc1twXSA9IFtdKTtcbiAgICAgICAgcCA9PT0gXCJlYXNlXCIgfHwgYS5wdXNoKHtcbiAgICAgICAgICB0OiBwYXJzZUZsb2F0KHByb3ApLFxuICAgICAgICAgIHY6IG9ialtwXSxcbiAgICAgICAgICBlOiBlYXNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgICAgIF9wYXJzZUZ1bmNPclN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZUZ1bmNPclN0cmluZyh2YWx1ZSwgdHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykge1xuICAgIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIDogX2lzU3RyaW5nKHZhbHVlKSAmJiB+dmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikgPyBfcmVwbGFjZVJhbmRvbSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfSxcbiAgICAgIF9zdGFnZ2VyVHdlZW5Qcm9wcyA9IF9jYWxsYmFja05hbWVzICsgXCJyZXBlYXQscmVwZWF0RGVsYXkseW95byxyZXBlYXRSZWZyZXNoLHlveW9FYXNlLGF1dG9SZXZlcnRcIixcbiAgICAgIF9zdGFnZ2VyUHJvcHNUb1NraXAgPSB7fTtcblxuICBfZm9yRWFjaE5hbWUoX3N0YWdnZXJUd2VlblByb3BzICsgXCIsaWQsc3RhZ2dlcixkZWxheSxkdXJhdGlvbixwYXVzZWQsc2Nyb2xsVHJpZ2dlclwiLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBfc3RhZ2dlclByb3BzVG9Ta2lwW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgdmFyIFR3ZWVuID0gZnVuY3Rpb24gKF9BbmltYXRpb24yKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoVHdlZW4sIF9BbmltYXRpb24yKTtcblxuICAgIGZ1bmN0aW9uIFR3ZWVuKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uLCBza2lwSW5oZXJpdCkge1xuICAgICAgdmFyIF90aGlzMztcblxuICAgICAgaWYgKHR5cGVvZiB2YXJzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHBvc2l0aW9uLmR1cmF0aW9uID0gdmFycztcbiAgICAgICAgdmFycyA9IHBvc2l0aW9uO1xuICAgICAgICBwb3NpdGlvbiA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIF90aGlzMyA9IF9BbmltYXRpb24yLmNhbGwodGhpcywgc2tpcEluaGVyaXQgPyB2YXJzIDogX2luaGVyaXREZWZhdWx0cyh2YXJzKSkgfHwgdGhpcztcbiAgICAgIHZhciBfdGhpczMkdmFycyA9IF90aGlzMy52YXJzLFxuICAgICAgICAgIGR1cmF0aW9uID0gX3RoaXMzJHZhcnMuZHVyYXRpb24sXG4gICAgICAgICAgZGVsYXkgPSBfdGhpczMkdmFycy5kZWxheSxcbiAgICAgICAgICBpbW1lZGlhdGVSZW5kZXIgPSBfdGhpczMkdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgICAgc3RhZ2dlciA9IF90aGlzMyR2YXJzLnN0YWdnZXIsXG4gICAgICAgICAgb3ZlcndyaXRlID0gX3RoaXMzJHZhcnMub3ZlcndyaXRlLFxuICAgICAgICAgIGtleWZyYW1lcyA9IF90aGlzMyR2YXJzLmtleWZyYW1lcyxcbiAgICAgICAgICBkZWZhdWx0cyA9IF90aGlzMyR2YXJzLmRlZmF1bHRzLFxuICAgICAgICAgIHNjcm9sbFRyaWdnZXIgPSBfdGhpczMkdmFycy5zY3JvbGxUcmlnZ2VyLFxuICAgICAgICAgIHlveW9FYXNlID0gX3RoaXMzJHZhcnMueW95b0Vhc2UsXG4gICAgICAgICAgcGFyZW50ID0gdmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLFxuICAgICAgICAgIHBhcnNlZFRhcmdldHMgPSAoX2lzQXJyYXkodGFyZ2V0cykgfHwgX2lzVHlwZWRBcnJheSh0YXJnZXRzKSA/IF9pc051bWJlcih0YXJnZXRzWzBdKSA6IFwibGVuZ3RoXCIgaW4gdmFycykgPyBbdGFyZ2V0c10gOiB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICAgIHRsLFxuICAgICAgICAgIGksXG4gICAgICAgICAgY29weSxcbiAgICAgICAgICBsLFxuICAgICAgICAgIHAsXG4gICAgICAgICAgY3VyVGFyZ2V0LFxuICAgICAgICAgIHN0YWdnZXJGdW5jLFxuICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZTtcbiAgICAgIF90aGlzMy5fdGFyZ2V0cyA9IHBhcnNlZFRhcmdldHMubGVuZ3RoID8gX2hhcm5lc3MocGFyc2VkVGFyZ2V0cykgOiBfd2FybihcIkdTQVAgdGFyZ2V0IFwiICsgdGFyZ2V0cyArIFwiIG5vdCBmb3VuZC4gaHR0cHM6Ly9nc2FwLmNvbVwiLCAhX2NvbmZpZy5udWxsVGFyZ2V0V2FybikgfHwgW107XG4gICAgICBfdGhpczMuX3B0TG9va3VwID0gW107XG4gICAgICBfdGhpczMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcblxuICAgICAgaWYgKGtleWZyYW1lcyB8fCBzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICB2YXJzID0gX3RoaXMzLnZhcnM7XG4gICAgICAgIHRsID0gX3RoaXMzLnRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgICAgICAgICBkYXRhOiBcIm5lc3RlZFwiLFxuICAgICAgICAgIGRlZmF1bHRzOiBkZWZhdWx0cyB8fCB7fSxcbiAgICAgICAgICB0YXJnZXRzOiBwYXJlbnQgJiYgcGFyZW50LmRhdGEgPT09IFwibmVzdGVkXCIgPyBwYXJlbnQudmFycy50YXJnZXRzIDogcGFyc2VkVGFyZ2V0c1xuICAgICAgICB9KTtcbiAgICAgICAgdGwua2lsbCgpO1xuICAgICAgICB0bC5wYXJlbnQgPSB0bC5fZHAgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG4gICAgICAgIHRsLl9zdGFydCA9IDA7XG5cbiAgICAgICAgaWYgKHN0YWdnZXIgfHwgX2lzRnVuY09yU3RyaW5nKGR1cmF0aW9uKSB8fCBfaXNGdW5jT3JTdHJpbmcoZGVsYXkpKSB7XG4gICAgICAgICAgbCA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuICAgICAgICAgIHN0YWdnZXJGdW5jID0gc3RhZ2dlciAmJiBkaXN0cmlidXRlKHN0YWdnZXIpO1xuXG4gICAgICAgICAgaWYgKF9pc09iamVjdChzdGFnZ2VyKSkge1xuICAgICAgICAgICAgZm9yIChwIGluIHN0YWdnZXIpIHtcbiAgICAgICAgICAgICAgaWYgKH5fc3RhZ2dlclR3ZWVuUHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSB8fCAoc3RhZ2dlclZhcnNUb01lcmdlID0ge30pO1xuICAgICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZVtwXSA9IHN0YWdnZXJbcF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5ID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3N0YWdnZXJQcm9wc1RvU2tpcCk7XG4gICAgICAgICAgICBjb3B5LnN0YWdnZXIgPSAwO1xuICAgICAgICAgICAgeW95b0Vhc2UgJiYgKGNvcHkueW95b0Vhc2UgPSB5b3lvRWFzZSk7XG4gICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgJiYgX21lcmdlKGNvcHksIHN0YWdnZXJWYXJzVG9NZXJnZSk7XG4gICAgICAgICAgICBjdXJUYXJnZXQgPSBwYXJzZWRUYXJnZXRzW2ldO1xuICAgICAgICAgICAgY29weS5kdXJhdGlvbiA9ICtfcGFyc2VGdW5jT3JTdHJpbmcoZHVyYXRpb24sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKTtcbiAgICAgICAgICAgIGNvcHkuZGVsYXkgPSAoK19wYXJzZUZ1bmNPclN0cmluZyhkZWxheSwgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpLCBpLCBjdXJUYXJnZXQsIHBhcnNlZFRhcmdldHMpIHx8IDApIC0gX3RoaXMzLl9kZWxheTtcblxuICAgICAgICAgICAgaWYgKCFzdGFnZ2VyICYmIGwgPT09IDEgJiYgY29weS5kZWxheSkge1xuICAgICAgICAgICAgICBfdGhpczMuX2RlbGF5ID0gZGVsYXkgPSBjb3B5LmRlbGF5O1xuICAgICAgICAgICAgICBfdGhpczMuX3N0YXJ0ICs9IGRlbGF5O1xuICAgICAgICAgICAgICBjb3B5LmRlbGF5ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGwudG8oY3VyVGFyZ2V0LCBjb3B5LCBzdGFnZ2VyRnVuYyA/IHN0YWdnZXJGdW5jKGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgOiAwKTtcbiAgICAgICAgICAgIHRsLl9lYXNlID0gX2Vhc2VNYXAubm9uZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0bC5kdXJhdGlvbigpID8gZHVyYXRpb24gPSBkZWxheSA9IDAgOiBfdGhpczMudGltZWxpbmUgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGtleWZyYW1lcykge1xuICAgICAgICAgIF9pbmhlcml0RGVmYXVsdHMoX3NldERlZmF1bHRzKHRsLnZhcnMuZGVmYXVsdHMsIHtcbiAgICAgICAgICAgIGVhc2U6IFwibm9uZVwiXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgdGwuX2Vhc2UgPSBfcGFyc2VFYXNlKGtleWZyYW1lcy5lYXNlIHx8IHZhcnMuZWFzZSB8fCBcIm5vbmVcIik7XG4gICAgICAgICAgdmFyIHRpbWUgPSAwLFxuICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICBrZixcbiAgICAgICAgICAgICAgdjtcblxuICAgICAgICAgIGlmIChfaXNBcnJheShrZXlmcmFtZXMpKSB7XG4gICAgICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRsLnRvKHBhcnNlZFRhcmdldHMsIGZyYW1lLCBcIj5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRsLmR1cmF0aW9uKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvcHkgPSB7fTtcblxuICAgICAgICAgICAgZm9yIChwIGluIGtleWZyYW1lcykge1xuICAgICAgICAgICAgICBwID09PSBcImVhc2VcIiB8fCBwID09PSBcImVhc2VFYWNoXCIgfHwgX3BhcnNlS2V5ZnJhbWUocCwga2V5ZnJhbWVzW3BdLCBjb3B5LCBrZXlmcmFtZXMuZWFzZUVhY2gpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHAgaW4gY29weSkge1xuICAgICAgICAgICAgICBhID0gY29weVtwXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEudCAtIGIudDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHRpbWUgPSAwO1xuXG4gICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2YgPSBhW2ldO1xuICAgICAgICAgICAgICAgIHYgPSB7XG4gICAgICAgICAgICAgICAgICBlYXNlOiBrZi5lLFxuICAgICAgICAgICAgICAgICAgZHVyYXRpb246IChrZi50IC0gKGkgPyBhW2kgLSAxXS50IDogMCkpIC8gMTAwICogZHVyYXRpb25cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZbcF0gPSBrZi52O1xuICAgICAgICAgICAgICAgIHRsLnRvKHBhcnNlZFRhcmdldHMsIHYsIHRpbWUpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gdi5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0bC5kdXJhdGlvbigpIDwgZHVyYXRpb24gJiYgdGwudG8oe30sIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uIC0gdGwuZHVyYXRpb24oKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZHVyYXRpb24gfHwgX3RoaXMzLmR1cmF0aW9uKGR1cmF0aW9uID0gdGwuZHVyYXRpb24oKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpczMudGltZWxpbmUgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcndyaXRlID09PSB0cnVlICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzKSB7XG4gICAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczMpO1xuXG4gICAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YocGFyc2VkVGFyZ2V0cyk7XG5cbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICBfYWRkVG9UaW1lbGluZShwYXJlbnQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgcG9zaXRpb24pO1xuXG4gICAgICB2YXJzLnJldmVyc2VkICYmIF90aGlzMy5yZXZlcnNlKCk7XG4gICAgICB2YXJzLnBhdXNlZCAmJiBfdGhpczMucGF1c2VkKHRydWUpO1xuXG4gICAgICBpZiAoaW1tZWRpYXRlUmVuZGVyIHx8ICFkdXJhdGlvbiAmJiAha2V5ZnJhbWVzICYmIF90aGlzMy5fc3RhcnQgPT09IF9yb3VuZFByZWNpc2UocGFyZW50Ll90aW1lKSAmJiBfaXNOb3RGYWxzZShpbW1lZGlhdGVSZW5kZXIpICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpICYmIHBhcmVudC5kYXRhICE9PSBcIm5lc3RlZFwiKSB7XG4gICAgICAgIF90aGlzMy5fdFRpbWUgPSAtX3RpbnlOdW07XG5cbiAgICAgICAgX3RoaXMzLnJlbmRlcihNYXRoLm1heCgwLCAtZGVsYXkpIHx8IDApO1xuICAgICAgfVxuXG4gICAgICBzY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgc2Nyb2xsVHJpZ2dlcik7XG4gICAgICByZXR1cm4gX3RoaXMzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8zID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvMy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICAgIHZhciBwcmV2VGltZSA9IHRoaXMuX3RpbWUsXG4gICAgICAgICAgdER1ciA9IHRoaXMuX3REdXIsXG4gICAgICAgICAgZHVyID0gdGhpcy5fZHVyLFxuICAgICAgICAgIGlzTmVnYXRpdmUgPSB0b3RhbFRpbWUgPCAwLFxuICAgICAgICAgIHRUaW1lID0gdG90YWxUaW1lID4gdER1ciAtIF90aW55TnVtICYmICFpc05lZ2F0aXZlID8gdER1ciA6IHRvdGFsVGltZSA8IF90aW55TnVtID8gMCA6IHRvdGFsVGltZSxcbiAgICAgICAgICB0aW1lLFxuICAgICAgICAgIHB0LFxuICAgICAgICAgIGl0ZXJhdGlvbixcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICAgIHByZXZJdGVyYXRpb24sXG4gICAgICAgICAgaXNZb3lvLFxuICAgICAgICAgIHJhdGlvLFxuICAgICAgICAgIHRpbWVsaW5lLFxuICAgICAgICAgIHlveW9FYXNlO1xuXG4gICAgICBpZiAoIWR1cikge1xuICAgICAgICBfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4odGhpcywgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgfSBlbHNlIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgIXRvdGFsVGltZSB8fCBmb3JjZSB8fCAhdGhpcy5faW5pdHRlZCAmJiB0aGlzLl90VGltZSB8fCB0aGlzLl9zdGFydEF0ICYmIHRoaXMuX3pUaW1lIDwgMCAhPT0gaXNOZWdhdGl2ZSB8fCB0aGlzLl9sYXp5KSB7XG4gICAgICAgIHRpbWUgPSB0VGltZTtcbiAgICAgICAgdGltZWxpbmUgPSB0aGlzLnRpbWVsaW5lO1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gZHVyICsgdGhpcy5fckRlbGF5O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZJdGVyYXRpb24gPSBfcm91bmRQcmVjaXNlKHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG4gICAgICAgICAgICBpdGVyYXRpb24gPSB+fnByZXZJdGVyYXRpb247XG5cbiAgICAgICAgICAgIGlmIChpdGVyYXRpb24gJiYgaXRlcmF0aW9uID09PSBwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aW1lID4gZHVyKSB7XG4gICAgICAgICAgICAgIHRpbWUgPSBkdXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNZb3lvID0gdGhpcy5feW95byAmJiBpdGVyYXRpb24gJiAxO1xuXG4gICAgICAgICAgaWYgKGlzWW95bykge1xuICAgICAgICAgICAgeW95b0Vhc2UgPSB0aGlzLl95RWFzZTtcbiAgICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByZXZJdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodGhpcy5fdFRpbWUsIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKHRpbWUgPT09IHByZXZUaW1lICYmICFmb3JjZSAmJiB0aGlzLl9pbml0dGVkICYmIGl0ZXJhdGlvbiA9PT0gcHJldkl0ZXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICAgIHRpbWVsaW5lICYmIHRoaXMuX3lFYXNlICYmIF9wcm9wYWdhdGVZb3lvRWFzZSh0aW1lbGluZSwgaXNZb3lvKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgIXRoaXMuX2xvY2sgJiYgdGltZSAhPT0gY3ljbGVEdXJhdGlvbiAmJiB0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2xvY2sgPSBmb3JjZSA9IDE7XG4gICAgICAgICAgICAgIHRoaXMucmVuZGVyKF9yb3VuZFByZWNpc2UoY3ljbGVEdXJhdGlvbiAqIGl0ZXJhdGlvbiksIHRydWUpLmludmFsaWRhdGUoKS5fbG9jayA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgaWYgKF9hdHRlbXB0SW5pdFR3ZWVuKHRoaXMsIGlzTmVnYXRpdmUgPyB0b3RhbFRpbWUgOiB0aW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMsIHRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdFRpbWUgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmICEoZm9yY2UgJiYgdGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgaXRlcmF0aW9uICE9PSBwcmV2SXRlcmF0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGR1ciAhPT0gdGhpcy5fZHVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7XG4gICAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmICghdGhpcy5fYWN0ICYmIHRoaXMuX3RzKSB7XG4gICAgICAgICAgdGhpcy5fYWN0ID0gMTtcbiAgICAgICAgICB0aGlzLl9sYXp5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9ICh5b3lvRWFzZSB8fCB0aGlzLl9lYXNlKSh0aW1lIC8gZHVyKTtcblxuICAgICAgICBpZiAodGhpcy5fZnJvbSkge1xuICAgICAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJldlRpbWUgJiYgdFRpbWUgJiYgIXN1cHByZXNzRXZlbnRzICYmICFwcmV2SXRlcmF0aW9uKSB7XG4gICAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgICAgd2hpbGUgKHB0KSB7XG4gICAgICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVsaW5lICYmIHRpbWVsaW5lLnJlbmRlcih0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZWxpbmUuX2R1ciAqIHRpbWVsaW5lLl9lYXNlKHRpbWUgLyB0aGlzLl9kdXIpLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHx8IHRoaXMuX3N0YXJ0QXQgJiYgKHRoaXMuX3pUaW1lID0gdG90YWxUaW1lKTtcblxuICAgICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgICAgaXNOZWdhdGl2ZSAmJiBfcmV3aW5kU3RhcnRBdCh0aGlzLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG5cbiAgICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlcGVhdCAmJiBpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgdGhpcy52YXJzLm9uUmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0aGlzLnBhcmVudCAmJiBfY2FsbGJhY2sodGhpcywgXCJvblJlcGVhdFwiKTtcblxuICAgICAgICBpZiAoKHRUaW1lID09PSB0aGlzLl90RHVyIHx8ICF0VGltZSkgJiYgdGhpcy5fdFRpbWUgPT09IHRUaW1lKSB7XG4gICAgICAgICAgaXNOZWdhdGl2ZSAmJiAhdGhpcy5fb25VcGRhdGUgJiYgX3Jld2luZFN0YXJ0QXQodGhpcywgdG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdGhpcy5fdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7XG5cbiAgICAgICAgICBpZiAoIXN1cHByZXNzRXZlbnRzICYmICEoaXNOZWdhdGl2ZSAmJiAhcHJldlRpbWUpICYmICh0VGltZSB8fCBwcmV2VGltZSB8fCBpc1lveW8pKSB7XG4gICAgICAgICAgICBfY2FsbGJhY2sodGhpcywgdFRpbWUgPT09IHREdXIgPyBcIm9uQ29tcGxldGVcIiA6IFwib25SZXZlcnNlQ29tcGxldGVcIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90bzMudGFyZ2V0cyA9IGZ1bmN0aW9uIHRhcmdldHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvMy5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZShzb2Z0KSB7XG4gICAgICAoIXNvZnQgfHwgIXRoaXMudmFycy5ydW5CYWNrd2FyZHMpICYmICh0aGlzLl9zdGFydEF0ID0gMCk7XG4gICAgICB0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9sYXp5ID0gdGhpcy5yYXRpbyA9IDA7XG4gICAgICB0aGlzLl9wdExvb2t1cCA9IFtdO1xuICAgICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLmludmFsaWRhdGUoc29mdCk7XG4gICAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzLCBzb2Z0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMy5yZXNldFRvID0gZnVuY3Rpb24gcmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHNraXBSZWN1cnNpb24pIHtcbiAgICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gICAgICB0aGlzLl90cyB8fCB0aGlzLnBsYXkoKTtcbiAgICAgIHZhciB0aW1lID0gTWF0aC5taW4odGhpcy5fZHVyLCAodGhpcy5fZHAuX3RpbWUgLSB0aGlzLl9zdGFydCkgKiB0aGlzLl90cyksXG4gICAgICAgICAgcmF0aW87XG4gICAgICB0aGlzLl9pbml0dGVkIHx8IF9pbml0VHdlZW4odGhpcywgdGltZSk7XG4gICAgICByYXRpbyA9IHRoaXMuX2Vhc2UodGltZSAvIHRoaXMuX2R1cik7XG5cbiAgICAgIGlmIChfdXBkYXRlUHJvcFR3ZWVucyh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUsIHJhdGlvLCB0aW1lLCBza2lwUmVjdXJzaW9uKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNldFRvKHByb3BlcnR5LCB2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSwgMSk7XG4gICAgICB9XG5cbiAgICAgIF9hbGlnblBsYXloZWFkKHRoaXMsIDApO1xuXG4gICAgICB0aGlzLnBhcmVudCB8fCBfYWRkTGlua2VkTGlzdEl0ZW0odGhpcy5fZHAsIHRoaXMsIFwiX2ZpcnN0XCIsIFwiX2xhc3RcIiwgdGhpcy5fZHAuX3NvcnQgPyBcIl9zdGFydFwiIDogMCk7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXIoMCk7XG4gICAgfTtcblxuICAgIF9wcm90bzMua2lsbCA9IGZ1bmN0aW9uIGtpbGwodGFyZ2V0cywgdmFycykge1xuICAgICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXJzID0gXCJhbGxcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0YXJnZXRzICYmICghdmFycyB8fCB2YXJzID09PSBcImFsbFwiKSkge1xuICAgICAgICB0aGlzLl9sYXp5ID0gdGhpcy5fcHQgPSAwO1xuICAgICAgICB0aGlzLnBhcmVudCA/IF9pbnRlcnJ1cHQodGhpcykgOiB0aGlzLnNjcm9sbFRyaWdnZXIgJiYgdGhpcy5zY3JvbGxUcmlnZ2VyLmtpbGwoISFfcmV2ZXJ0aW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRpbWVsaW5lKSB7XG4gICAgICAgIHZhciB0RHVyID0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCk7XG4gICAgICAgIHRoaXMudGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldHMsIHZhcnMsIF9vdmVyd3JpdGluZ1R3ZWVuICYmIF9vdmVyd3JpdGluZ1R3ZWVuLnZhcnMub3ZlcndyaXRlICE9PSB0cnVlKS5fZmlyc3QgfHwgX2ludGVycnVwdCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgJiYgdER1ciAhPT0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCkgJiYgX3NldER1cmF0aW9uKHRoaXMsIHRoaXMuX2R1ciAqIHRoaXMudGltZWxpbmUuX3REdXIgLyB0RHVyLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAgICBraWxsaW5nVGFyZ2V0cyA9IHRhcmdldHMgPyB0b0FycmF5KHRhcmdldHMpIDogcGFyc2VkVGFyZ2V0cyxcbiAgICAgICAgICBwcm9wVHdlZW5Mb29rdXAgPSB0aGlzLl9wdExvb2t1cCxcbiAgICAgICAgICBmaXJzdFBUID0gdGhpcy5fcHQsXG4gICAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wcyxcbiAgICAgICAgICBjdXJMb29rdXAsXG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMsXG4gICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBwdCxcbiAgICAgICAgICBpO1xuXG4gICAgICBpZiAoKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpICYmIF9hcnJheXNNYXRjaChwYXJzZWRUYXJnZXRzLCBraWxsaW5nVGFyZ2V0cykpIHtcbiAgICAgICAgdmFycyA9PT0gXCJhbGxcIiAmJiAodGhpcy5fcHQgPSAwKTtcbiAgICAgICAgcmV0dXJuIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vcCA9IHRoaXMuX29wIHx8IFtdO1xuXG4gICAgICBpZiAodmFycyAhPT0gXCJhbGxcIikge1xuICAgICAgICBpZiAoX2lzU3RyaW5nKHZhcnMpKSB7XG4gICAgICAgICAgcCA9IHt9O1xuXG4gICAgICAgICAgX2ZvckVhY2hOYW1lKHZhcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gcFtuYW1lXSA9IDE7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXJzID0gcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhcnMgPSBfYWRkQWxpYXNlc1RvVmFycyhwYXJzZWRUYXJnZXRzLCB2YXJzKTtcbiAgICAgIH1cblxuICAgICAgaSA9IHBhcnNlZFRhcmdldHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh+a2lsbGluZ1RhcmdldHMuaW5kZXhPZihwYXJzZWRUYXJnZXRzW2ldKSkge1xuICAgICAgICAgIGN1ckxvb2t1cCA9IHByb3BUd2Vlbkxvb2t1cFtpXTtcblxuICAgICAgICAgIGlmICh2YXJzID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBvdmVyd3JpdHRlblByb3BzW2ldID0gdmFycztcbiAgICAgICAgICAgIHByb3BzID0gY3VyTG9va3VwO1xuICAgICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSBvdmVyd3JpdHRlblByb3BzW2ldID0gb3ZlcndyaXR0ZW5Qcm9wc1tpXSB8fCB7fTtcbiAgICAgICAgICAgIHByb3BzID0gdmFycztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHAgaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIHB0ID0gY3VyTG9va3VwICYmIGN1ckxvb2t1cFtwXTtcblxuICAgICAgICAgICAgaWYgKHB0KSB7XG4gICAgICAgICAgICAgIGlmICghKFwia2lsbFwiIGluIHB0LmQpIHx8IHB0LmQua2lsbChwKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgY3VyTG9va3VwW3BdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VyT3ZlcndyaXRlUHJvcHMgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHNbcF0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0dGVkICYmICF0aGlzLl9wdCAmJiBmaXJzdFBUICYmIF9pbnRlcnJ1cHQodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgVHdlZW4udG8gPSBmdW5jdGlvbiB0byh0YXJnZXRzLCB2YXJzKSB7XG4gICAgICByZXR1cm4gbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIGFyZ3VtZW50c1syXSk7XG4gICAgfTtcblxuICAgIFR3ZWVuLmZyb20gPSBmdW5jdGlvbiBmcm9tKHRhcmdldHMsIHZhcnMpIHtcbiAgICAgIHJldHVybiBfY3JlYXRlVHdlZW5UeXBlKDEsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIFR3ZWVuLmRlbGF5ZWRDYWxsID0gZnVuY3Rpb24gZGVsYXllZENhbGwoZGVsYXksIGNhbGxiYWNrLCBwYXJhbXMsIHNjb3BlKSB7XG4gICAgICByZXR1cm4gbmV3IFR3ZWVuKGNhbGxiYWNrLCAwLCB7XG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogZmFsc2UsXG4gICAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgICBvdmVyd3JpdGU6IGZhbHNlLFxuICAgICAgICBkZWxheTogZGVsYXksXG4gICAgICAgIG9uQ29tcGxldGU6IGNhbGxiYWNrLFxuICAgICAgICBvblJldmVyc2VDb21wbGV0ZTogY2FsbGJhY2ssXG4gICAgICAgIG9uQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgb25SZXZlcnNlQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgY2FsbGJhY2tTY29wZTogc2NvcGVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBUd2Vlbi5mcm9tVG8gPSBmdW5jdGlvbiBmcm9tVG8odGFyZ2V0cywgZnJvbVZhcnMsIHRvVmFycykge1xuICAgICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgVHdlZW4uc2V0ID0gZnVuY3Rpb24gc2V0KHRhcmdldHMsIHZhcnMpIHtcbiAgICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgICAgdmFycy5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycyk7XG4gICAgfTtcblxuICAgIFR3ZWVuLmtpbGxUd2VlbnNPZiA9IGZ1bmN0aW9uIGtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSkge1xuICAgICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gVHdlZW47XG4gIH0oQW5pbWF0aW9uKTtcblxuICBfc2V0RGVmYXVsdHMoVHdlZW4ucHJvdG90eXBlLCB7XG4gICAgX3RhcmdldHM6IFtdLFxuICAgIF9sYXp5OiAwLFxuICAgIF9zdGFydEF0OiAwLFxuICAgIF9vcDogMCxcbiAgICBfb25Jbml0OiAwXG4gIH0pO1xuXG4gIF9mb3JFYWNoTmFtZShcInN0YWdnZXJUbyxzdGFnZ2VyRnJvbSxzdGFnZ2VyRnJvbVRvXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgVHdlZW5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUoKSxcbiAgICAgICAgICBwYXJhbXMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICBwYXJhbXMuc3BsaWNlKG5hbWUgPT09IFwic3RhZ2dlckZyb21Ub1wiID8gNSA6IDQsIDAsIDApO1xuICAgICAgcmV0dXJuIHRsW25hbWVdLmFwcGx5KHRsLCBwYXJhbXMpO1xuICAgIH07XG4gIH0pO1xuXG4gIHZhciBfc2V0dGVyUGxhaW4gPSBmdW5jdGlvbiBfc2V0dGVyUGxhaW4odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9LFxuICAgICAgX3NldHRlckZ1bmMgPSBmdW5jdGlvbiBfc2V0dGVyRnVuYyh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldKHZhbHVlKTtcbiAgfSxcbiAgICAgIF9zZXR0ZXJGdW5jV2l0aFBhcmFtID0gZnVuY3Rpb24gX3NldHRlckZ1bmNXaXRoUGFyYW0odGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XShkYXRhLmZwLCB2YWx1ZSk7XG4gIH0sXG4gICAgICBfc2V0dGVyQXR0cmlidXRlID0gZnVuY3Rpb24gX3NldHRlckF0dHJpYnV0ZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG4gIH0sXG4gICAgICBfZ2V0U2V0dGVyID0gZnVuY3Rpb24gX2dldFNldHRlcih0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIF9pc0Z1bmN0aW9uKHRhcmdldFtwcm9wZXJ0eV0pID8gX3NldHRlckZ1bmMgOiBfaXNVbmRlZmluZWQodGFyZ2V0W3Byb3BlcnR5XSkgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZSA/IF9zZXR0ZXJBdHRyaWJ1dGUgOiBfc2V0dGVyUGxhaW47XG4gIH0sXG4gICAgICBfcmVuZGVyUGxhaW4gPSBmdW5jdGlvbiBfcmVuZGVyUGxhaW4ocmF0aW8sIGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMDApIC8gMTAwMDAwMCwgZGF0YSk7XG4gIH0sXG4gICAgICBfcmVuZGVyQm9vbGVhbiA9IGZ1bmN0aW9uIF9yZW5kZXJCb29sZWFuKHJhdGlvLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAhIShkYXRhLnMgKyBkYXRhLmMgKiByYXRpbyksIGRhdGEpO1xuICB9LFxuICAgICAgX3JlbmRlckNvbXBsZXhTdHJpbmcgPSBmdW5jdGlvbiBfcmVuZGVyQ29tcGxleFN0cmluZyhyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgICBzID0gXCJcIjtcblxuICAgIGlmICghcmF0aW8gJiYgZGF0YS5iKSB7XG4gICAgICBzID0gZGF0YS5iO1xuICAgIH0gZWxzZSBpZiAocmF0aW8gPT09IDEgJiYgZGF0YS5lKSB7XG4gICAgICBzID0gZGF0YS5lO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocHQpIHtcbiAgICAgICAgcyA9IHB0LnAgKyAocHQubSA/IHB0Lm0ocHQucyArIHB0LmMgKiByYXRpbykgOiBNYXRoLnJvdW5kKChwdC5zICsgcHQuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwKSArIHM7XG4gICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICB9XG5cbiAgICAgIHMgKz0gZGF0YS5jO1xuICAgIH1cblxuICAgIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCBzLCBkYXRhKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3JlbmRlclByb3BUd2VlbnMocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cbiAgfSxcbiAgICAgIF9hZGRQbHVnaW5Nb2RpZmllciA9IGZ1bmN0aW9uIF9hZGRQbHVnaW5Nb2RpZmllcihtb2RpZmllciwgdHdlZW4sIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgICAgbmV4dDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgICAgcHQucCA9PT0gcHJvcGVydHkgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xuICAgICAgcHQgPSBuZXh0O1xuICAgIH1cbiAgfSxcbiAgICAgIF9raWxsUHJvcFR3ZWVuc09mID0gZnVuY3Rpb24gX2tpbGxQcm9wVHdlZW5zT2YocHJvcGVydHkpIHtcbiAgICB2YXIgcHQgPSB0aGlzLl9wdCxcbiAgICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLFxuICAgICAgICBuZXh0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICAgIGlmIChwdC5wID09PSBwcm9wZXJ0eSAmJiAhcHQub3AgfHwgcHQub3AgPT09IHByb3BlcnR5KSB7XG4gICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgICB9IGVsc2UgaWYgKCFwdC5kZXApIHtcbiAgICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nID0gMTtcbiAgICAgIH1cblxuICAgICAgcHQgPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiAhaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nO1xuICB9LFxuICAgICAgX3NldHRlcldpdGhNb2RpZmllciA9IGZ1bmN0aW9uIF9zZXR0ZXJXaXRoTW9kaWZpZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEpIHtcbiAgICBkYXRhLm1TZXQodGFyZ2V0LCBwcm9wZXJ0eSwgZGF0YS5tLmNhbGwoZGF0YS50d2VlbiwgdmFsdWUsIGRhdGEubXQpLCBkYXRhKTtcbiAgfSxcbiAgICAgIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkgPSBmdW5jdGlvbiBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5KHBhcmVudCkge1xuICAgIHZhciBwdCA9IHBhcmVudC5fcHQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIHB0MixcbiAgICAgICAgZmlyc3QsXG4gICAgICAgIGxhc3Q7XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIG5leHQgPSBwdC5fbmV4dDtcbiAgICAgIHB0MiA9IGZpcnN0O1xuXG4gICAgICB3aGlsZSAocHQyICYmIHB0Mi5wciA+IHB0LnByKSB7XG4gICAgICAgIHB0MiA9IHB0Mi5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHB0Ll9wcmV2ID0gcHQyID8gcHQyLl9wcmV2IDogbGFzdCkge1xuICAgICAgICBwdC5fcHJldi5fbmV4dCA9IHB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBwdDtcbiAgICAgIH1cblxuICAgICAgaWYgKHB0Ll9uZXh0ID0gcHQyKSB7XG4gICAgICAgIHB0Mi5fcHJldiA9IHB0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdCA9IHB0O1xuICAgICAgfVxuXG4gICAgICBwdCA9IG5leHQ7XG4gICAgfVxuXG4gICAgcGFyZW50Ll9wdCA9IGZpcnN0O1xuICB9O1xuXG4gIHZhciBQcm9wVHdlZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvcFR3ZWVuKG5leHQsIHRhcmdldCwgcHJvcCwgc3RhcnQsIGNoYW5nZSwgcmVuZGVyZXIsIGRhdGEsIHNldHRlciwgcHJpb3JpdHkpIHtcbiAgICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICAgIHRoaXMucyA9IHN0YXJ0O1xuICAgICAgdGhpcy5jID0gY2hhbmdlO1xuICAgICAgdGhpcy5wID0gcHJvcDtcbiAgICAgIHRoaXMuciA9IHJlbmRlcmVyIHx8IF9yZW5kZXJQbGFpbjtcbiAgICAgIHRoaXMuZCA9IGRhdGEgfHwgdGhpcztcbiAgICAgIHRoaXMuc2V0ID0gc2V0dGVyIHx8IF9zZXR0ZXJQbGFpbjtcbiAgICAgIHRoaXMucHIgPSBwcmlvcml0eSB8fCAwO1xuICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG5cbiAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgIG5leHQuX3ByZXYgPSB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfcHJvdG80ID0gUHJvcFR3ZWVuLnByb3RvdHlwZTtcblxuICAgIF9wcm90bzQubW9kaWZpZXIgPSBmdW5jdGlvbiBtb2RpZmllcihmdW5jLCB0d2VlbiwgdGFyZ2V0KSB7XG4gICAgICB0aGlzLm1TZXQgPSB0aGlzLm1TZXQgfHwgdGhpcy5zZXQ7XG4gICAgICB0aGlzLnNldCA9IF9zZXR0ZXJXaXRoTW9kaWZpZXI7XG4gICAgICB0aGlzLm0gPSBmdW5jO1xuICAgICAgdGhpcy5tdCA9IHRhcmdldDtcbiAgICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3BUd2VlbjtcbiAgfSgpO1xuXG4gIF9mb3JFYWNoTmFtZShfY2FsbGJhY2tOYW1lcyArIFwicGFyZW50LGR1cmF0aW9uLGVhc2UsZGVsYXksb3ZlcndyaXRlLHJ1bkJhY2t3YXJkcyxzdGFydEF0LHlveW8saW1tZWRpYXRlUmVuZGVyLHJlcGVhdCxyZXBlYXREZWxheSxkYXRhLHBhdXNlZCxyZXZlcnNlZCxsYXp5LGNhbGxiYWNrU2NvcGUsc3RyaW5nRmlsdGVyLGlkLHlveW9FYXNlLHN0YWdnZXIsaW5oZXJpdCxyZXBlYXRSZWZyZXNoLGtleWZyYW1lcyxhdXRvUmV2ZXJ0LHNjcm9sbFRyaWdnZXJcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gX3Jlc2VydmVkUHJvcHNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfZ2xvYmFscy5Ud2Vlbk1heCA9IF9nbG9iYWxzLlR3ZWVuTGl0ZSA9IFR3ZWVuO1xuICBfZ2xvYmFscy5UaW1lbGluZUxpdGUgPSBfZ2xvYmFscy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xuICBfZ2xvYmFsVGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgIHNvcnRDaGlsZHJlbjogZmFsc2UsXG4gICAgZGVmYXVsdHM6IF9kZWZhdWx0cyxcbiAgICBhdXRvUmVtb3ZlQ2hpbGRyZW46IHRydWUsXG4gICAgaWQ6IFwicm9vdFwiLFxuICAgIHNtb290aENoaWxkVGltaW5nOiB0cnVlXG4gIH0pO1xuICBfY29uZmlnLnN0cmluZ0ZpbHRlciA9IF9jb2xvclN0cmluZ0ZpbHRlcjtcblxuICB2YXIgX21lZGlhID0gW10sXG4gICAgICBfbGlzdGVuZXJzID0ge30sXG4gICAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgICAgX2xhc3RNZWRpYVRpbWUgPSAwLFxuICAgICAgX2NvbnRleHRJRCA9IDAsXG4gICAgICBfZGlzcGF0Y2ggPSBmdW5jdGlvbiBfZGlzcGF0Y2godHlwZSkge1xuICAgIHJldHVybiAoX2xpc3RlbmVyc1t0eXBlXSB8fCBfZW1wdHlBcnJheSkubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gZigpO1xuICAgIH0pO1xuICB9LFxuICAgICAgX29uTWVkaWFDaGFuZ2UgPSBmdW5jdGlvbiBfb25NZWRpYUNoYW5nZSgpIHtcbiAgICB2YXIgdGltZSA9IERhdGUubm93KCksXG4gICAgICAgIG1hdGNoZXMgPSBbXTtcblxuICAgIGlmICh0aW1lIC0gX2xhc3RNZWRpYVRpbWUgPiAyKSB7XG4gICAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhSW5pdFwiKTtcblxuICAgICAgX21lZGlhLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHF1ZXJpZXMgPSBjLnF1ZXJpZXMsXG4gICAgICAgICAgICBjb25kaXRpb25zID0gYy5jb25kaXRpb25zLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgYW55TWF0Y2gsXG4gICAgICAgICAgICB0b2dnbGVkO1xuXG4gICAgICAgIGZvciAocCBpbiBxdWVyaWVzKSB7XG4gICAgICAgICAgbWF0Y2ggPSBfd2luLm1hdGNoTWVkaWEocXVlcmllc1twXSkubWF0Y2hlcztcbiAgICAgICAgICBtYXRjaCAmJiAoYW55TWF0Y2ggPSAxKTtcblxuICAgICAgICAgIGlmIChtYXRjaCAhPT0gY29uZGl0aW9uc1twXSkge1xuICAgICAgICAgICAgY29uZGl0aW9uc1twXSA9IG1hdGNoO1xuICAgICAgICAgICAgdG9nZ2xlZCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvZ2dsZWQpIHtcbiAgICAgICAgICBjLnJldmVydCgpO1xuICAgICAgICAgIGFueU1hdGNoICYmIG1hdGNoZXMucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFSZXZlcnRcIik7XG5cbiAgICAgIG1hdGNoZXMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5vbk1hdGNoKGMsIGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGMuYWRkKG51bGwsIGZ1bmMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgX2xhc3RNZWRpYVRpbWUgPSB0aW1lO1xuXG4gICAgICBfZGlzcGF0Y2goXCJtYXRjaE1lZGlhXCIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb250ZXh0KGZ1bmMsIHNjb3BlKSB7XG4gICAgICB0aGlzLnNlbGVjdG9yID0gc2NvcGUgJiYgc2VsZWN0b3Ioc2NvcGUpO1xuICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICB0aGlzLl9yID0gW107XG4gICAgICB0aGlzLmlzUmV2ZXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaWQgPSBfY29udGV4dElEKys7XG4gICAgICBmdW5jICYmIHRoaXMuYWRkKGZ1bmMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG81ID0gQ29udGV4dC5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG81LmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBmdW5jLCBzY29wZSkge1xuICAgICAgaWYgKF9pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgIHNjb3BlID0gZnVuYztcbiAgICAgICAgZnVuYyA9IG5hbWU7XG4gICAgICAgIG5hbWUgPSBfaXNGdW5jdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKCkge1xuICAgICAgICB2YXIgcHJldiA9IF9jb250ZXh0LFxuICAgICAgICAgICAgcHJldlNlbGVjdG9yID0gc2VsZi5zZWxlY3RvcixcbiAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgcHJldiAmJiBwcmV2ICE9PSBzZWxmICYmIHByZXYuZGF0YS5wdXNoKHNlbGYpO1xuICAgICAgICBzY29wZSAmJiAoc2VsZi5zZWxlY3RvciA9IHNlbGVjdG9yKHNjb3BlKSk7XG4gICAgICAgIF9jb250ZXh0ID0gc2VsZjtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICBfaXNGdW5jdGlvbihyZXN1bHQpICYmIHNlbGYuX3IucHVzaChyZXN1bHQpO1xuICAgICAgICBfY29udGV4dCA9IHByZXY7XG4gICAgICAgIHNlbGYuc2VsZWN0b3IgPSBwcmV2U2VsZWN0b3I7XG4gICAgICAgIHNlbGYuaXNSZXZlcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgc2VsZi5sYXN0ID0gZjtcbiAgICAgIHJldHVybiBuYW1lID09PSBfaXNGdW5jdGlvbiA/IGYoc2VsZiwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYWRkKG51bGwsIGZ1bmMpO1xuICAgICAgfSkgOiBuYW1lID8gc2VsZltuYW1lXSA9IGYgOiBmO1xuICAgIH07XG5cbiAgICBfcHJvdG81Lmlnbm9yZSA9IGZ1bmN0aW9uIGlnbm9yZShmdW5jKSB7XG4gICAgICB2YXIgcHJldiA9IF9jb250ZXh0O1xuICAgICAgX2NvbnRleHQgPSBudWxsO1xuICAgICAgZnVuYyh0aGlzKTtcbiAgICAgIF9jb250ZXh0ID0gcHJldjtcbiAgICB9O1xuXG4gICAgX3Byb3RvNS5nZXRUd2VlbnMgPSBmdW5jdGlvbiBnZXRUd2VlbnMoKSB7XG4gICAgICB2YXIgYSA9IFtdO1xuICAgICAgdGhpcy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBDb250ZXh0ID8gYS5wdXNoLmFwcGx5KGEsIGUuZ2V0VHdlZW5zKCkpIDogZSBpbnN0YW5jZW9mIFR3ZWVuICYmICEoZS5wYXJlbnQgJiYgZS5wYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIikgJiYgYS5wdXNoKGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgX3Byb3RvNS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5fci5sZW5ndGggPSB0aGlzLmRhdGEubGVuZ3RoID0gMDtcbiAgICB9O1xuXG4gICAgX3Byb3RvNS5raWxsID0gZnVuY3Rpb24ga2lsbChyZXZlcnQsIG1hdGNoTWVkaWEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICBpZiAocmV2ZXJ0KSB7XG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHR3ZWVucyA9IF90aGlzNC5nZXRUd2VlbnMoKSxcbiAgICAgICAgICAgICAgaSA9IF90aGlzNC5kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgdDtcblxuICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHQgPSBfdGhpczQuZGF0YVtpXTtcblxuICAgICAgICAgICAgaWYgKHQuZGF0YSA9PT0gXCJpc0ZsaXBcIikge1xuICAgICAgICAgICAgICB0LnJldmVydCgpO1xuICAgICAgICAgICAgICB0LmdldENoaWxkcmVuKHRydWUsIHRydWUsIGZhbHNlKS5mb3JFYWNoKGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0d2VlbnMuc3BsaWNlKHR3ZWVucy5pbmRleE9mKHR3ZWVuKSwgMSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVucy5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGc6IHQuX2R1ciB8fCB0Ll9kZWxheSB8fCB0Ll9zYXQgJiYgIXQuX3NhdC52YXJzLmltbWVkaWF0ZVJlbmRlciA/IHQuZ2xvYmFsVGltZSgwKSA6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgdDogdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5nIC0gYS5nIHx8IC1JbmZpbml0eTtcbiAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICByZXR1cm4gby50LnJldmVydChyZXZlcnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGkgPSBfdGhpczQuZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB0ID0gX3RoaXM0LmRhdGFbaV07XG5cbiAgICAgICAgICAgIGlmICh0IGluc3RhbmNlb2YgVGltZWxpbmUpIHtcbiAgICAgICAgICAgICAgaWYgKHQuZGF0YSAhPT0gXCJuZXN0ZWRcIikge1xuICAgICAgICAgICAgICAgIHQuc2Nyb2xsVHJpZ2dlciAmJiB0LnNjcm9sbFRyaWdnZXIucmV2ZXJ0KCk7XG4gICAgICAgICAgICAgICAgdC5raWxsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICEodCBpbnN0YW5jZW9mIFR3ZWVuKSAmJiB0LnJldmVydCAmJiB0LnJldmVydChyZXZlcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNC5fci5mb3JFYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICByZXR1cm4gZihyZXZlcnQsIF90aGlzNCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBfdGhpczQuaXNSZXZlcnRlZCA9IHRydWU7XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiBlLmtpbGwgJiYgZS5raWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgIGlmIChtYXRjaE1lZGlhKSB7XG4gICAgICAgIHZhciBpID0gX21lZGlhLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgX21lZGlhW2ldLmlkID09PSB0aGlzLmlkICYmIF9tZWRpYS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvNS5yZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoY29uZmlnKSB7XG4gICAgICB0aGlzLmtpbGwoY29uZmlnIHx8IHt9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnRleHQ7XG4gIH0oKTtcblxuICB2YXIgTWF0Y2hNZWRpYSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRjaE1lZGlhKHNjb3BlKSB7XG4gICAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgICBfY29udGV4dCAmJiBfY29udGV4dC5kYXRhLnB1c2godGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzYgPSBNYXRjaE1lZGlhLnByb3RvdHlwZTtcblxuICAgIF9wcm90bzYuYWRkID0gZnVuY3Rpb24gYWRkKGNvbmRpdGlvbnMsIGZ1bmMsIHNjb3BlKSB7XG4gICAgICBfaXNPYmplY3QoY29uZGl0aW9ucykgfHwgKGNvbmRpdGlvbnMgPSB7XG4gICAgICAgIG1hdGNoZXM6IGNvbmRpdGlvbnNcbiAgICAgIH0pO1xuICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dCgwLCBzY29wZSB8fCB0aGlzLnNjb3BlKSxcbiAgICAgICAgICBjb25kID0gY29udGV4dC5jb25kaXRpb25zID0ge30sXG4gICAgICAgICAgbXEsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBhY3RpdmU7XG4gICAgICBfY29udGV4dCAmJiAhY29udGV4dC5zZWxlY3RvciAmJiAoY29udGV4dC5zZWxlY3RvciA9IF9jb250ZXh0LnNlbGVjdG9yKTtcbiAgICAgIHRoaXMuY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgICAgIGZ1bmMgPSBjb250ZXh0LmFkZChcIm9uTWF0Y2hcIiwgZnVuYyk7XG4gICAgICBjb250ZXh0LnF1ZXJpZXMgPSBjb25kaXRpb25zO1xuXG4gICAgICBmb3IgKHAgaW4gY29uZGl0aW9ucykge1xuICAgICAgICBpZiAocCA9PT0gXCJhbGxcIikge1xuICAgICAgICAgIGFjdGl2ZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXEgPSBfd2luLm1hdGNoTWVkaWEoY29uZGl0aW9uc1twXSk7XG5cbiAgICAgICAgICBpZiAobXEpIHtcbiAgICAgICAgICAgIF9tZWRpYS5pbmRleE9mKGNvbnRleHQpIDwgMCAmJiBfbWVkaWEucHVzaChjb250ZXh0KTtcbiAgICAgICAgICAgIChjb25kW3BdID0gbXEubWF0Y2hlcykgJiYgKGFjdGl2ZSA9IDEpO1xuICAgICAgICAgICAgbXEuYWRkTGlzdGVuZXIgPyBtcS5hZGRMaXN0ZW5lcihfb25NZWRpYUNoYW5nZSkgOiBtcS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIF9vbk1lZGlhQ2hhbmdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWN0aXZlICYmIGZ1bmMoY29udGV4dCwgZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuYWRkKG51bGwsIGYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgX3Byb3RvNi5yZXZlcnQgPSBmdW5jdGlvbiByZXZlcnQoY29uZmlnKSB7XG4gICAgICB0aGlzLmtpbGwoY29uZmlnIHx8IHt9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvNi5raWxsID0gZnVuY3Rpb24ga2lsbChyZXZlcnQpIHtcbiAgICAgIHRoaXMuY29udGV4dHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy5raWxsKHJldmVydCwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hdGNoTWVkaWE7XG4gIH0oKTtcblxuICB2YXIgX2dzYXAgPSB7XG4gICAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVQbHVnaW4oY29uZmlnKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgdGltZWxpbmU6IGZ1bmN0aW9uIHRpbWVsaW5lKHZhcnMpIHtcbiAgICAgIHJldHVybiBuZXcgVGltZWxpbmUodmFycyk7XG4gICAgfSxcbiAgICBnZXRUd2VlbnNPZjogZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKTtcbiAgICB9LFxuICAgIGdldFByb3BlcnR5OiBmdW5jdGlvbiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgICBfaXNTdHJpbmcodGFyZ2V0KSAmJiAodGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpWzBdKTtcblxuICAgICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgICBmb3JtYXQgPSB1bml0ID8gX3Bhc3NUaHJvdWdoIDogX251bWVyaWNJZlBvc3NpYmxlO1xuXG4gICAgICB1bml0ID09PSBcIm5hdGl2ZVwiICYmICh1bml0ID0gXCJcIik7XG4gICAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0KChfcGx1Z2luc1twcm9wZXJ0eV0gJiYgX3BsdWdpbnNbcHJvcGVydHldLmdldCB8fCBnZXR0ZXIpKHRhcmdldCwgcHJvcGVydHksIHVuaXQsIHVuY2FjaGUpKTtcbiAgICAgIH0gOiBmb3JtYXQoKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiBfcGx1Z2luc1twcm9wZXJ0eV0uZ2V0IHx8IGdldHRlcikodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkpO1xuICAgIH0sXG4gICAgcXVpY2tTZXR0ZXI6IGZ1bmN0aW9uIHF1aWNrU2V0dGVyKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHtcbiAgICAgIHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KTtcblxuICAgICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHZhciBzZXR0ZXJzID0gdGFyZ2V0Lm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBnc2FwLnF1aWNrU2V0dGVyKHQsIHByb3BlcnR5LCB1bml0KTtcbiAgICAgICAgfSksXG4gICAgICAgICAgICBsID0gc2V0dGVycy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBzZXR0ZXJzW2ldKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgICAgdmFyIFBsdWdpbiA9IF9wbHVnaW5zW3Byb3BlcnR5XSxcbiAgICAgICAgICBjYWNoZSA9IF9nZXRDYWNoZSh0YXJnZXQpLFxuICAgICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcbiAgICAgICAgICBzZXR0ZXIgPSBQbHVnaW4gPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgUGx1Z2luKCk7XG4gICAgICAgIF9xdWlja1R3ZWVuLl9wdCA9IDA7XG4gICAgICAgIHAuaW5pdCh0YXJnZXQsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgX3F1aWNrVHdlZW4sIDAsIFt0YXJnZXRdKTtcbiAgICAgICAgcC5yZW5kZXIoMSwgcCk7XG4gICAgICAgIF9xdWlja1R3ZWVuLl9wdCAmJiBfcmVuZGVyUHJvcFR3ZWVucygxLCBfcXVpY2tUd2Vlbik7XG4gICAgICB9IDogY2FjaGUuc2V0KHRhcmdldCwgcCk7XG5cbiAgICAgIHJldHVybiBQbHVnaW4gPyBzZXR0ZXIgOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHNldHRlcih0YXJnZXQsIHAsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgY2FjaGUsIDEpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIHF1aWNrVG86IGZ1bmN0aW9uIHF1aWNrVG8odGFyZ2V0LCBwcm9wZXJ0eSwgdmFycykge1xuICAgICAgdmFyIF9zZXREZWZhdWx0czI7XG5cbiAgICAgIHZhciB0d2VlbiA9IGdzYXAudG8odGFyZ2V0LCBfc2V0RGVmYXVsdHMoKF9zZXREZWZhdWx0czIgPSB7fSwgX3NldERlZmF1bHRzMltwcm9wZXJ0eV0gPSBcIis9MC4xXCIsIF9zZXREZWZhdWx0czIucGF1c2VkID0gdHJ1ZSwgX3NldERlZmF1bHRzMi5zdGFnZ2VyID0gMCwgX3NldERlZmF1bHRzMiksIHZhcnMgfHwge30pKSxcbiAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyh2YWx1ZSwgc3RhcnQsIHN0YXJ0SXNSZWxhdGl2ZSkge1xuICAgICAgICByZXR1cm4gdHdlZW4ucmVzZXRUbyhwcm9wZXJ0eSwgdmFsdWUsIHN0YXJ0LCBzdGFydElzUmVsYXRpdmUpO1xuICAgICAgfTtcblxuICAgICAgZnVuYy50d2VlbiA9IHR3ZWVuO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfSxcbiAgICBpc1R3ZWVuaW5nOiBmdW5jdGlvbiBpc1R3ZWVuaW5nKHRhcmdldHMpIHtcbiAgICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgdHJ1ZSkubGVuZ3RoID4gMDtcbiAgICB9LFxuICAgIGRlZmF1bHRzOiBmdW5jdGlvbiBkZWZhdWx0cyh2YWx1ZSkge1xuICAgICAgdmFsdWUgJiYgdmFsdWUuZWFzZSAmJiAodmFsdWUuZWFzZSA9IF9wYXJzZUVhc2UodmFsdWUuZWFzZSwgX2RlZmF1bHRzLmVhc2UpKTtcbiAgICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICAgIH0sXG4gICAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcodmFsdWUpIHtcbiAgICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyRWZmZWN0OiBmdW5jdGlvbiByZWdpc3RlckVmZmVjdChfcmVmMykge1xuICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdCxcbiAgICAgICAgICBwbHVnaW5zID0gX3JlZjMucGx1Z2lucyxcbiAgICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICAgIGV4dGVuZFRpbWVsaW5lID0gX3JlZjMuZXh0ZW5kVGltZWxpbmU7XG4gICAgICAocGx1Z2lucyB8fCBcIlwiKS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luTmFtZSkge1xuICAgICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICAgIH0pO1xuXG4gICAgICBfZWZmZWN0c1tuYW1lXSA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzLCB0bCkge1xuICAgICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChleHRlbmRUaW1lbGluZSkge1xuICAgICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoX2VmZmVjdHNbbmFtZV0odGFyZ2V0cywgX2lzT2JqZWN0KHZhcnMpID8gdmFycyA6IChwb3NpdGlvbiA9IHZhcnMpICYmIHt9LCB0aGlzKSwgcG9zaXRpb24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVnaXN0ZXJFYXNlOiBmdW5jdGlvbiByZWdpc3RlckVhc2UobmFtZSwgZWFzZSkge1xuICAgICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICAgIH0sXG4gICAgcGFyc2VFYXNlOiBmdW5jdGlvbiBwYXJzZUVhc2UoZWFzZSwgZGVmYXVsdEVhc2UpIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgICB9LFxuICAgIGdldEJ5SWQ6IGZ1bmN0aW9uIGdldEJ5SWQoaWQpIHtcbiAgICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gICAgfSxcbiAgICBleHBvcnRSb290OiBmdW5jdGlvbiBleHBvcnRSb290KHZhcnMsIGluY2x1ZGVEZWxheWVkQ2FsbHMpIHtcbiAgICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFycyA9IHt9O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgICAgY2hpbGQsXG4gICAgICAgICAgbmV4dDtcbiAgICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICAgIF9nbG9iYWxUaW1lbGluZS5yZW1vdmUodGwpO1xuXG4gICAgICB0bC5fZHAgPSAwO1xuICAgICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgICBjaGlsZCA9IF9nbG9iYWxUaW1lbGluZS5fZmlyc3Q7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVEZWxheWVkQ2FsbHMgfHwgISghY2hpbGQuX2R1ciAmJiBjaGlsZCBpbnN0YW5jZW9mIFR3ZWVuICYmIGNoaWxkLnZhcnMub25Db21wbGV0ZSA9PT0gY2hpbGQuX3RhcmdldHNbMF0pKSB7XG4gICAgICAgICAgX2FkZFRvVGltZWxpbmUodGwsIGNoaWxkLCBjaGlsZC5fc3RhcnQgLSBjaGlsZC5fZGVsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgPSBuZXh0O1xuICAgICAgfVxuXG4gICAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgICAgcmV0dXJuIHRsO1xuICAgIH0sXG4gICAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dChmdW5jLCBzY29wZSkge1xuICAgICAgcmV0dXJuIGZ1bmMgPyBuZXcgQ29udGV4dChmdW5jLCBzY29wZSkgOiBfY29udGV4dDtcbiAgICB9LFxuICAgIG1hdGNoTWVkaWE6IGZ1bmN0aW9uIG1hdGNoTWVkaWEoc2NvcGUpIHtcbiAgICAgIHJldHVybiBuZXcgTWF0Y2hNZWRpYShzY29wZSk7XG4gICAgfSxcbiAgICBtYXRjaE1lZGlhUmVmcmVzaDogZnVuY3Rpb24gbWF0Y2hNZWRpYVJlZnJlc2goKSB7XG4gICAgICByZXR1cm4gX21lZGlhLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIGNvbmQgPSBjLmNvbmRpdGlvbnMsXG4gICAgICAgICAgICBmb3VuZCxcbiAgICAgICAgICAgIHA7XG5cbiAgICAgICAgZm9yIChwIGluIGNvbmQpIHtcbiAgICAgICAgICBpZiAoY29uZFtwXSkge1xuICAgICAgICAgICAgY29uZFtwXSA9IGZhbHNlO1xuICAgICAgICAgICAgZm91bmQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvdW5kICYmIGMucmV2ZXJ0KCk7XG4gICAgICB9KSB8fCBfb25NZWRpYUNoYW5nZSgpO1xuICAgIH0sXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdIHx8IChfbGlzdGVuZXJzW3R5cGVdID0gW10pO1xuICAgICAgfmEuaW5kZXhPZihjYWxsYmFjaykgfHwgYS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBhID0gX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgICAgICBpID0gYSAmJiBhLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgaSA+PSAwICYmIGEuc3BsaWNlKGksIDEpO1xuICAgIH0sXG4gICAgdXRpbHM6IHtcbiAgICAgIHdyYXA6IHdyYXAsXG4gICAgICB3cmFwWW95bzogd3JhcFlveW8sXG4gICAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgICAgcmFuZG9tOiByYW5kb20sXG4gICAgICBzbmFwOiBzbmFwLFxuICAgICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgICBnZXRVbml0OiBnZXRVbml0LFxuICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgICBwaXBlOiBwaXBlLFxuICAgICAgdW5pdGl6ZTogdW5pdGl6ZSxcbiAgICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICAgIHNodWZmbGU6IHNodWZmbGVcbiAgICB9LFxuICAgIGluc3RhbGw6IF9pbnN0YWxsLFxuICAgIGVmZmVjdHM6IF9lZmZlY3RzLFxuICAgIHRpY2tlcjogX3RpY2tlcixcbiAgICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICAgIHBsdWdpbnM6IF9wbHVnaW5zLFxuICAgIGdsb2JhbFRpbWVsaW5lOiBfZ2xvYmFsVGltZWxpbmUsXG4gICAgY29yZToge1xuICAgICAgUHJvcFR3ZWVuOiBQcm9wVHdlZW4sXG4gICAgICBnbG9iYWxzOiBfYWRkR2xvYmFsLFxuICAgICAgVHdlZW46IFR3ZWVuLFxuICAgICAgVGltZWxpbmU6IFRpbWVsaW5lLFxuICAgICAgQW5pbWF0aW9uOiBBbmltYXRpb24sXG4gICAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtOiBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sXG4gICAgICByZXZlcnRpbmc6IGZ1bmN0aW9uIHJldmVydGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9yZXZlcnRpbmc7XG4gICAgICB9LFxuICAgICAgY29udGV4dDogZnVuY3Rpb24gY29udGV4dCh0b0FkZCkge1xuICAgICAgICBpZiAodG9BZGQgJiYgX2NvbnRleHQpIHtcbiAgICAgICAgICBfY29udGV4dC5kYXRhLnB1c2godG9BZGQpO1xuXG4gICAgICAgICAgdG9BZGQuX2N0eCA9IF9jb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jb250ZXh0O1xuICAgICAgfSxcbiAgICAgIHN1cHByZXNzT3ZlcndyaXRlczogZnVuY3Rpb24gc3VwcHJlc3NPdmVyd3JpdGVzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfc3VwcHJlc3NPdmVyd3JpdGVzID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9mb3JFYWNoTmFtZShcInRvLGZyb20sZnJvbVRvLGRlbGF5ZWRDYWxsLHNldCxraWxsVHdlZW5zT2ZcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcbiAgfSk7XG5cbiAgX3RpY2tlci5hZGQoVGltZWxpbmUudXBkYXRlUm9vdCk7XG5cbiAgX3F1aWNrVHdlZW4gPSBfZ3NhcC50byh7fSwge1xuICAgIGR1cmF0aW9uOiAwXG4gIH0pO1xuXG4gIHZhciBfZ2V0UGx1Z2luUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2dldFBsdWdpblByb3BUd2VlbihwbHVnaW4sIHByb3ApIHtcbiAgICB2YXIgcHQgPSBwbHVnaW4uX3B0O1xuXG4gICAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0O1xuICB9LFxuICAgICAgX2FkZE1vZGlmaWVycyA9IGZ1bmN0aW9uIF9hZGRNb2RpZmllcnModHdlZW4sIG1vZGlmaWVycykge1xuICAgIHZhciB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICAgIHAsXG4gICAgICAgIGksXG4gICAgICAgIHB0O1xuXG4gICAgZm9yIChwIGluIG1vZGlmaWVycykge1xuICAgICAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHB0ID0gdHdlZW4uX3B0TG9va3VwW2ldW3BdO1xuXG4gICAgICAgIGlmIChwdCAmJiAocHQgPSBwdC5kKSkge1xuICAgICAgICAgIGlmIChwdC5fcHQpIHtcbiAgICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHQgJiYgcHQubW9kaWZpZXIgJiYgcHQubW9kaWZpZXIobW9kaWZpZXJzW3BdLCB0d2VlbiwgdGFyZ2V0c1tpXSwgcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICAgICBfYnVpbGRNb2RpZmllclBsdWdpbiA9IGZ1bmN0aW9uIF9idWlsZE1vZGlmaWVyUGx1Z2luKG5hbWUsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBoZWFkbGVzczogMSxcbiAgICAgIHJhd1ZhcnM6IDEsXG4gICAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcbiAgICAgICAgdHdlZW4uX29uSW5pdCA9IGZ1bmN0aW9uICh0d2Vlbikge1xuICAgICAgICAgIHZhciB0ZW1wLCBwO1xuXG4gICAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgICBfZm9yRWFjaE5hbWUodmFycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRlbXBbbmFtZV0gPSAxO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtb2RpZmllcikge1xuICAgICAgICAgICAgdGVtcCA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgICB0ZW1wW3BdID0gbW9kaWZpZXIodmFyc1twXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9hZGRNb2RpZmllcnModHdlZW4sIHZhcnMpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgdmFyIGdzYXAgPSBfZ3NhcC5yZWdpc3RlclBsdWdpbih7XG4gICAgbmFtZTogXCJhdHRyXCIsXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgICAgdmFyIHAsIHB0LCB2O1xuICAgICAgdGhpcy50d2VlbiA9IHR3ZWVuO1xuXG4gICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICB2ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShwKSB8fCBcIlwiO1xuICAgICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHYgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICAgIHB0Lm9wID0gcDtcbiAgICAgICAgcHQuYiA9IHY7XG5cbiAgICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgICB2YXIgcHQgPSBkYXRhLl9wdDtcblxuICAgICAgd2hpbGUgKHB0KSB7XG4gICAgICAgIF9yZXZlcnRpbmcgPyBwdC5zZXQocHQudCwgcHQucCwgcHQuYiwgcHQpIDogcHQucihyYXRpbywgcHQuZCk7XG4gICAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAgbmFtZTogXCJlbmRBcnJheVwiLFxuICAgIGhlYWRsZXNzOiAxLFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZSkge1xuICAgICAgdmFyIGkgPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBpLCB0YXJnZXRbaV0gfHwgMCwgdmFsdWVbaV0sIDAsIDAsIDAsIDAsIDAsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJyb3VuZFByb3BzXCIsIF9yb3VuZE1vZGlmaWVyKSwgX2J1aWxkTW9kaWZpZXJQbHVnaW4oXCJtb2RpZmllcnNcIiksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwic25hcFwiLCBzbmFwKSkgfHwgX2dzYXA7XG4gIFR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjEzLjBcIjtcbiAgX2NvcmVSZWFkeSA9IDE7XG4gIF93aW5kb3dFeGlzdHMoKSAmJiBfd2FrZSgpO1xuICB2YXIgUG93ZXIwID0gX2Vhc2VNYXAuUG93ZXIwLFxuICAgICAgUG93ZXIxID0gX2Vhc2VNYXAuUG93ZXIxLFxuICAgICAgUG93ZXIyID0gX2Vhc2VNYXAuUG93ZXIyLFxuICAgICAgUG93ZXIzID0gX2Vhc2VNYXAuUG93ZXIzLFxuICAgICAgUG93ZXI0ID0gX2Vhc2VNYXAuUG93ZXI0LFxuICAgICAgTGluZWFyID0gX2Vhc2VNYXAuTGluZWFyLFxuICAgICAgUXVhZCA9IF9lYXNlTWFwLlF1YWQsXG4gICAgICBDdWJpYyA9IF9lYXNlTWFwLkN1YmljLFxuICAgICAgUXVhcnQgPSBfZWFzZU1hcC5RdWFydCxcbiAgICAgIFF1aW50ID0gX2Vhc2VNYXAuUXVpbnQsXG4gICAgICBTdHJvbmcgPSBfZWFzZU1hcC5TdHJvbmcsXG4gICAgICBFbGFzdGljID0gX2Vhc2VNYXAuRWxhc3RpYyxcbiAgICAgIEJhY2sgPSBfZWFzZU1hcC5CYWNrLFxuICAgICAgU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5TdGVwcGVkRWFzZSxcbiAgICAgIEJvdW5jZSA9IF9lYXNlTWFwLkJvdW5jZSxcbiAgICAgIFNpbmUgPSBfZWFzZU1hcC5TaW5lLFxuICAgICAgRXhwbyA9IF9lYXNlTWFwLkV4cG8sXG4gICAgICBDaXJjID0gX2Vhc2VNYXAuQ2lyYztcblxuICB2YXIgX3dpbiQxLFxuICAgICAgX2RvYyQxLFxuICAgICAgX2RvY0VsZW1lbnQsXG4gICAgICBfcGx1Z2luSW5pdHRlZCxcbiAgICAgIF90ZW1wRGl2LFxuICAgICAgX3RlbXBEaXZTdHlsZXIsXG4gICAgICBfcmVjZW50U2V0dGVyUGx1Z2luLFxuICAgICAgX3JldmVydGluZyQxLFxuICAgICAgX3dpbmRvd0V4aXN0cyQxID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgfSxcbiAgICAgIF90cmFuc2Zvcm1Qcm9wcyA9IHt9LFxuICAgICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgICAgX2F0YW4yID0gTWF0aC5hdGFuMixcbiAgICAgIF9iaWdOdW0kMSA9IDFlOCxcbiAgICAgIF9jYXBzRXhwID0gLyhbQS1aXSkvZyxcbiAgICAgIF9ob3Jpem9udGFsRXhwID0gLyhsZWZ0fHJpZ2h0fHdpZHRofG1hcmdpbnxwYWRkaW5nfHgpL2ksXG4gICAgICBfY29tcGxleEV4cCA9IC9bXFxzLFxcKF1cXFMvLFxuICAgICAgX3Byb3BlcnR5QWxpYXNlcyA9IHtcbiAgICBhdXRvQWxwaGE6IFwib3BhY2l0eSx2aXNpYmlsaXR5XCIsXG4gICAgc2NhbGU6IFwic2NhbGVYLHNjYWxlWVwiLFxuICAgIGFscGhhOiBcIm9wYWNpdHlcIlxuICB9LFxuICAgICAgX3JlbmRlckNTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xuICB9LFxuICAgICAgX3JlbmRlclByb3BXaXRoRW5kID0gZnVuY3Rpb24gX3JlbmRlclByb3BXaXRoRW5kKHJhdGlvLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZyhyYXRpbywgZGF0YSkge1xuICAgIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSA6IGRhdGEuYiwgZGF0YSk7XG4gIH0sXG4gICAgICBfcmVuZGVyUm91bmRlZENTU1Byb3AgPSBmdW5jdGlvbiBfcmVuZGVyUm91bmRlZENTU1Byb3AocmF0aW8sIGRhdGEpIHtcbiAgICB2YXIgdmFsdWUgPSBkYXRhLnMgKyBkYXRhLmMgKiByYXRpbztcbiAgICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgfn4odmFsdWUgKyAodmFsdWUgPCAwID8gLS41IDogLjUpKSArIGRhdGEudSwgZGF0YSk7XG4gIH0sXG4gICAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKHJhdGlvLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYiwgZGF0YSk7XG4gIH0sXG4gICAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kKHJhdGlvLCBkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyAhPT0gMSA/IGRhdGEuYiA6IGRhdGEuZSwgZGF0YSk7XG4gIH0sXG4gICAgICBfc2V0dGVyQ1NTU3R5bGUgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTU3R5bGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICB9LFxuICAgICAgX3NldHRlckNTU1Byb3AgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTUHJvcCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgfSxcbiAgICAgIF9zZXR0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRhcmdldC5fZ3NhcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfSxcbiAgICAgIF9zZXR0ZXJTY2FsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0YXJnZXQuX2dzYXAuc2NhbGVYID0gdGFyZ2V0Ll9nc2FwLnNjYWxlWSA9IHZhbHVlO1xuICB9LFxuICAgICAgX3NldHRlclNjYWxlV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gICAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgIGNhY2hlLnNjYWxlWCA9IGNhY2hlLnNjYWxlWSA9IHZhbHVlO1xuICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xuICB9LFxuICAgICAgX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIgPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlcih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSwgcmF0aW8pIHtcbiAgICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gICAgY2FjaGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKHJhdGlvLCBjYWNoZSk7XG4gIH0sXG4gICAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgICBfdHJhbnNmb3JtT3JpZ2luUHJvcCA9IF90cmFuc2Zvcm1Qcm9wICsgXCJPcmlnaW5cIixcbiAgICAgIF9zYXZlU3R5bGUgPSBmdW5jdGlvbiBfc2F2ZVN0eWxlKHByb3BlcnR5LCBpc05vdENTUykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcblxuICAgIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgc3R5bGUpIHtcbiAgICAgIHRoaXMudGZtID0gdGhpcy50Zm0gfHwge307XG5cbiAgICAgIGlmIChwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldIHx8IHByb3BlcnR5O1xuICAgICAgICB+cHJvcGVydHkuaW5kZXhPZihcIixcIikgPyBwcm9wZXJ0eS5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy50Zm1bYV0gPSBfZ2V0KHRhcmdldCwgYSk7XG4gICAgICAgIH0pIDogdGhpcy50Zm1bcHJvcGVydHldID0gY2FjaGUueCA/IGNhY2hlW3Byb3BlcnR5XSA6IF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICAgIHByb3BlcnR5ID09PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGhpcy50Zm0uek9yaWdpbiA9IGNhY2hlLnpPcmlnaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIF9wcm9wZXJ0eUFsaWFzZXMudHJhbnNmb3JtLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIF9zYXZlU3R5bGUuY2FsbChfdGhpcywgcCwgaXNOb3RDU1MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJvcHMuaW5kZXhPZihfdHJhbnNmb3JtUHJvcCkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgdGhpcy5zdmdvID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiKTtcbiAgICAgICAgdGhpcy5wcm9wcy5wdXNoKF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCBpc05vdENTUywgXCJcIik7XG4gICAgICB9XG5cbiAgICAgIHByb3BlcnR5ID0gX3RyYW5zZm9ybVByb3A7XG4gICAgfVxuXG4gICAgKHN0eWxlIHx8IGlzTm90Q1NTKSAmJiB0aGlzLnByb3BzLnB1c2gocHJvcGVydHksIGlzTm90Q1NTLCBzdHlsZVtwcm9wZXJ0eV0pO1xuICB9LFxuICAgICAgX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMoc3R5bGUpIHtcbiAgICBpZiAoc3R5bGUudHJhbnNsYXRlKSB7XG4gICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInRyYW5zbGF0ZVwiKTtcbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KFwic2NhbGVcIik7XG4gICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShcInJvdGF0ZVwiKTtcbiAgICB9XG4gIH0sXG4gICAgICBfcmV2ZXJ0U3R5bGUgPSBmdW5jdGlvbiBfcmV2ZXJ0U3R5bGUoKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgaSxcbiAgICAgICAgcDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgaWYgKCFwcm9wc1tpICsgMV0pIHtcbiAgICAgICAgcHJvcHNbaSArIDJdID8gc3R5bGVbcHJvcHNbaV1dID0gcHJvcHNbaSArIDJdIDogc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcHNbaV0uc3Vic3RyKDAsIDIpID09PSBcIi0tXCIgPyBwcm9wc1tpXSA6IHByb3BzW2ldLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wc1tpICsgMV0gPT09IDIpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BzW2ldXShwcm9wc1tpICsgMl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BzW2ldXSA9IHByb3BzW2kgKyAyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy50Zm0pIHtcbiAgICAgIGZvciAocCBpbiB0aGlzLnRmbSkge1xuICAgICAgICBjYWNoZVtwXSA9IHRoaXMudGZtW3BdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHRoaXMuc3ZnbyB8fCBcIlwiKTtcbiAgICAgIH1cblxuICAgICAgaSA9IF9yZXZlcnRpbmckMSgpO1xuXG4gICAgICBpZiAoKCFpIHx8ICFpLmlzU3RhcnQpICYmICFzdHlsZVtfdHJhbnNmb3JtUHJvcF0pIHtcbiAgICAgICAgX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyhzdHlsZSk7XG5cbiAgICAgICAgaWYgKGNhY2hlLnpPcmlnaW4gJiYgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdKSB7XG4gICAgICAgICAgc3R5bGVbX3RyYW5zZm9ybU9yaWdpblByb3BdICs9IFwiIFwiICsgY2FjaGUuek9yaWdpbiArIFwicHhcIjtcbiAgICAgICAgICBjYWNoZS56T3JpZ2luID0gMDtcbiAgICAgICAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlLnVuY2FjaGUgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgICAgIF9nZXRTdHlsZVNhdmVyID0gZnVuY3Rpb24gX2dldFN0eWxlU2F2ZXIodGFyZ2V0LCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIHNhdmVyID0ge1xuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBwcm9wczogW10sXG4gICAgICByZXZlcnQ6IF9yZXZlcnRTdHlsZSxcbiAgICAgIHNhdmU6IF9zYXZlU3R5bGVcbiAgICB9O1xuICAgIHRhcmdldC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KTtcbiAgICBwcm9wZXJ0aWVzICYmIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQubm9kZVR5cGUgJiYgcHJvcGVydGllcy5zcGxpdChcIixcIikuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIHNhdmVyLnNhdmUocCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNhdmVyO1xuICB9LFxuICAgICAgX3N1cHBvcnRzM0QsXG4gICAgICBfY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KHR5cGUsIG5zKSB7XG4gICAgdmFyIGUgPSBfZG9jJDEuY3JlYXRlRWxlbWVudE5TID8gX2RvYyQxLmNyZWF0ZUVsZW1lbnROUygobnMgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIpLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jJDEuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgICByZXR1cm4gZSAmJiBlLnN0eWxlID8gZSA6IF9kb2MkMS5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICB9LFxuICAgICAgX2dldENvbXB1dGVkUHJvcGVydHkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCBza2lwUHJlZml4RmFsbGJhY2spIHtcbiAgICB2YXIgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjtcbiAgfSxcbiAgICAgIF9wcmVmaXhlcyA9IFwiTyxNb3osbXMsTXMsV2Via2l0XCIuc3BsaXQoXCIsXCIpLFxuICAgICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICAgIHZhciBlID0gZWxlbWVudCB8fCBfdGVtcERpdixcbiAgICAgICAgcyA9IGUuc3R5bGUsXG4gICAgICAgIGkgPSA1O1xuXG4gICAgaWYgKHByb3BlcnR5IGluIHMgJiYgIXByZWZlclByZWZpeCkge1xuICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgIH1cblxuICAgIHByb3BlcnR5ID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zdWJzdHIoMSk7XG5cbiAgICB3aGlsZSAoaS0tICYmICEoX3ByZWZpeGVzW2ldICsgcHJvcGVydHkgaW4gcykpIHt9XG5cbiAgICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xuICB9LFxuICAgICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICAgIGlmIChfd2luZG93RXhpc3RzJDEoKSAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICAgIF93aW4kMSA9IHdpbmRvdztcbiAgICAgIF9kb2MkMSA9IF93aW4kMS5kb2N1bWVudDtcbiAgICAgIF9kb2NFbGVtZW50ID0gX2RvYyQxLmRvY3VtZW50RWxlbWVudDtcbiAgICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgICBzdHlsZToge31cbiAgICAgIH07XG4gICAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgX3RyYW5zZm9ybVByb3AgPSBfY2hlY2tQcm9wUHJlZml4KF90cmFuc2Zvcm1Qcm9wKTtcbiAgICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuICAgICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjtcbiAgICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgICBfcmV2ZXJ0aW5nJDEgPSBnc2FwLmNvcmUucmV2ZXJ0aW5nO1xuICAgICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICAgIH1cbiAgfSxcbiAgICAgIF9nZXRSZXBhcmVudGVkQ2xvbmVCQm94ID0gZnVuY3Rpb24gX2dldFJlcGFyZW50ZWRDbG9uZUJCb3godGFyZ2V0KSB7XG4gICAgdmFyIG93bmVyID0gdGFyZ2V0Lm93bmVyU1ZHRWxlbWVudCxcbiAgICAgICAgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgb3duZXIgJiYgb3duZXIuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgICAgY2xvbmUgPSB0YXJnZXQuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICBiYm94O1xuXG4gICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICBzdmcuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXG4gICAgX2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcblxuICAgIHRyeSB7XG4gICAgICBiYm94ID0gY2xvbmUuZ2V0QkJveCgpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICBzdmcucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuXG4gICAgX2RvY0VsZW1lbnQucmVtb3ZlQ2hpbGQoc3ZnKTtcblxuICAgIHJldHVybiBiYm94O1xuICB9LFxuICAgICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgICB2YXIgaSA9IGF0dHJpYnV0ZXNBcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZXNBcnJheVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAgICAgX2dldEJCb3ggPSBmdW5jdGlvbiBfZ2V0QkJveCh0YXJnZXQpIHtcbiAgICB2YXIgYm91bmRzLCBjbG9uZWQ7XG5cbiAgICB0cnkge1xuICAgICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYm91bmRzID0gX2dldFJlcGFyZW50ZWRDbG9uZUJCb3godGFyZ2V0KTtcbiAgICAgIGNsb25lZCA9IDE7XG4gICAgfVxuXG4gICAgYm91bmRzICYmIChib3VuZHMud2lkdGggfHwgYm91bmRzLmhlaWdodCkgfHwgY2xvbmVkIHx8IChib3VuZHMgPSBfZ2V0UmVwYXJlbnRlZENsb25lQkJveCh0YXJnZXQpKTtcbiAgICByZXR1cm4gYm91bmRzICYmICFib3VuZHMud2lkdGggJiYgIWJvdW5kcy54ICYmICFib3VuZHMueSA/IHtcbiAgICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgICB5OiArX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyh0YXJnZXQsIFtcInlcIiwgXCJjeVwiLCBcInkxXCJdKSB8fCAwLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9IDogYm91bmRzO1xuICB9LFxuICAgICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgICByZXR1cm4gISEoZS5nZXRDVE0gJiYgKCFlLnBhcmVudE5vZGUgfHwgZS5vd25lclNWR0VsZW1lbnQpICYmIF9nZXRCQm94KGUpKTtcbiAgfSxcbiAgICAgIF9yZW1vdmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgaWYgKHByb3BlcnR5KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgICAgZmlyc3QyQ2hhcnM7XG5cbiAgICAgIGlmIChwcm9wZXJ0eSBpbiBfdHJhbnNmb3JtUHJvcHMgJiYgcHJvcGVydHkgIT09IF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSB7XG4gICAgICAgIHByb3BlcnR5ID0gX3RyYW5zZm9ybVByb3A7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5yZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgICBmaXJzdDJDaGFycyA9IHByb3BlcnR5LnN1YnN0cigwLCAyKTtcblxuICAgICAgICBpZiAoZmlyc3QyQ2hhcnMgPT09IFwibXNcIiB8fCBwcm9wZXJ0eS5zdWJzdHIoMCwgNikgPT09IFwid2Via2l0XCIpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IFwiLVwiICsgcHJvcGVydHk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShmaXJzdDJDaGFycyA9PT0gXCItLVwiID8gcHJvcGVydHkgOiBwcm9wZXJ0eS5yZXBsYWNlKF9jYXBzRXhwLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAgICAgX2FkZE5vblR3ZWVuaW5nUFQgPSBmdW5jdGlvbiBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGJlZ2lubmluZywgZW5kLCBvbmx5U2V0QXRFbmQpIHtcbiAgICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIG9ubHlTZXRBdEVuZCA/IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIDogX3JlbmRlck5vblR3ZWVuaW5nVmFsdWUpO1xuICAgIHBsdWdpbi5fcHQgPSBwdDtcbiAgICBwdC5iID0gYmVnaW5uaW5nO1xuICAgIHB0LmUgPSBlbmQ7XG5cbiAgICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgcmV0dXJuIHB0O1xuICB9LFxuICAgICAgX25vbkNvbnZlcnRpYmxlVW5pdHMgPSB7XG4gICAgZGVnOiAxLFxuICAgIHJhZDogMSxcbiAgICB0dXJuOiAxXG4gIH0sXG4gICAgICBfbm9uU3RhbmRhcmRMYXlvdXRzID0ge1xuICAgIGdyaWQ6IDEsXG4gICAgZmxleDogMVxuICB9LFxuICAgICAgX2NvbnZlcnRUb1VuaXQgPSBmdW5jdGlvbiBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgdW5pdCkge1xuICAgIHZhciBjdXJWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDAsXG4gICAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgICBzdHlsZSA9IF90ZW1wRGl2LnN0eWxlLFxuICAgICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICAgIGlzUm9vdFNWRyA9IHRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIsXG4gICAgICAgIG1lYXN1cmVQcm9wZXJ0eSA9IChpc1Jvb3RTVkcgPyBcImNsaWVudFwiIDogXCJvZmZzZXRcIikgKyAoaG9yaXpvbnRhbCA/IFwiV2lkdGhcIiA6IFwiSGVpZ2h0XCIpLFxuICAgICAgICBhbW91bnQgPSAxMDAsXG4gICAgICAgIHRvUGl4ZWxzID0gdW5pdCA9PT0gXCJweFwiLFxuICAgICAgICB0b1BlcmNlbnQgPSB1bml0ID09PSBcIiVcIixcbiAgICAgICAgcHgsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGlzU1ZHO1xuXG4gICAgaWYgKHVuaXQgPT09IGN1clVuaXQgfHwgIWN1clZhbHVlIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW3VuaXRdIHx8IF9ub25Db252ZXJ0aWJsZVVuaXRzW2N1clVuaXRdKSB7XG4gICAgICByZXR1cm4gY3VyVmFsdWU7XG4gICAgfVxuXG4gICAgY3VyVW5pdCAhPT0gXCJweFwiICYmICF0b1BpeGVscyAmJiAoY3VyVmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgXCJweFwiKSk7XG4gICAgaXNTVkcgPSB0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpO1xuXG4gICAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgICBweCA9IGlzU1ZHID8gdGFyZ2V0LmdldEJCb3goKVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gOiB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICAgIHJldHVybiBfcm91bmQodG9QZXJjZW50ID8gY3VyVmFsdWUgLyBweCAqIGFtb3VudCA6IGN1clZhbHVlIC8gMTAwICogcHgpO1xuICAgIH1cblxuICAgIHN0eWxlW2hvcml6b250YWwgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXSA9IGFtb3VudCArICh0b1BpeGVscyA/IGN1clVuaXQgOiB1bml0KTtcbiAgICBwYXJlbnQgPSB1bml0ICE9PSBcInJlbVwiICYmIH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgIHBhcmVudCA9ICh0YXJnZXQub3duZXJTVkdFbGVtZW50IHx8IHt9KS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmICghcGFyZW50IHx8IHBhcmVudCA9PT0gX2RvYyQxIHx8ICFwYXJlbnQuYXBwZW5kQ2hpbGQpIHtcbiAgICAgIHBhcmVudCA9IF9kb2MkMS5ib2R5O1xuICAgIH1cblxuICAgIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gICAgaWYgKGNhY2hlICYmIHRvUGVyY2VudCAmJiBjYWNoZS53aWR0aCAmJiBob3Jpem9udGFsICYmIGNhY2hlLnRpbWUgPT09IF90aWNrZXIudGltZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgICAgcmV0dXJuIF9yb3VuZChjdXJWYWx1ZSAvIGNhY2hlLndpZHRoICogYW1vdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRvUGVyY2VudCAmJiAocHJvcGVydHkgPT09IFwiaGVpZ2h0XCIgfHwgcHJvcGVydHkgPT09IFwid2lkdGhcIikpIHtcbiAgICAgICAgdmFyIHYgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuICAgICAgICB0YXJnZXQuc3R5bGVbcHJvcGVydHldID0gYW1vdW50ICsgdW5pdDtcbiAgICAgICAgcHggPSB0YXJnZXRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICAgICAgdiA/IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2IDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHRvUGVyY2VudCB8fCBjdXJVbml0ID09PSBcIiVcIikgJiYgIV9ub25TdGFuZGFyZExheW91dHNbX2dldENvbXB1dGVkUHJvcGVydHkocGFyZW50LCBcImRpc3BsYXlcIildICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgICAgIHBhcmVudCA9PT0gdGFyZ2V0ICYmIChzdHlsZS5wb3NpdGlvbiA9IFwic3RhdGljXCIpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgICAgICBweCA9IF90ZW1wRGl2W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChfdGVtcERpdik7XG4gICAgICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG9yaXpvbnRhbCAmJiB0b1BlcmNlbnQpIHtcbiAgICAgICAgY2FjaGUgPSBfZ2V0Q2FjaGUocGFyZW50KTtcbiAgICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgICAgY2FjaGUud2lkdGggPSBwYXJlbnRbbWVhc3VyZVByb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX3JvdW5kKHRvUGl4ZWxzID8gcHggKiBjdXJWYWx1ZSAvIGFtb3VudCA6IHB4ICYmIGN1clZhbHVlID8gYW1vdW50IC8gcHggKiBjdXJWYWx1ZSA6IDApO1xuICB9LFxuICAgICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgIHZhciB2YWx1ZTtcbiAgICBfcGx1Z2luSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblxuICAgIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBwcm9wZXJ0eSA9IF9wcm9wZXJ0eUFsaWFzZXNbcHJvcGVydHldO1xuXG4gICAgICBpZiAofnByb3BlcnR5LmluZGV4T2YoXCIsXCIpKSB7XG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICB2YWx1ZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHVuY2FjaGUpO1xuICAgICAgdmFsdWUgPSBwcm9wZXJ0eSAhPT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IHZhbHVlW3Byb3BlcnR5XSA6IHZhbHVlLnN2ZyA/IHZhbHVlLm9yaWdpbiA6IF9maXJzdFR3b09ubHkoX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtT3JpZ2luUHJvcCkpICsgXCIgXCIgKyB2YWx1ZS56T3JpZ2luICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHRhcmdldC5zdHlsZVtwcm9wZXJ0eV07XG5cbiAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUgPT09IFwiYXV0b1wiIHx8IHVuY2FjaGUgfHwgfih2YWx1ZSArIFwiXCIpLmluZGV4T2YoXCJjYWxjKFwiKSkge1xuICAgICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bml0ICYmICF+KHZhbHVlICsgXCJcIikudHJpbSgpLmluZGV4T2YoXCIgXCIpID8gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpICsgdW5pdCA6IHZhbHVlO1xuICB9LFxuICAgICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCB8fCBzdGFydCA9PT0gXCJub25lXCIpIHtcbiAgICAgIHZhciBwID0gX2NoZWNrUHJvcFByZWZpeChwcm9wLCB0YXJnZXQsIDEpLFxuICAgICAgICAgIHMgPSBwICYmIF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcCwgMSk7XG5cbiAgICAgIGlmIChzICYmIHMgIT09IHN0YXJ0KSB7XG4gICAgICAgIHByb3AgPSBwO1xuICAgICAgICBzdGFydCA9IHM7XG4gICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiYm9yZGVyQ29sb3JcIikge1xuICAgICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQuc3R5bGUsIHByb3AsIDAsIDEsIF9yZW5kZXJDb21wbGV4U3RyaW5nKSxcbiAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICBtYXRjaEluZGV4ID0gMCxcbiAgICAgICAgYSxcbiAgICAgICAgcmVzdWx0LFxuICAgICAgICBzdGFydFZhbHVlcyxcbiAgICAgICAgc3RhcnROdW0sXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBjaHVuayxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgc3RhcnRVbml0LFxuICAgICAgICBlbmRWYWx1ZXM7XG4gICAgcHQuYiA9IHN0YXJ0O1xuICAgIHB0LmUgPSBlbmQ7XG4gICAgc3RhcnQgKz0gXCJcIjtcbiAgICBlbmQgKz0gXCJcIjtcblxuICAgIGlmIChlbmQuc3Vic3RyaW5nKDAsIDYpID09PSBcInZhcigtLVwiKSB7XG4gICAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIGVuZC5zdWJzdHJpbmcoNCwgZW5kLmluZGV4T2YoXCIpXCIpKSk7XG4gICAgfVxuXG4gICAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIHN0YXJ0VmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcF07XG4gICAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XG4gICAgICBlbmQgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHByb3ApIHx8IGVuZDtcbiAgICAgIHN0YXJ0VmFsdWUgPyB0YXJnZXQuc3R5bGVbcHJvcF0gPSBzdGFydFZhbHVlIDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgfVxuXG4gICAgYSA9IFtzdGFydCwgZW5kXTtcblxuICAgIF9jb2xvclN0cmluZ0ZpbHRlcihhKTtcblxuICAgIHN0YXJ0ID0gYVswXTtcbiAgICBlbmQgPSBhWzFdO1xuICAgIHN0YXJ0VmFsdWVzID0gc3RhcnQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcbiAgICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICAgIGlmIChlbmRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICB3aGlsZSAocmVzdWx0ID0gX251bVdpdGhVbml0RXhwLmV4ZWMoZW5kKSkge1xuICAgICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgICAgY2h1bmsgPSBlbmQuc3Vic3RyaW5nKGluZGV4LCByZXN1bHQuaW5kZXgpO1xuXG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgICB9IGVsc2UgaWYgKGNodW5rLnN1YnN0cigtNSkgPT09IFwicmdiYShcIiB8fCBjaHVuay5zdWJzdHIoLTUpID09PSBcImhzbGEoXCIpIHtcbiAgICAgICAgICBjb2xvciA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kVmFsdWUgIT09IChzdGFydFZhbHVlID0gc3RhcnRWYWx1ZXNbbWF0Y2hJbmRleCsrXSB8fCBcIlwiKSkge1xuICAgICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKSB8fCAwO1xuICAgICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoZW5kVmFsdWUgPSBfcGFyc2VSZWxhdGl2ZShzdGFydE51bSwgZW5kVmFsdWUpICsgc3RhcnRVbml0KTtcbiAgICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICAgIGluZGV4ID0gX251bVdpdGhVbml0RXhwLmxhc3RJbmRleCAtIGVuZFVuaXQubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKCFlbmRVbml0KSB7XG4gICAgICAgICAgICBlbmRVbml0ID0gZW5kVW5pdCB8fCBfY29uZmlnLnVuaXRzW3Byb3BdIHx8IHN0YXJ0VW5pdDtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGVuZCArPSBlbmRVbml0O1xuICAgICAgICAgICAgICBwdC5lICs9IGVuZFVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCkge1xuICAgICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHQuX3B0ID0ge1xuICAgICAgICAgICAgX25leHQ6IHB0Ll9wdCxcbiAgICAgICAgICAgIHA6IGNodW5rIHx8IG1hdGNoSW5kZXggPT09IDEgPyBjaHVuayA6IFwiLFwiLFxuICAgICAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgICAgICBjOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB0LmMgPSBpbmRleCA8IGVuZC5sZW5ndGggPyBlbmQuc3Vic3RyaW5nKGluZGV4LCBlbmQubGVuZ3RoKSA6IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB0LnIgPSBwcm9wID09PSBcImRpc3BsYXlcIiAmJiBlbmQgPT09IFwibm9uZVwiID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZTtcbiAgICB9XG5cbiAgICBfcmVsRXhwLnRlc3QoZW5kKSAmJiAocHQuZSA9IDApO1xuICAgIHRoaXMuX3B0ID0gcHQ7XG4gICAgcmV0dXJuIHB0O1xuICB9LFxuICAgICAgX2tleXdvcmRUb1BlcmNlbnQgPSB7XG4gICAgdG9wOiBcIjAlXCIsXG4gICAgYm90dG9tOiBcIjEwMCVcIixcbiAgICBsZWZ0OiBcIjAlXCIsXG4gICAgcmlnaHQ6IFwiMTAwJVwiLFxuICAgIGNlbnRlcjogXCI1MCVcIlxuICB9LFxuICAgICAgX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMgPSBmdW5jdGlvbiBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyh2YWx1ZSkge1xuICAgIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgeCA9IHNwbGl0WzBdLFxuICAgICAgICB5ID0gc3BsaXRbMV0gfHwgXCI1MCVcIjtcblxuICAgIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICB2YWx1ZSA9IHg7XG4gICAgICB4ID0geTtcbiAgICAgIHkgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBzcGxpdFswXSA9IF9rZXl3b3JkVG9QZXJjZW50W3hdIHx8IHg7XG4gICAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICAgIHJldHVybiBzcGxpdC5qb2luKFwiIFwiKTtcbiAgfSxcbiAgICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgICBpZiAoZGF0YS50d2VlbiAmJiBkYXRhLnR3ZWVuLl90aW1lID09PSBkYXRhLnR3ZWVuLl9kdXIpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBkYXRhLnQsXG4gICAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgICAgcHJvcHMgPSBkYXRhLnUsXG4gICAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICAgICAgcHJvcCxcbiAgICAgICAgICBjbGVhclRyYW5zZm9ybXMsXG4gICAgICAgICAgaTtcblxuICAgICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICAgIHN0eWxlLmNzc1RleHQgPSBcIlwiO1xuICAgICAgICBjbGVhclRyYW5zZm9ybXMgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBwcm9wcy5zcGxpdChcIixcIik7XG4gICAgICAgIGkgPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgICAgcHJvcCA9IHByb3BzW2ldO1xuXG4gICAgICAgICAgaWYgKF90cmFuc2Zvcm1Qcm9wc1twcm9wXSkge1xuICAgICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICAgIHByb3AgPSBwcm9wID09PSBcInRyYW5zZm9ybU9yaWdpblwiID8gX3RyYW5zZm9ybU9yaWdpblByb3AgOiBfdHJhbnNmb3JtUHJvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICBzdHlsZS5zY2FsZSA9IHN0eWxlLnJvdGF0ZSA9IHN0eWxlLnRyYW5zbGF0ZSA9IFwibm9uZVwiO1xuXG4gICAgICAgICAgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSk7XG5cbiAgICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcblxuICAgICAgICAgIF9yZW1vdmVJbmRlcGVuZGVudFRyYW5zZm9ybXMoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAgICAgX3NwZWNpYWxQcm9wcyA9IHtcbiAgICBjbGVhclByb3BzOiBmdW5jdGlvbiBjbGVhclByb3BzKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gICAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICAgIHZhciBwdCA9IHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDAsIF9yZW5kZXJDbGVhclByb3BzKTtcbiAgICAgICAgcHQudSA9IGVuZFZhbHVlO1xuICAgICAgICBwdC5wciA9IC0xMDtcbiAgICAgICAgcHQudHdlZW4gPSB0d2VlbjtcblxuICAgICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgICAgIF9pZGVudGl0eTJETWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdLFxuICAgICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgICBfaXNOdWxsVHJhbnNmb3JtID0gZnVuY3Rpb24gX2lzTnVsbFRyYW5zZm9ybSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIiB8fCB2YWx1ZSA9PT0gXCJub25lXCIgfHwgIXZhbHVlO1xuICB9LFxuICAgICAgX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSB7XG4gICAgdmFyIG1hdHJpeFN0cmluZyA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbiAgfSxcbiAgICAgIF9nZXRNYXRyaXggPSBmdW5jdGlvbiBfZ2V0TWF0cml4KHRhcmdldCwgZm9yY2UyRCkge1xuICAgIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIG1hdHJpeCA9IF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkodGFyZ2V0KSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBuZXh0U2libGluZyxcbiAgICAgICAgdGVtcCxcbiAgICAgICAgYWRkZWRUb0RPTTtcblxuICAgIGlmIChjYWNoZS5zdmcgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKSkge1xuICAgICAgdGVtcCA9IHRhcmdldC50cmFuc2Zvcm0uYmFzZVZhbC5jb25zb2xpZGF0ZSgpLm1hdHJpeDtcbiAgICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICAgIHJldHVybiBtYXRyaXguam9pbihcIixcIikgPT09IFwiMSwwLDAsMSwwLDBcIiA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4O1xuICAgIH0gZWxzZSBpZiAobWF0cml4ID09PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAhdGFyZ2V0Lm9mZnNldFBhcmVudCAmJiB0YXJnZXQgIT09IF9kb2NFbGVtZW50ICYmICFjYWNoZS5zdmcpIHtcbiAgICAgIHRlbXAgPSBzdHlsZS5kaXNwbGF5O1xuICAgICAgc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgICBpZiAoIXBhcmVudCB8fCAhdGFyZ2V0Lm9mZnNldFBhcmVudCAmJiAhdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKSB7XG4gICAgICAgIGFkZGVkVG9ET00gPSAxO1xuICAgICAgICBuZXh0U2libGluZyA9IHRhcmdldC5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgICAgX2RvY0VsZW1lbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgICAgdGVtcCA/IHN0eWxlLmRpc3BsYXkgPSB0ZW1wIDogX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgXCJkaXNwbGF5XCIpO1xuXG4gICAgICBpZiAoYWRkZWRUb0RPTSkge1xuICAgICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbiAgfSxcbiAgICAgIF9hcHBseVNWR09yaWdpbiA9IGZ1bmN0aW9uIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIG9yaWdpbiwgb3JpZ2luSXNBYnNvbHV0ZSwgc21vb3RoLCBtYXRyaXhBcnJheSwgcGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8pIHtcbiAgICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICAgIG1hdHJpeCA9IG1hdHJpeEFycmF5IHx8IF9nZXRNYXRyaXgodGFyZ2V0LCB0cnVlKSxcbiAgICAgICAgeE9yaWdpbk9sZCA9IGNhY2hlLnhPcmlnaW4gfHwgMCxcbiAgICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgICAgeE9mZnNldE9sZCA9IGNhY2hlLnhPZmZzZXQgfHwgMCxcbiAgICAgICAgeU9mZnNldE9sZCA9IGNhY2hlLnlPZmZzZXQgfHwgMCxcbiAgICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgICAgYiA9IG1hdHJpeFsxXSxcbiAgICAgICAgYyA9IG1hdHJpeFsyXSxcbiAgICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgICAgdHggPSBtYXRyaXhbNF0sXG4gICAgICAgIHR5ID0gbWF0cml4WzVdLFxuICAgICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICAgIHhPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzBdKSB8fCAwLFxuICAgICAgICB5T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFsxXSkgfHwgMCxcbiAgICAgICAgYm91bmRzLFxuICAgICAgICBkZXRlcm1pbmFudCxcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIGlmICghb3JpZ2luSXNBYnNvbHV0ZSkge1xuICAgICAgYm91bmRzID0gX2dldEJCb3godGFyZ2V0KTtcbiAgICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgICB5T3JpZ2luID0gYm91bmRzLnkgKyAofihvcmlnaW5TcGxpdFsxXSB8fCBvcmlnaW5TcGxpdFswXSkuaW5kZXhPZihcIiVcIikgPyB5T3JpZ2luIC8gMTAwICogYm91bmRzLmhlaWdodCA6IHlPcmlnaW4pO1xuICAgIH0gZWxzZSBpZiAobWF0cml4ICE9PSBfaWRlbnRpdHkyRE1hdHJpeCAmJiAoZGV0ZXJtaW5hbnQgPSBhICogZCAtIGIgKiBjKSkge1xuICAgICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgICAgeSA9IHhPcmlnaW4gKiAoLWIgLyBkZXRlcm1pbmFudCkgKyB5T3JpZ2luICogKGEgLyBkZXRlcm1pbmFudCkgLSAoYSAqIHR5IC0gYiAqIHR4KSAvIGRldGVybWluYW50O1xuICAgICAgeE9yaWdpbiA9IHg7XG4gICAgICB5T3JpZ2luID0geTtcbiAgICB9XG5cbiAgICBpZiAoc21vb3RoIHx8IHNtb290aCAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoKSB7XG4gICAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgICAgdHkgPSB5T3JpZ2luIC0geU9yaWdpbk9sZDtcbiAgICAgIGNhY2hlLnhPZmZzZXQgPSB4T2Zmc2V0T2xkICsgKHR4ICogYSArIHR5ICogYykgLSB0eDtcbiAgICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGNhY2hlLnhPcmlnaW4gPSB4T3JpZ2luO1xuICAgIGNhY2hlLnlPcmlnaW4gPSB5T3JpZ2luO1xuICAgIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICAgIGNhY2hlLm9yaWdpbiA9IG9yaWdpbjtcbiAgICBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlID0gISFvcmlnaW5Jc0Fic29sdXRlO1xuICAgIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjtcblxuICAgIGlmIChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICAgICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ5T3JpZ2luXCIsIHlPcmlnaW5PbGQsIHlPcmlnaW4pO1xuXG4gICAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieE9mZnNldFwiLCB4T2Zmc2V0T2xkLCBjYWNoZS54T2Zmc2V0KTtcblxuICAgICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcImRhdGEtc3ZnLW9yaWdpblwiLCB4T3JpZ2luICsgXCIgXCIgKyB5T3JpZ2luKTtcbiAgfSxcbiAgICAgIF9wYXJzZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHVuY2FjaGUpIHtcbiAgICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAgfHwgbmV3IEdTQ2FjaGUodGFyZ2V0KTtcblxuICAgIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgaW52ZXJ0ZWRTY2FsZVggPSBjYWNoZS5zY2FsZVggPCAwLFxuICAgICAgICBweCA9IFwicHhcIixcbiAgICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgICAgY3MgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCksXG4gICAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB6LFxuICAgICAgICBzY2FsZVgsXG4gICAgICAgIHNjYWxlWSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHJvdGF0aW9uWCxcbiAgICAgICAgcm90YXRpb25ZLFxuICAgICAgICBza2V3WCxcbiAgICAgICAgc2tld1ksXG4gICAgICAgIHBlcnNwZWN0aXZlLFxuICAgICAgICB4T3JpZ2luLFxuICAgICAgICB5T3JpZ2luLFxuICAgICAgICBtYXRyaXgsXG4gICAgICAgIGFuZ2xlLFxuICAgICAgICBjb3MsXG4gICAgICAgIHNpbixcbiAgICAgICAgYSxcbiAgICAgICAgYixcbiAgICAgICAgYyxcbiAgICAgICAgZCxcbiAgICAgICAgYTEyLFxuICAgICAgICBhMjIsXG4gICAgICAgIHQxLFxuICAgICAgICB0MixcbiAgICAgICAgdDMsXG4gICAgICAgIGExMyxcbiAgICAgICAgYTIzLFxuICAgICAgICBhMzMsXG4gICAgICAgIGE0MixcbiAgICAgICAgYTQzLFxuICAgICAgICBhMzI7XG4gICAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICAgIHNjYWxlWCA9IHNjYWxlWSA9IDE7XG4gICAgY2FjaGUuc3ZnID0gISEodGFyZ2V0LmdldENUTSAmJiBfaXNTVkcodGFyZ2V0KSk7XG5cbiAgICBpZiAoY3MudHJhbnNsYXRlKSB7XG4gICAgICBpZiAoY3MudHJhbnNsYXRlICE9PSBcIm5vbmVcIiB8fCBjcy5zY2FsZSAhPT0gXCJub25lXCIgfHwgY3Mucm90YXRlICE9PSBcIm5vbmVcIikge1xuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSAoY3MudHJhbnNsYXRlICE9PSBcIm5vbmVcIiA/IFwidHJhbnNsYXRlM2QoXCIgKyAoY3MudHJhbnNsYXRlICsgXCIgMCAwXCIpLnNwbGl0KFwiIFwiKS5zbGljZSgwLCAzKS5qb2luKFwiLCBcIikgKyBcIikgXCIgOiBcIlwiKSArIChjcy5yb3RhdGUgIT09IFwibm9uZVwiID8gXCJyb3RhdGUoXCIgKyBjcy5yb3RhdGUgKyBcIikgXCIgOiBcIlwiKSArIChjcy5zY2FsZSAhPT0gXCJub25lXCIgPyBcInNjYWxlKFwiICsgY3Muc2NhbGUuc3BsaXQoXCIgXCIpLmpvaW4oXCIsXCIpICsgXCIpIFwiIDogXCJcIikgKyAoY3NbX3RyYW5zZm9ybVByb3BdICE9PSBcIm5vbmVcIiA/IGNzW190cmFuc2Zvcm1Qcm9wXSA6IFwiXCIpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZS5zY2FsZSA9IHN0eWxlLnJvdGF0ZSA9IHN0eWxlLnRyYW5zbGF0ZSA9IFwibm9uZVwiO1xuICAgIH1cblxuICAgIG1hdHJpeCA9IF9nZXRNYXRyaXgodGFyZ2V0LCBjYWNoZS5zdmcpO1xuXG4gICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgaWYgKGNhY2hlLnVuY2FjaGUpIHtcbiAgICAgICAgdDIgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgICAgICBvcmlnaW4gPSBjYWNoZS54T3JpZ2luIC0gdDIueCArIFwicHggXCIgKyAoY2FjaGUueU9yaWdpbiAtIHQyLnkpICsgXCJweFwiO1xuICAgICAgICB0MSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0MSA9ICF1bmNhY2hlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7XG4gICAgICB9XG5cbiAgICAgIF9hcHBseVNWR09yaWdpbih0YXJnZXQsIHQxIHx8IG9yaWdpbiwgISF0MSB8fCBjYWNoZS5vcmlnaW5Jc0Fic29sdXRlLCBjYWNoZS5zbW9vdGggIT09IGZhbHNlLCBtYXRyaXgpO1xuICAgIH1cblxuICAgIHhPcmlnaW4gPSBjYWNoZS54T3JpZ2luIHx8IDA7XG4gICAgeU9yaWdpbiA9IGNhY2hlLnlPcmlnaW4gfHwgMDtcblxuICAgIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4KSB7XG4gICAgICBhID0gbWF0cml4WzBdO1xuICAgICAgYiA9IG1hdHJpeFsxXTtcbiAgICAgIGMgPSBtYXRyaXhbMl07XG4gICAgICBkID0gbWF0cml4WzNdO1xuICAgICAgeCA9IGExMiA9IG1hdHJpeFs0XTtcbiAgICAgIHkgPSBhMjIgPSBtYXRyaXhbNV07XG5cbiAgICAgIGlmIChtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgICAgc2NhbGVZID0gTWF0aC5zcXJ0KGQgKiBkICsgYyAqIGMpO1xuICAgICAgICByb3RhdGlvbiA9IGEgfHwgYiA/IF9hdGFuMihiLCBhKSAqIF9SQUQyREVHIDogMDtcbiAgICAgICAgc2tld1ggPSBjIHx8IGQgPyBfYXRhbjIoYywgZCkgKiBfUkFEMkRFRyArIHJvdGF0aW9uIDogMDtcbiAgICAgICAgc2tld1ggJiYgKHNjYWxlWSAqPSBNYXRoLmFicyhNYXRoLmNvcyhza2V3WCAqIF9ERUcyUkFEKSkpO1xuXG4gICAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgICB4IC09IHhPcmlnaW4gLSAoeE9yaWdpbiAqIGEgKyB5T3JpZ2luICogYyk7XG4gICAgICAgICAgeSAtPSB5T3JpZ2luIC0gKHhPcmlnaW4gKiBiICsgeU9yaWdpbiAqIGQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhMzIgPSBtYXRyaXhbNl07XG4gICAgICAgIGE0MiA9IG1hdHJpeFs3XTtcbiAgICAgICAgYTEzID0gbWF0cml4WzhdO1xuICAgICAgICBhMjMgPSBtYXRyaXhbOV07XG4gICAgICAgIGEzMyA9IG1hdHJpeFsxMF07XG4gICAgICAgIGE0MyA9IG1hdHJpeFsxMV07XG4gICAgICAgIHggPSBtYXRyaXhbMTJdO1xuICAgICAgICB5ID0gbWF0cml4WzEzXTtcbiAgICAgICAgeiA9IG1hdHJpeFsxNF07XG4gICAgICAgIGFuZ2xlID0gX2F0YW4yKGEzMiwgYTMzKTtcbiAgICAgICAgcm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgICAgdDEgPSBhMTIgKiBjb3MgKyBhMTMgKiBzaW47XG4gICAgICAgICAgdDIgPSBhMjIgKiBjb3MgKyBhMjMgKiBzaW47XG4gICAgICAgICAgdDMgPSBhMzIgKiBjb3MgKyBhMzMgKiBzaW47XG4gICAgICAgICAgYTEzID0gYTEyICogLXNpbiArIGExMyAqIGNvcztcbiAgICAgICAgICBhMjMgPSBhMjIgKiAtc2luICsgYTIzICogY29zO1xuICAgICAgICAgIGEzMyA9IGEzMiAqIC1zaW4gKyBhMzMgKiBjb3M7XG4gICAgICAgICAgYTQzID0gYTQyICogLXNpbiArIGE0MyAqIGNvcztcbiAgICAgICAgICBhMTIgPSB0MTtcbiAgICAgICAgICBhMjIgPSB0MjtcbiAgICAgICAgICBhMzIgPSB0MztcbiAgICAgICAgfVxuXG4gICAgICAgIGFuZ2xlID0gX2F0YW4yKC1jLCBhMzMpO1xuICAgICAgICByb3RhdGlvblkgPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICAgIGlmIChhbmdsZSkge1xuICAgICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgICB0MSA9IGEgKiBjb3MgLSBhMTMgKiBzaW47XG4gICAgICAgICAgdDIgPSBiICogY29zIC0gYTIzICogc2luO1xuICAgICAgICAgIHQzID0gYyAqIGNvcyAtIGEzMyAqIHNpbjtcbiAgICAgICAgICBhNDMgPSBkICogc2luICsgYTQzICogY29zO1xuICAgICAgICAgIGEgPSB0MTtcbiAgICAgICAgICBiID0gdDI7XG4gICAgICAgICAgYyA9IHQzO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5nbGUgPSBfYXRhbjIoYiwgYSk7XG4gICAgICAgIHJvdGF0aW9uID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgICBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgIHQxID0gYSAqIGNvcyArIGIgKiBzaW47XG4gICAgICAgICAgdDIgPSBhMTIgKiBjb3MgKyBhMjIgKiBzaW47XG4gICAgICAgICAgYiA9IGIgKiBjb3MgLSBhICogc2luO1xuICAgICAgICAgIGEyMiA9IGEyMiAqIGNvcyAtIGExMiAqIHNpbjtcbiAgICAgICAgICBhID0gdDE7XG4gICAgICAgICAgYTEyID0gdDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25YICYmIE1hdGguYWJzKHJvdGF0aW9uWCkgKyBNYXRoLmFicyhyb3RhdGlvbikgPiAzNTkuOSkge1xuICAgICAgICAgIHJvdGF0aW9uWCA9IHJvdGF0aW9uID0gMDtcbiAgICAgICAgICByb3RhdGlvblkgPSAxODAgLSByb3RhdGlvblk7XG4gICAgICAgIH1cblxuICAgICAgICBzY2FsZVggPSBfcm91bmQoTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYykpO1xuICAgICAgICBzY2FsZVkgPSBfcm91bmQoTWF0aC5zcXJ0KGEyMiAqIGEyMiArIGEzMiAqIGEzMikpO1xuICAgICAgICBhbmdsZSA9IF9hdGFuMihhMTIsIGEyMik7XG4gICAgICAgIHNrZXdYID0gTWF0aC5hYnMoYW5nbGUpID4gMC4wMDAyID8gYW5nbGUgKiBfUkFEMkRFRyA6IDA7XG4gICAgICAgIHBlcnNwZWN0aXZlID0gYTQzID8gMSAvIChhNDMgPCAwID8gLWE0MyA6IGE0MykgOiAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgIHQxID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgY2FjaGUuZm9yY2VDU1MgPSB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpIHx8ICFfaXNOdWxsVHJhbnNmb3JtKF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApKTtcbiAgICAgICAgdDEgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0MSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKHNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHNrZXdYKSA8IDI3MCkge1xuICAgICAgaWYgKGludmVydGVkU2NhbGVYKSB7XG4gICAgICAgIHNjYWxlWCAqPSAtMTtcbiAgICAgICAgc2tld1ggKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgICAgIHJvdGF0aW9uICs9IHJvdGF0aW9uIDw9IDAgPyAxODAgOiAtMTgwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVZICo9IC0xO1xuICAgICAgICBza2V3WCArPSBza2V3WCA8PSAwID8gMTgwIDogLTE4MDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB1bmNhY2hlID0gdW5jYWNoZSB8fCBjYWNoZS51bmNhY2hlO1xuICAgIGNhY2hlLnggPSB4IC0gKChjYWNoZS54UGVyY2VudCA9IHggJiYgKCF1bmNhY2hlICYmIGNhY2hlLnhQZXJjZW50IHx8IChNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpID09PSBNYXRoLnJvdW5kKC14KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0V2lkdGggKiBjYWNoZS54UGVyY2VudCAvIDEwMCA6IDApICsgcHg7XG4gICAgY2FjaGUueSA9IHkgLSAoKGNhY2hlLnlQZXJjZW50ID0geSAmJiAoIXVuY2FjaGUgJiYgY2FjaGUueVBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldEhlaWdodCAvIDIpID09PSBNYXRoLnJvdW5kKC15KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0SGVpZ2h0ICogY2FjaGUueVBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuICAgIGNhY2hlLnogPSB6ICsgcHg7XG4gICAgY2FjaGUuc2NhbGVYID0gX3JvdW5kKHNjYWxlWCk7XG4gICAgY2FjaGUuc2NhbGVZID0gX3JvdW5kKHNjYWxlWSk7XG4gICAgY2FjaGUucm90YXRpb24gPSBfcm91bmQocm90YXRpb24pICsgZGVnO1xuICAgIGNhY2hlLnJvdGF0aW9uWCA9IF9yb3VuZChyb3RhdGlvblgpICsgZGVnO1xuICAgIGNhY2hlLnJvdGF0aW9uWSA9IF9yb3VuZChyb3RhdGlvblkpICsgZGVnO1xuICAgIGNhY2hlLnNrZXdYID0gc2tld1ggKyBkZWc7XG4gICAgY2FjaGUuc2tld1kgPSBza2V3WSArIGRlZztcbiAgICBjYWNoZS50cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlICsgcHg7XG5cbiAgICBpZiAoY2FjaGUuek9yaWdpbiA9IHBhcnNlRmxvYXQob3JpZ2luLnNwbGl0KFwiIFwiKVsyXSkgfHwgIXVuY2FjaGUgJiYgY2FjaGUuek9yaWdpbiB8fCAwKSB7XG4gICAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gICAgfVxuXG4gICAgY2FjaGUueE9mZnNldCA9IGNhY2hlLnlPZmZzZXQgPSAwO1xuICAgIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtID0gY2FjaGUuc3ZnID8gX3JlbmRlclNWR1RyYW5zZm9ybXMgOiBfc3VwcG9ydHMzRCA/IF9yZW5kZXJDU1NUcmFuc2Zvcm1zIDogX3JlbmRlck5vbjNEVHJhbnNmb3JtcztcbiAgICBjYWNoZS51bmNhY2hlID0gMDtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH0sXG4gICAgICBfZmlyc3RUd29Pbmx5ID0gZnVuY3Rpb24gX2ZpcnN0VHdvT25seSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbiAgfSxcbiAgICAgIF9hZGRQeFRyYW5zbGF0ZSA9IGZ1bmN0aW9uIF9hZGRQeFRyYW5zbGF0ZSh0YXJnZXQsIHN0YXJ0LCB2YWx1ZSkge1xuICAgIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gICAgcmV0dXJuIF9yb3VuZChwYXJzZUZsb2F0KHN0YXJ0KSArIHBhcnNlRmxvYXQoX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgdmFsdWUgKyBcInB4XCIsIHVuaXQpKSkgKyB1bml0O1xuICB9LFxuICAgICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gICAgY2FjaGUueiA9IFwiMHB4XCI7XG4gICAgY2FjaGUucm90YXRpb25ZID0gY2FjaGUucm90YXRpb25YID0gXCIwZGVnXCI7XG4gICAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgICBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpO1xuICB9LFxuICAgICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICAgIF96ZXJvUHggPSBcIjBweFwiLFxuICAgICAgX2VuZFBhcmVudGhlc2lzID0gXCIpIFwiLFxuICAgICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgICB2YXIgX3JlZiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICAgIHhQZXJjZW50ID0gX3JlZi54UGVyY2VudCxcbiAgICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgICB4ID0gX3JlZi54LFxuICAgICAgICB5ID0gX3JlZi55LFxuICAgICAgICB6ID0gX3JlZi56LFxuICAgICAgICByb3RhdGlvbiA9IF9yZWYucm90YXRpb24sXG4gICAgICAgIHJvdGF0aW9uWSA9IF9yZWYucm90YXRpb25ZLFxuICAgICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgICAgc2tld1ggPSBfcmVmLnNrZXdYLFxuICAgICAgICBza2V3WSA9IF9yZWYuc2tld1ksXG4gICAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgICBzY2FsZVkgPSBfcmVmLnNjYWxlWSxcbiAgICAgICAgdHJhbnNmb3JtUGVyc3BlY3RpdmUgPSBfcmVmLnRyYW5zZm9ybVBlcnNwZWN0aXZlLFxuICAgICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgICB0YXJnZXQgPSBfcmVmLnRhcmdldCxcbiAgICAgICAgek9yaWdpbiA9IF9yZWYuek9yaWdpbixcbiAgICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICAgIHVzZTNEID0gZm9yY2UzRCA9PT0gXCJhdXRvXCIgJiYgcmF0aW8gJiYgcmF0aW8gIT09IDEgfHwgZm9yY2UzRCA9PT0gdHJ1ZTtcblxuICAgIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgICB2YXIgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWSkgKiBfREVHMlJBRCxcbiAgICAgICAgICBhMTMgPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIGNvcztcblxuICAgICAgYW5nbGUgPSBwYXJzZUZsb2F0KHJvdGF0aW9uWCkgKiBfREVHMlJBRDtcbiAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHggPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB4LCBhMTMgKiBjb3MgKiAtek9yaWdpbik7XG4gICAgICB5ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeSwgLU1hdGguc2luKGFuZ2xlKSAqIC16T3JpZ2luKTtcbiAgICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSAhPT0gX3plcm9QeCkge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gICAgfVxuXG4gICAgaWYgKHhQZXJjZW50IHx8IHlQZXJjZW50KSB7XG4gICAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICAgIH1cblxuICAgIGlmICh1c2UzRCB8fCB4ICE9PSBfemVyb1B4IHx8IHkgIT09IF96ZXJvUHggfHwgeiAhPT0gX3plcm9QeCkge1xuICAgICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0aW9uICE9PSBfemVyb0RlZykge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICAgIH1cblxuICAgIGlmIChyb3RhdGlvblkgIT09IF96ZXJvRGVnKSB7XG4gICAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgICB9XG5cbiAgICBpZiAocm90YXRpb25YICE9PSBfemVyb0RlZykge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gICAgfVxuXG4gICAgaWYgKHNrZXdYICE9PSBfemVyb0RlZyB8fCBza2V3WSAhPT0gX3plcm9EZWcpIHtcbiAgICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgICB9XG5cbiAgICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICAgIH1cblxuICAgIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zIHx8IFwidHJhbnNsYXRlKDAsIDApXCI7XG4gIH0sXG4gICAgICBfcmVuZGVyU1ZHVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJTVkdUcmFuc2Zvcm1zKHJhdGlvLCBjYWNoZSkge1xuICAgIHZhciBfcmVmMiA9IGNhY2hlIHx8IHRoaXMsXG4gICAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICAgIHlQZXJjZW50ID0gX3JlZjIueVBlcmNlbnQsXG4gICAgICAgIHggPSBfcmVmMi54LFxuICAgICAgICB5ID0gX3JlZjIueSxcbiAgICAgICAgcm90YXRpb24gPSBfcmVmMi5yb3RhdGlvbixcbiAgICAgICAgc2tld1ggPSBfcmVmMi5za2V3WCxcbiAgICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgICAgc2NhbGVYID0gX3JlZjIuc2NhbGVYLFxuICAgICAgICBzY2FsZVkgPSBfcmVmMi5zY2FsZVksXG4gICAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgICAgeE9yaWdpbiA9IF9yZWYyLnhPcmlnaW4sXG4gICAgICAgIHlPcmlnaW4gPSBfcmVmMi55T3JpZ2luLFxuICAgICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgICAgeU9mZnNldCA9IF9yZWYyLnlPZmZzZXQsXG4gICAgICAgIGZvcmNlQ1NTID0gX3JlZjIuZm9yY2VDU1MsXG4gICAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgICAgdHkgPSBwYXJzZUZsb2F0KHkpLFxuICAgICAgICBhMTEsXG4gICAgICAgIGEyMSxcbiAgICAgICAgYTEyLFxuICAgICAgICBhMjIsXG4gICAgICAgIHRlbXA7XG5cbiAgICByb3RhdGlvbiA9IHBhcnNlRmxvYXQocm90YXRpb24pO1xuICAgIHNrZXdYID0gcGFyc2VGbG9hdChza2V3WCk7XG4gICAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICAgIGlmIChza2V3WSkge1xuICAgICAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcbiAgICAgIHNrZXdYICs9IHNrZXdZO1xuICAgICAgcm90YXRpb24gKz0gc2tld1k7XG4gICAgfVxuXG4gICAgaWYgKHJvdGF0aW9uIHx8IHNrZXdYKSB7XG4gICAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICAgIHNrZXdYICo9IF9ERUcyUkFEO1xuICAgICAgYTExID0gTWF0aC5jb3Mocm90YXRpb24pICogc2NhbGVYO1xuICAgICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgICAgYTEyID0gTWF0aC5zaW4ocm90YXRpb24gLSBza2V3WCkgKiAtc2NhbGVZO1xuICAgICAgYTIyID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG5cbiAgICAgIGlmIChza2V3WCkge1xuICAgICAgICBza2V3WSAqPSBfREVHMlJBRDtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdYIC0gc2tld1kpO1xuICAgICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICAgIGExMiAqPSB0ZW1wO1xuICAgICAgICBhMjIgKj0gdGVtcDtcblxuICAgICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1kpO1xuICAgICAgICAgIHRlbXAgPSBNYXRoLnNxcnQoMSArIHRlbXAgKiB0ZW1wKTtcbiAgICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgICBhMjEgKj0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhMTEgPSBfcm91bmQoYTExKTtcbiAgICAgIGEyMSA9IF9yb3VuZChhMjEpO1xuICAgICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgICBhMjIgPSBfcm91bmQoYTIyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYTExID0gc2NhbGVYO1xuICAgICAgYTIyID0gc2NhbGVZO1xuICAgICAgYTIxID0gYTEyID0gMDtcbiAgICB9XG5cbiAgICBpZiAodHggJiYgIX4oeCArIFwiXCIpLmluZGV4T2YoXCJweFwiKSB8fCB0eSAmJiAhfih5ICsgXCJcIikuaW5kZXhPZihcInB4XCIpKSB7XG4gICAgICB0eCA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHgsIFwicHhcIik7XG4gICAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gICAgfVxuXG4gICAgaWYgKHhPcmlnaW4gfHwgeU9yaWdpbiB8fCB4T2Zmc2V0IHx8IHlPZmZzZXQpIHtcbiAgICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICAgIHR5ID0gX3JvdW5kKHR5ICsgeU9yaWdpbiAtICh4T3JpZ2luICogYTIxICsgeU9yaWdpbiAqIGEyMikgKyB5T2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgICAgdHggPSBfcm91bmQodHggKyB4UGVyY2VudCAvIDEwMCAqIHRlbXAud2lkdGgpO1xuICAgICAgdHkgPSBfcm91bmQodHkgKyB5UGVyY2VudCAvIDEwMCAqIHRlbXAuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB0ZW1wID0gXCJtYXRyaXgoXCIgKyBhMTEgKyBcIixcIiArIGEyMSArIFwiLFwiICsgYTEyICsgXCIsXCIgKyBhMjIgKyBcIixcIiArIHR4ICsgXCIsXCIgKyB0eSArIFwiKVwiO1xuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdGVtcCk7XG4gICAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTtcbiAgfSxcbiAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4ocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBzdGFydE51bSwgZW5kVmFsdWUpIHtcbiAgICB2YXIgY2FwID0gMzYwLFxuICAgICAgICBpc1N0cmluZyA9IF9pc1N0cmluZyhlbmRWYWx1ZSksXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpICogKGlzU3RyaW5nICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFkXCIpID8gX1JBRDJERUcgOiAxKSxcbiAgICAgICAgY2hhbmdlID0gZW5kTnVtIC0gc3RhcnROdW0sXG4gICAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSArIFwiZGVnXCIsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgcHQ7XG5cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJzaG9ydFwiKSB7XG4gICAgICAgIGNoYW5nZSAlPSBjYXA7XG5cbiAgICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgICAgY2hhbmdlICs9IGNoYW5nZSA8IDAgPyBjYXAgOiAtY2FwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiY3dcIiAmJiBjaGFuZ2UgPCAwKSB7XG4gICAgICAgIGNoYW5nZSA9IChjaGFuZ2UgKyBjYXAgKiBfYmlnTnVtJDEpICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBcImNjd1wiICYmIGNoYW5nZSA+IDApIHtcbiAgICAgICAgY2hhbmdlID0gKGNoYW5nZSAtIGNhcCAqIF9iaWdOdW0kMSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgICBwdC5lID0gZmluYWxWYWx1ZTtcbiAgICBwdC51ID0gXCJkZWdcIjtcblxuICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICByZXR1cm4gcHQ7XG4gIH0sXG4gICAgICBfYXNzaWduID0gZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIHAgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRbcF0gPSBzb3VyY2VbcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcbiAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHMgPSBmdW5jdGlvbiBfYWRkUmF3VHJhbnNmb3JtUFRzKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSB7XG4gICAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuICAgICAgICBleGNsdWRlID0gXCJwZXJzcGVjdGl2ZSxmb3JjZTNELHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW5cIixcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIGVuZENhY2hlLFxuICAgICAgICBwLFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgc3RhcnROdW0sXG4gICAgICAgIGVuZE51bSxcbiAgICAgICAgc3RhcnRVbml0LFxuICAgICAgICBlbmRVbml0O1xuXG4gICAgaWYgKHN0YXJ0Q2FjaGUuc3ZnKSB7XG4gICAgICBzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIik7XG4gICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1zO1xuICAgICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblxuICAgICAgX3JlbW92ZVByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybVByb3ApO1xuXG4gICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHN0YXJ0VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1Qcm9wXTtcbiAgICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuICAgICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gc3RhcnRWYWx1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgICBzdGFydFZhbHVlID0gc3RhcnRDYWNoZVtwXTtcbiAgICAgIGVuZFZhbHVlID0gZW5kQ2FjaGVbcF07XG5cbiAgICAgIGlmIChzdGFydFZhbHVlICE9PSBlbmRWYWx1ZSAmJiBleGNsdWRlLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAgIHN0YXJ0VW5pdCA9IGdldFVuaXQoc3RhcnRWYWx1ZSk7XG4gICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG4gICAgICAgIHBsdWdpbi5fcHQgPSBuZXcgUHJvcFR3ZWVuKHBsdWdpbi5fcHQsIGVuZENhY2hlLCBwLCBzdGFydE51bSwgZW5kTnVtIC0gc3RhcnROdW0sIF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfYXNzaWduKGVuZENhY2hlLCBzdGFydENhY2hlKTtcbiAgfTtcblxuICBfZm9yRWFjaE5hbWUoXCJwYWRkaW5nLG1hcmdpbixXaWR0aCxSYWRpdXNcIiwgZnVuY3Rpb24gKG5hbWUsIGluZGV4KSB7XG4gICAgdmFyIHQgPSBcIlRvcFwiLFxuICAgICAgICByID0gXCJSaWdodFwiLFxuICAgICAgICBiID0gXCJCb3R0b21cIixcbiAgICAgICAgbCA9IFwiTGVmdFwiLFxuICAgICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgIHJldHVybiBpbmRleCA8IDIgPyBuYW1lICsgc2lkZSA6IFwiYm9yZGVyXCIgKyBzaWRlICsgbmFtZTtcbiAgICB9KTtcblxuICAgIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgICAgdmFyIGEsIHZhcnM7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkge1xuICAgICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXQocGx1Z2luLCBwcm9wLCBwcm9wZXJ0eSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIHZhcnMuc3BsaXQoYVswXSkubGVuZ3RoID09PSA1ID8gYVswXSA6IHZhcnM7XG4gICAgICB9XG5cbiAgICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgICB2YXJzID0ge307XG4gICAgICBwcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wLCBpKSB7XG4gICAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgICAgfSk7XG4gICAgICBwbHVnaW4uaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuKTtcbiAgICB9O1xuICB9KTtcblxuICB2YXIgQ1NTUGx1Z2luID0ge1xuICAgIG5hbWU6IFwiY3NzXCIsXG4gICAgcmVnaXN0ZXI6IF9pbml0Q29yZSxcbiAgICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldC5zdHlsZSAmJiB0YXJnZXQubm9kZVR5cGU7XG4gICAgfSxcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLl9wcm9wcyxcbiAgICAgICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICAgICAgZW5kVmFsdWUsXG4gICAgICAgICAgZW5kTnVtLFxuICAgICAgICAgIHN0YXJ0TnVtLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgICAgcCxcbiAgICAgICAgICBzdGFydFVuaXQsXG4gICAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgICByZWxhdGl2ZSxcbiAgICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQsXG4gICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIHNtb290aCxcbiAgICAgICAgICBoYXNQcmlvcml0eSxcbiAgICAgICAgICBpbmxpbmVQcm9wcztcbiAgICAgIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuICAgICAgdGhpcy5zdHlsZXMgPSB0aGlzLnN0eWxlcyB8fCBfZ2V0U3R5bGVTYXZlcih0YXJnZXQpO1xuICAgICAgaW5saW5lUHJvcHMgPSB0aGlzLnN0eWxlcy5wcm9wcztcbiAgICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcblxuICAgICAgZm9yIChwIGluIHZhcnMpIHtcbiAgICAgICAgaWYgKHAgPT09IFwiYXV0b1JvdW5kXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZFZhbHVlID0gdmFyc1twXTtcblxuICAgICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IHR5cGVvZiBlbmRWYWx1ZTtcbiAgICAgICAgc3BlY2lhbFByb3AgPSBfc3BlY2lhbFByb3BzW3BdO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLmNhbGwodHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpO1xuICAgICAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiB+ZW5kVmFsdWUuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgICAgICBlbmRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcGVjaWFsUHJvcCkge1xuICAgICAgICAgIHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChwLnN1YnN0cigwLCAyKSA9PT0gXCItLVwiKSB7XG4gICAgICAgICAgc3RhcnRWYWx1ZSA9IChnZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuZ2V0UHJvcGVydHlWYWx1ZShwKSArIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICBlbmRWYWx1ZSArPSBcIlwiO1xuICAgICAgICAgIF9jb2xvckV4cC5sYXN0SW5kZXggPSAwO1xuXG4gICAgICAgICAgaWYgKCFfY29sb3JFeHAudGVzdChzdGFydFZhbHVlKSkge1xuICAgICAgICAgICAgc3RhcnRVbml0ID0gZ2V0VW5pdChzdGFydFZhbHVlKTtcbiAgICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbmRVbml0ID8gc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydFZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwLCBzdGFydFZhbHVlLCBlbmRVbml0KSArIGVuZFVuaXQpIDogc3RhcnRVbml0ICYmIChlbmRWYWx1ZSArPSBzdGFydFVuaXQpO1xuICAgICAgICAgIHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICAgICAgcHJvcHMucHVzaChwKTtcbiAgICAgICAgICBpbmxpbmVQcm9wcy5wdXNoKHAsIDAsIHN0eWxlW3BdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0QXQgJiYgcCBpbiBzdGFydEF0KSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlID0gdHlwZW9mIHN0YXJ0QXRbcF0gPT09IFwiZnVuY3Rpb25cIiA/IHN0YXJ0QXRbcF0uY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykgOiBzdGFydEF0W3BdO1xuICAgICAgICAgICAgX2lzU3RyaW5nKHN0YXJ0VmFsdWUpICYmIH5zdGFydFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpICYmIChzdGFydFZhbHVlID0gX3JlcGxhY2VSYW5kb20oc3RhcnRWYWx1ZSkpO1xuICAgICAgICAgICAgZ2V0VW5pdChzdGFydFZhbHVlICsgXCJcIikgfHwgc3RhcnRWYWx1ZSA9PT0gXCJhdXRvXCIgfHwgKHN0YXJ0VmFsdWUgKz0gX2NvbmZpZy51bml0c1twXSB8fCBnZXRVbml0KF9nZXQodGFyZ2V0LCBwKSkgfHwgXCJcIik7XG4gICAgICAgICAgICAoc3RhcnRWYWx1ZSArIFwiXCIpLmNoYXJBdCgxKSA9PT0gXCI9XCIgJiYgKHN0YXJ0VmFsdWUgPSBfZ2V0KHRhcmdldCwgcCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXJ0TnVtID0gcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiAmJiBlbmRWYWx1ZS5zdWJzdHIoMCwgMik7XG4gICAgICAgICAgcmVsYXRpdmUgJiYgKGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpKTtcbiAgICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcblxuICAgICAgICAgIGlmIChwIGluIF9wcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0TnVtID0gMDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlubGluZVByb3BzLnB1c2goXCJ2aXNpYmlsaXR5XCIsIDAsIHN0eWxlLnZpc2liaWxpdHkpO1xuXG4gICAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwICE9PSBcInNjYWxlXCIgJiYgcCAhPT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcbiAgICAgICAgICAgICAgfnAuaW5kZXhPZihcIixcIikgJiYgKHAgPSBwLnNwbGl0KFwiLFwiKVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNUcmFuc2Zvcm1SZWxhdGVkID0gcCBpbiBfdHJhbnNmb3JtUHJvcHM7XG5cbiAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlcy5zYXZlKHApO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBlbmRWYWx1ZS5zdWJzdHJpbmcoMCwgNikgPT09IFwidmFyKC0tXCIpIHtcbiAgICAgICAgICAgICAgZW5kVmFsdWUgPSBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIGVuZFZhbHVlLnN1YnN0cmluZyg0LCBlbmRWYWx1ZS5pbmRleE9mKFwiKVwiKSkpO1xuICAgICAgICAgICAgICBlbmROdW0gPSBwYXJzZUZsb2F0KGVuZFZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcbiAgICAgICAgICAgICAgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gICAgICAgICAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSAmJiAhdmFycy5wYXJzZVRyYW5zZm9ybSB8fCBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB2YXJzLnBhcnNlVHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgc21vb3RoID0gdmFycy5zbW9vdGhPcmlnaW4gIT09IGZhbHNlICYmIGNhY2hlLnNtb290aDtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuID0gdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBzdHlsZSwgX3RyYW5zZm9ybVByb3AsIDAsIDEsIGNhY2hlLnJlbmRlclRyYW5zZm9ybSwgY2FjaGUsIDAsIC0xKTtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwID09PSBcInNjYWxlXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBjYWNoZSwgXCJzY2FsZVlcIiwgY2FjaGUuc2NhbGVZLCAocmVsYXRpdmUgPyBfcGFyc2VSZWxhdGl2ZShjYWNoZS5zY2FsZVksIHJlbGF0aXZlICsgZW5kTnVtKSA6IGVuZE51bSkgLSBjYWNoZS5zY2FsZVkgfHwgMCwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgICAgICAgICB0aGlzLl9wdC51ID0gMDtcbiAgICAgICAgICAgICAgcHJvcHMucHVzaChcInNjYWxlWVwiLCBwKTtcbiAgICAgICAgICAgICAgcCArPSBcIlhcIjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgICBpbmxpbmVQcm9wcy5wdXNoKF90cmFuc2Zvcm1PcmlnaW5Qcm9wLCAwLCBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0pO1xuICAgICAgICAgICAgICBlbmRWYWx1ZSA9IF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDAsIHNtb290aCwgMCwgdGhpcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZW5kVW5pdCA9IHBhcnNlRmxvYXQoZW5kVmFsdWUuc3BsaXQoXCIgXCIpWzJdKSB8fCAwO1xuICAgICAgICAgICAgICAgIGVuZFVuaXQgIT09IGNhY2hlLnpPcmlnaW4gJiYgX2FkZE5vblR3ZWVuaW5nUFQodGhpcywgY2FjaGUsIFwiek9yaWdpblwiLCBjYWNoZS56T3JpZ2luLCBlbmRVbml0KTtcblxuICAgICAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBwLCBfZmlyc3RUd29Pbmx5KHN0YXJ0VmFsdWUpLCBfZmlyc3RUd29Pbmx5KGVuZFZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzdmdPcmlnaW5cIikge1xuICAgICAgICAgICAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCBlbmRWYWx1ZSwgMSwgc21vb3RoLCAwLCB0aGlzKTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCBpbiBfcm90YXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4odGhpcywgY2FjaGUsIHAsIHN0YXJ0TnVtLCByZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZFZhbHVlKSA6IGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzbW9vdGhPcmlnaW5cIikge1xuICAgICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwiZm9yY2UzRFwiKSB7XG4gICAgICAgICAgICAgIGNhY2hlW3BdID0gZW5kVmFsdWU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHModGhpcywgZW5kVmFsdWUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgICBwID0gX2NoZWNrUHJvcFByZWZpeChwKSB8fCBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIHAgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgIHN0YXJ0VW5pdCA9IChzdGFydFZhbHVlICsgXCJcIikuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgICAgICBlbmROdW0gfHwgKGVuZE51bSA9IDApO1xuICAgICAgICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpIHx8IChwIGluIF9jb25maWcudW5pdHMgPyBfY29uZmlnLnVuaXRzW3BdIDogc3RhcnRVbml0KTtcbiAgICAgICAgICAgIHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiAoc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpKTtcbiAgICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIChyZWxhdGl2ZSA/IF9wYXJzZVJlbGF0aXZlKHN0YXJ0TnVtLCByZWxhdGl2ZSArIGVuZE51bSkgOiBlbmROdW0pIC0gc3RhcnROdW0sICFpc1RyYW5zZm9ybVJlbGF0ZWQgJiYgKGVuZFVuaXQgPT09IFwicHhcIiB8fCBwID09PSBcInpJbmRleFwiKSAmJiB2YXJzLmF1dG9Sb3VuZCAhPT0gZmFsc2UgPyBfcmVuZGVyUm91bmRlZENTU1Byb3AgOiBfcmVuZGVyQ1NTUHJvcCk7XG4gICAgICAgICAgICB0aGlzLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIGVuZFVuaXQgIT09IFwiJVwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3B0LmIgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgICB0aGlzLl9wdC5yID0gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgICAgaWYgKHAgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0sIHJlbGF0aXZlID8gcmVsYXRpdmUgKyBlbmRWYWx1ZSA6IGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAgIT09IFwicGFyc2VUcmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgICBfbWlzc2luZ1BsdWdpbihwLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbCh0aGlzLCB0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIHJlbGF0aXZlID8gcmVsYXRpdmUgKyBlbmRWYWx1ZSA6IGVuZFZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKHAgaW4gc3R5bGUgPyBpbmxpbmVQcm9wcy5wdXNoKHAsIDAsIHN0eWxlW3BdKSA6IHR5cGVvZiB0YXJnZXRbcF0gPT09IFwiZnVuY3Rpb25cIiA/IGlubGluZVByb3BzLnB1c2gocCwgMiwgdGFyZ2V0W3BdKCkpIDogaW5saW5lUHJvcHMucHVzaChwLCAxLCBzdGFydFZhbHVlIHx8IHRhcmdldFtwXSkpO1xuICAgICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0aGlzKTtcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS50d2Vlbi5fdGltZSB8fCAhX3JldmVydGluZyQxKCkpIHtcbiAgICAgICAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgICAgICAgd2hpbGUgKHB0KSB7XG4gICAgICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5zdHlsZXMucmV2ZXJ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IF9nZXQsXG4gICAgYWxpYXNlczogX3Byb3BlcnR5QWxpYXNlcyxcbiAgICBnZXRTZXR0ZXI6IGZ1bmN0aW9uIGdldFNldHRlcih0YXJnZXQsIHByb3BlcnR5LCBwbHVnaW4pIHtcbiAgICAgIHZhciBwID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG4gICAgICBwICYmIHAuaW5kZXhPZihcIixcIikgPCAwICYmIChwcm9wZXJ0eSA9IHApO1xuICAgICAgcmV0dXJuIHByb3BlcnR5IGluIF90cmFuc2Zvcm1Qcm9wcyAmJiBwcm9wZXJ0eSAhPT0gX3RyYW5zZm9ybU9yaWdpblByb3AgJiYgKHRhcmdldC5fZ3NhcC54IHx8IF9nZXQodGFyZ2V0LCBcInhcIikpID8gcGx1Z2luICYmIF9yZWNlbnRTZXR0ZXJQbHVnaW4gPT09IHBsdWdpbiA/IHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGUgOiBfc2V0dGVyVHJhbnNmb3JtIDogKF9yZWNlbnRTZXR0ZXJQbHVnaW4gPSBwbHVnaW4gfHwge30pICYmIChwcm9wZXJ0eSA9PT0gXCJzY2FsZVwiID8gX3NldHRlclNjYWxlV2l0aFJlbmRlciA6IF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKSA6IHRhcmdldC5zdHlsZSAmJiAhX2lzVW5kZWZpbmVkKHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0pID8gX3NldHRlckNTU1N0eWxlIDogfnByb3BlcnR5LmluZGV4T2YoXCItXCIpID8gX3NldHRlckNTU1Byb3AgOiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpO1xuICAgIH0sXG4gICAgY29yZToge1xuICAgICAgX3JlbW92ZVByb3BlcnR5OiBfcmVtb3ZlUHJvcGVydHksXG4gICAgICBfZ2V0TWF0cml4OiBfZ2V0TWF0cml4XG4gICAgfVxuICB9O1xuICBnc2FwLnV0aWxzLmNoZWNrUHJlZml4ID0gX2NoZWNrUHJvcFByZWZpeDtcbiAgZ3NhcC5jb3JlLmdldFN0eWxlU2F2ZXIgPSBfZ2V0U3R5bGVTYXZlcjtcblxuICAoZnVuY3Rpb24gKHBvc2l0aW9uQW5kU2NhbGUsIHJvdGF0aW9uLCBvdGhlcnMsIGFsaWFzZXMpIHtcbiAgICB2YXIgYWxsID0gX2ZvckVhY2hOYW1lKHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uICsgXCIsXCIgKyBvdGhlcnMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdHJhbnNmb3JtUHJvcHNbbmFtZV0gPSAxO1xuICAgIH0pO1xuXG4gICAgX2ZvckVhY2hOYW1lKHJvdGF0aW9uLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwiZGVnXCI7XG4gICAgICBfcm90YXRpb25hbFByb3BlcnRpZXNbbmFtZV0gPSAxO1xuICAgIH0pO1xuXG4gICAgX3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xuXG4gICAgX2ZvckVhY2hOYW1lKGFsaWFzZXMsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgc3BsaXQgPSBuYW1lLnNwbGl0KFwiOlwiKTtcbiAgICAgIF9wcm9wZXJ0eUFsaWFzZXNbc3BsaXRbMV1dID0gYWxsW3NwbGl0WzBdXTtcbiAgICB9KTtcbiAgfSkoXCJ4LHkseixzY2FsZSxzY2FsZVgsc2NhbGVZLHhQZXJjZW50LHlQZXJjZW50XCIsIFwicm90YXRpb24scm90YXRpb25YLHJvdGF0aW9uWSxza2V3WCxza2V3WVwiLCBcInRyYW5zZm9ybSx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luLGZvcmNlM0Qsc21vb3RoT3JpZ2luLHRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsIFwiMDp0cmFuc2xhdGVYLDE6dHJhbnNsYXRlWSwyOnRyYW5zbGF0ZVosODpyb3RhdGUsODpyb3RhdGlvblosODpyb3RhdGVaLDk6cm90YXRlWCwxMDpyb3RhdGVZXCIpO1xuXG4gIF9mb3JFYWNoTmFtZShcIngseSx6LHRvcCxyaWdodCxib3R0b20sbGVmdCx3aWR0aCxoZWlnaHQsZm9udFNpemUscGFkZGluZyxtYXJnaW4scGVyc3BlY3RpdmVcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfY29uZmlnLnVuaXRzW25hbWVdID0gXCJweFwiO1xuICB9KTtcblxuICBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XG5cbiAgdmFyIGdzYXBXaXRoQ1NTID0gZ3NhcC5yZWdpc3RlclBsdWdpbihDU1NQbHVnaW4pIHx8IGdzYXAsXG4gICAgICBUd2Vlbk1heFdpdGhDU1MgPSBnc2FwV2l0aENTUy5jb3JlLlR3ZWVuO1xuXG4gIGV4cG9ydHMuQmFjayA9IEJhY2s7XG4gIGV4cG9ydHMuQm91bmNlID0gQm91bmNlO1xuICBleHBvcnRzLkNTU1BsdWdpbiA9IENTU1BsdWdpbjtcbiAgZXhwb3J0cy5DaXJjID0gQ2lyYztcbiAgZXhwb3J0cy5DdWJpYyA9IEN1YmljO1xuICBleHBvcnRzLkVsYXN0aWMgPSBFbGFzdGljO1xuICBleHBvcnRzLkV4cG8gPSBFeHBvO1xuICBleHBvcnRzLkxpbmVhciA9IExpbmVhcjtcbiAgZXhwb3J0cy5Qb3dlcjAgPSBQb3dlcjA7XG4gIGV4cG9ydHMuUG93ZXIxID0gUG93ZXIxO1xuICBleHBvcnRzLlBvd2VyMiA9IFBvd2VyMjtcbiAgZXhwb3J0cy5Qb3dlcjMgPSBQb3dlcjM7XG4gIGV4cG9ydHMuUG93ZXI0ID0gUG93ZXI0O1xuICBleHBvcnRzLlF1YWQgPSBRdWFkO1xuICBleHBvcnRzLlF1YXJ0ID0gUXVhcnQ7XG4gIGV4cG9ydHMuUXVpbnQgPSBRdWludDtcbiAgZXhwb3J0cy5TaW5lID0gU2luZTtcbiAgZXhwb3J0cy5TdGVwcGVkRWFzZSA9IFN0ZXBwZWRFYXNlO1xuICBleHBvcnRzLlN0cm9uZyA9IFN0cm9uZztcbiAgZXhwb3J0cy5UaW1lbGluZUxpdGUgPSBUaW1lbGluZTtcbiAgZXhwb3J0cy5UaW1lbGluZU1heCA9IFRpbWVsaW5lO1xuICBleHBvcnRzLlR3ZWVuTGl0ZSA9IFR3ZWVuO1xuICBleHBvcnRzLlR3ZWVuTWF4ID0gVHdlZW5NYXhXaXRoQ1NTO1xuICBleHBvcnRzLmRlZmF1bHQgPSBnc2FwV2l0aENTUztcbiAgZXhwb3J0cy5nc2FwID0gZ3NhcFdpdGhDU1M7XG5cbiAgaWYgKHR5cGVvZih3aW5kb3cpID09PSAndW5kZWZpbmVkJyB8fCB3aW5kb3cgIT09IGV4cG9ydHMpIHtPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO30gZWxzZSB7ZGVsZXRlIHdpbmRvdy5kZWZhdWx0O31cblxufSkpKTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsInNlbGYiLCJ3aW5kb3ciLCJfaW5oZXJpdHNMb29zZSIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX19wcm90b19fIiwiX2Fzc2VydFRoaXNJbml0aWFsaXplZCIsIlJlZmVyZW5jZUVycm9yIiwiX2NvbmZpZyIsImF1dG9TbGVlcCIsImZvcmNlM0QiLCJudWxsVGFyZ2V0V2FybiIsInVuaXRzIiwibGluZUhlaWdodCIsIl9kZWZhdWx0cyIsImR1cmF0aW9uIiwib3ZlcndyaXRlIiwiZGVsYXkiLCJfc3VwcHJlc3NPdmVyd3JpdGVzIiwiX3JldmVydGluZyIsIl9jb250ZXh0IiwiX2JpZ051bSIsIl90aW55TnVtIiwiXzJQSSIsIk1hdGgiLCJQSSIsIl9IQUxGX1BJIiwiX2dzSUQiLCJfc3FydCIsInNxcnQiLCJfY29zIiwiY29zIiwiX3NpbiIsInNpbiIsIl9pc1N0cmluZyIsInZhbHVlIiwiX2lzRnVuY3Rpb24iLCJfaXNOdW1iZXIiLCJfaXNVbmRlZmluZWQiLCJfaXNPYmplY3QiLCJfaXNOb3RGYWxzZSIsIl93aW5kb3dFeGlzdHMiLCJfaXNGdW5jT3JTdHJpbmciLCJfaXNUeXBlZEFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJfaXNBcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIl9zdHJpY3ROdW1FeHAiLCJfbnVtRXhwIiwiX251bVdpdGhVbml0RXhwIiwiX2NvbXBsZXhTdHJpbmdOdW1FeHAiLCJfcmVsRXhwIiwiX2RlbGltaXRlZFZhbHVlRXhwIiwiX3VuaXRFeHAiLCJfZ2xvYmFsVGltZWxpbmUiLCJfd2luIiwiX2NvcmVJbml0dGVkIiwiX2RvYyIsIl9nbG9iYWxzIiwiX2luc3RhbGxTY29wZSIsIl9jb3JlUmVhZHkiLCJfaW5zdGFsbCIsInNjb3BlIiwiX21lcmdlIiwiZ3NhcCIsIl9taXNzaW5nUGx1Z2luIiwicHJvcGVydHkiLCJjb25zb2xlIiwid2FybiIsIl93YXJuIiwibWVzc2FnZSIsInN1cHByZXNzIiwiX2FkZEdsb2JhbCIsIm5hbWUiLCJvYmoiLCJfZW1wdHlGdW5jIiwiX3N0YXJ0QXRSZXZlcnRDb25maWciLCJzdXBwcmVzc0V2ZW50cyIsImlzU3RhcnQiLCJraWxsIiwiX3JldmVydENvbmZpZ05vS2lsbCIsIl9yZXZlcnRDb25maWciLCJfcmVzZXJ2ZWRQcm9wcyIsIl9sYXp5VHdlZW5zIiwiX2xhenlMb29rdXAiLCJfbGFzdFJlbmRlcmVkRnJhbWUiLCJfcGx1Z2lucyIsIl9lZmZlY3RzIiwiX25leHRHQ0ZyYW1lIiwiX2hhcm5lc3NQbHVnaW5zIiwiX2NhbGxiYWNrTmFtZXMiLCJfaGFybmVzcyIsInRhcmdldHMiLCJ0YXJnZXQiLCJoYXJuZXNzUGx1Z2luIiwiaSIsIl9nc2FwIiwiaGFybmVzcyIsImxlbmd0aCIsInRhcmdldFRlc3QiLCJHU0NhY2hlIiwic3BsaWNlIiwiX2dldENhY2hlIiwidG9BcnJheSIsIl9nZXRQcm9wZXJ0eSIsInYiLCJnZXRBdHRyaWJ1dGUiLCJfZm9yRWFjaE5hbWUiLCJuYW1lcyIsImZ1bmMiLCJzcGxpdCIsImZvckVhY2giLCJfcm91bmQiLCJyb3VuZCIsIl9yb3VuZFByZWNpc2UiLCJfcGFyc2VSZWxhdGl2ZSIsInN0YXJ0Iiwib3BlcmF0b3IiLCJjaGFyQXQiLCJlbmQiLCJwYXJzZUZsb2F0Iiwic3Vic3RyIiwiX2FycmF5Q29udGFpbnNBbnkiLCJ0b1NlYXJjaCIsInRvRmluZCIsImwiLCJpbmRleE9mIiwiX2xhenlSZW5kZXIiLCJhIiwic2xpY2UiLCJ0d2VlbiIsIl9sYXp5IiwicmVuZGVyIiwiX2lzUmV2ZXJ0V29ydGh5IiwiYW5pbWF0aW9uIiwiX2luaXR0ZWQiLCJfc3RhcnRBdCIsImFkZCIsIl9sYXp5U2FmZVJlbmRlciIsInRpbWUiLCJmb3JjZSIsIl9udW1lcmljSWZQb3NzaWJsZSIsIm4iLCJtYXRjaCIsInRyaW0iLCJfcGFzc1Rocm91Z2giLCJwIiwiX3NldERlZmF1bHRzIiwiZGVmYXVsdHMiLCJfc2V0S2V5ZnJhbWVEZWZhdWx0cyIsImV4Y2x1ZGVEdXJhdGlvbiIsImJhc2UiLCJ0b01lcmdlIiwiX21lcmdlRGVlcCIsIl9jb3B5RXhjbHVkaW5nIiwiZXhjbHVkaW5nIiwiY29weSIsIl9pbmhlcml0RGVmYXVsdHMiLCJ2YXJzIiwicGFyZW50Iiwia2V5ZnJhbWVzIiwiaW5oZXJpdCIsIl9kcCIsIl9hcnJheXNNYXRjaCIsImExIiwiYTIiLCJfYWRkTGlua2VkTGlzdEl0ZW0iLCJjaGlsZCIsImZpcnN0UHJvcCIsImxhc3RQcm9wIiwic29ydEJ5IiwicHJldiIsInQiLCJfcHJldiIsIl9uZXh0IiwiX3JlbW92ZUxpbmtlZExpc3RJdGVtIiwibmV4dCIsIl9yZW1vdmVGcm9tUGFyZW50Iiwib25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSIsImF1dG9SZW1vdmVDaGlsZHJlbiIsInJlbW92ZSIsIl9hY3QiLCJfdW5jYWNoZSIsIl9lbmQiLCJfZHVyIiwiX3N0YXJ0IiwiX2RpcnR5IiwiX3JlY2FjaGVBbmNlc3RvcnMiLCJ0b3RhbER1cmF0aW9uIiwiX3Jld2luZFN0YXJ0QXQiLCJ0b3RhbFRpbWUiLCJyZXZlcnQiLCJpbW1lZGlhdGVSZW5kZXIiLCJhdXRvUmV2ZXJ0IiwiX2hhc05vUGF1c2VkQW5jZXN0b3JzIiwiX3RzIiwiX2VsYXBzZWRDeWNsZUR1cmF0aW9uIiwiX3JlcGVhdCIsIl9hbmltYXRpb25DeWNsZSIsIl90VGltZSIsIl9yRGVsYXkiLCJ0VGltZSIsImN5Y2xlRHVyYXRpb24iLCJ3aG9sZSIsImZsb29yIiwiX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUiLCJwYXJlbnRUaW1lIiwiX3REdXIiLCJfc2V0RW5kIiwiYWJzIiwiX3J0cyIsIl9hbGlnblBsYXloZWFkIiwic21vb3RoQ2hpbGRUaW1pbmciLCJfdGltZSIsIl9wb3N0QWRkQ2hlY2tzIiwidGltZWxpbmUiLCJyYXdUaW1lIiwiX2NsYW1wIiwiX3pUaW1lIiwiX2FkZFRvVGltZWxpbmUiLCJwb3NpdGlvbiIsInNraXBDaGVja3MiLCJfcGFyc2VQb3NpdGlvbiIsIl9kZWxheSIsInRpbWVTY2FsZSIsIl9zb3J0IiwiX2lzRnJvbU9yRnJvbVN0YXJ0IiwiX3JlY2VudCIsIl9zY3JvbGxUcmlnZ2VyIiwidHJpZ2dlciIsIlNjcm9sbFRyaWdnZXIiLCJfYXR0ZW1wdEluaXRUd2VlbiIsIl9pbml0VHdlZW4iLCJfcHQiLCJsYXp5IiwiX3RpY2tlciIsImZyYW1lIiwicHVzaCIsIl9wYXJlbnRQbGF5aGVhZElzQmVmb3JlU3RhcnQiLCJfcmVmIiwiX2xvY2siLCJfcmVmMiIsImRhdGEiLCJfcmVuZGVyWmVyb0R1cmF0aW9uVHdlZW4iLCJwcmV2UmF0aW8iLCJyYXRpbyIsInJlcGVhdERlbGF5IiwicHQiLCJpdGVyYXRpb24iLCJwcmV2SXRlcmF0aW9uIiwiX3lveW8iLCJyZXBlYXRSZWZyZXNoIiwiaW52YWxpZGF0ZSIsIl9mcm9tIiwiciIsImQiLCJfb25VcGRhdGUiLCJfY2FsbGJhY2siLCJfcHJvbSIsIl9maW5kTmV4dFBhdXNlVHdlZW4iLCJwcmV2VGltZSIsIl9maXJzdCIsIl9sYXN0IiwiX3NldER1cmF0aW9uIiwic2tpcFVuY2FjaGUiLCJsZWF2ZVBsYXloZWFkIiwicmVwZWF0IiwiZHVyIiwidG90YWxQcm9ncmVzcyIsIl9vblVwZGF0ZVRvdGFsRHVyYXRpb24iLCJUaW1lbGluZSIsIl96ZXJvUG9zaXRpb24iLCJlbmRUaW1lIiwicGVyY2VudEFuaW1hdGlvbiIsImxhYmVscyIsInJlY2VudCIsImNsaXBwZWREdXJhdGlvbiIsIm9mZnNldCIsImlzUGVyY2VudCIsImlzTmFOIiwicmVwbGFjZSIsIl9jcmVhdGVUd2VlblR5cGUiLCJ0eXBlIiwicGFyYW1zIiwiaXNMZWdhY3kiLCJ2YXJzSW5kZXgiLCJpclZhcnMiLCJydW5CYWNrd2FyZHMiLCJzdGFydEF0IiwiVHdlZW4iLCJfY29uZGl0aW9uYWxSZXR1cm4iLCJtaW4iLCJtYXgiLCJnZXRVbml0IiwiZXhlYyIsImNsYW1wIiwiX3NsaWNlIiwiX2lzQXJyYXlMaWtlIiwibm9uRW1wdHkiLCJub2RlVHlwZSIsIl9mbGF0dGVuIiwiYXIiLCJsZWF2ZVN0cmluZ3MiLCJhY2N1bXVsYXRvciIsIl9hY2N1bXVsYXRvciIsImFwcGx5Iiwic2VsZWN0b3IiLCJfd2FrZSIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZWwiLCJjdXJyZW50IiwibmF0aXZlRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzaHVmZmxlIiwic29ydCIsInJhbmRvbSIsImRpc3RyaWJ1dGUiLCJlYWNoIiwiZWFzZSIsIl9wYXJzZUVhc2UiLCJmcm9tIiwiY2FjaGUiLCJpc0RlY2ltYWwiLCJyYXRpb3MiLCJheGlzIiwicmF0aW9YIiwicmF0aW9ZIiwiY2VudGVyIiwiZWRnZXMiLCJkaXN0YW5jZXMiLCJvcmlnaW5YIiwib3JpZ2luWSIsIngiLCJ5IiwiaiIsIndyYXBBdCIsImdyaWQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwiYW1vdW50IiwiYiIsInUiLCJfaW52ZXJ0RWFzZSIsIl9yb3VuZE1vZGlmaWVyIiwicG93IiwicmF3Iiwic25hcCIsInNuYXBUbyIsInJhZGl1cyIsImlzMkQiLCJ2YWx1ZXMiLCJpbmNyZW1lbnQiLCJjbG9zZXN0IiwiZHgiLCJkeSIsInJvdW5kaW5nSW5jcmVtZW50IiwicmV0dXJuRnVuY3Rpb24iLCJwaXBlIiwiX2xlbiIsImFyZ3VtZW50cyIsImZ1bmN0aW9ucyIsIl9rZXkiLCJyZWR1Y2UiLCJmIiwidW5pdGl6ZSIsInVuaXQiLCJub3JtYWxpemUiLCJtYXBSYW5nZSIsIl93cmFwQXJyYXkiLCJ3cmFwcGVyIiwiaW5kZXgiLCJ3cmFwIiwicmFuZ2UiLCJ3cmFwWW95byIsInRvdGFsIiwiX3JlcGxhY2VSYW5kb20iLCJzIiwibnVtcyIsImluTWluIiwiaW5NYXgiLCJvdXRNaW4iLCJvdXRNYXgiLCJpblJhbmdlIiwib3V0UmFuZ2UiLCJpbnRlcnBvbGF0ZSIsInByb2dyZXNzIiwibXV0YXRlIiwiaXNTdHJpbmciLCJtYXN0ZXIiLCJpbnRlcnBvbGF0b3JzIiwiaWwiLCJfYWRkUHJvcFR3ZWVuIiwiX3JlbmRlclByb3BUd2VlbnMiLCJfZ2V0TGFiZWxJbkRpcmVjdGlvbiIsImZyb21UaW1lIiwiYmFja3dhcmQiLCJkaXN0YW5jZSIsImxhYmVsIiwiZXhlY3V0ZUxhenlGaXJzdCIsImNhbGxiYWNrIiwicHJldkNvbnRleHQiLCJjb250ZXh0IiwiX2N0eCIsInJlc3VsdCIsImNhbGxiYWNrU2NvcGUiLCJfaW50ZXJydXB0Iiwic2Nyb2xsVHJpZ2dlciIsIl9xdWlja1R3ZWVuIiwiX3JlZ2lzdGVyUGx1Z2luUXVldWUiLCJfY3JlYXRlUGx1Z2luIiwiY29uZmlnIiwiaGVhZGxlc3MiLCJpc0Z1bmMiLCJQbHVnaW4iLCJpbml0IiwiX3Byb3BzIiwiaW5zdGFuY2VEZWZhdWx0cyIsIl9raWxsUHJvcFR3ZWVuc09mIiwibW9kaWZpZXIiLCJfYWRkUGx1Z2luTW9kaWZpZXIiLCJyYXdWYXJzIiwic3RhdGljcyIsImdldCIsImdldFNldHRlciIsIl9nZXRTZXR0ZXIiLCJhbGlhc2VzIiwicmVnaXN0ZXIiLCJwcm9wIiwidG9VcHBlckNhc2UiLCJQcm9wVHdlZW4iLCJfMjU1IiwiX2NvbG9yTG9va3VwIiwiYXF1YSIsImxpbWUiLCJzaWx2ZXIiLCJibGFjayIsIm1hcm9vbiIsInRlYWwiLCJibHVlIiwibmF2eSIsIndoaXRlIiwib2xpdmUiLCJ5ZWxsb3ciLCJvcmFuZ2UiLCJncmF5IiwicHVycGxlIiwiZ3JlZW4iLCJyZWQiLCJwaW5rIiwiY3lhbiIsInRyYW5zcGFyZW50IiwiX2h1ZSIsImgiLCJtMSIsIm0yIiwic3BsaXRDb2xvciIsInRvSFNMIiwiZm9yY2VBbHBoYSIsImciLCJ3YXNIU0wiLCJwYXJzZUludCIsIm1hcCIsIk51bWJlciIsIl9jb2xvck9yZGVyRGF0YSIsImMiLCJfY29sb3JFeHAiLCJfZm9ybWF0Q29sb3JzIiwib3JkZXJNYXRjaERhdGEiLCJjb2xvcnMiLCJzaGVsbCIsImNvbG9yIiwiam9pbiIsInNoaWZ0IiwiUmVnRXhwIiwiX2hzbEV4cCIsIl9jb2xvclN0cmluZ0ZpbHRlciIsImNvbWJpbmVkIiwibGFzdEluZGV4IiwidGVzdCIsIl90aWNrZXJBY3RpdmUiLCJfZ2V0VGltZSIsIkRhdGUiLCJub3ciLCJfbGFnVGhyZXNob2xkIiwiX2FkanVzdGVkTGFnIiwiX3N0YXJ0VGltZSIsIl9sYXN0VXBkYXRlIiwiX2dhcCIsIl9uZXh0VGltZSIsIl9saXN0ZW5lcnMiLCJfaWQiLCJfcmVxIiwiX3JhZiIsIl9zZWxmIiwiX2RlbHRhIiwiX2kiLCJfdGljayIsImVsYXBzZWQiLCJtYW51YWwiLCJvdmVybGFwIiwiZGlzcGF0Y2giLCJ0aWNrIiwiZGVsdGFSYXRpbyIsImZwcyIsIndha2UiLCJkb2N1bWVudCIsImdzYXBWZXJzaW9ucyIsInZlcnNpb24iLCJHcmVlblNvY2tHbG9iYWxzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2xlZXAiLCJzZXRUaW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJjbGVhclRpbWVvdXQiLCJsYWdTbW9vdGhpbmciLCJ0aHJlc2hvbGQiLCJhZGp1c3RlZExhZyIsIkluZmluaXR5IiwiX2ZwcyIsIm9uY2UiLCJwcmlvcml0aXplIiwiX2Vhc2VNYXAiLCJfY3VzdG9tRWFzZUV4cCIsIl9xdW90ZXNFeHAiLCJfcGFyc2VPYmplY3RJblN0cmluZyIsImtleSIsInZhbCIsInBhcnNlZFZhbCIsImxhc3RJbmRleE9mIiwiX3ZhbHVlSW5QYXJlbnRoZXNlcyIsIm9wZW4iLCJjbG9zZSIsIm5lc3RlZCIsInN1YnN0cmluZyIsIl9jb25maWdFYXNlRnJvbVN0cmluZyIsIl9DRSIsIl9wcm9wYWdhdGVZb3lvRWFzZSIsImlzWW95byIsInlveW9FYXNlIiwiX2Vhc2UiLCJfeUVhc2UiLCJkZWZhdWx0RWFzZSIsIl9pbnNlcnRFYXNlIiwiZWFzZUluIiwiZWFzZU91dCIsImVhc2VJbk91dCIsImxvd2VyY2FzZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsIl9lYXNlSW5PdXRGcm9tT3V0IiwiX2NvbmZpZ0VsYXN0aWMiLCJhbXBsaXR1ZGUiLCJwZXJpb2QiLCJwMSIsInAyIiwicDMiLCJhc2luIiwiX2NvbmZpZ0JhY2siLCJvdmVyc2hvb3QiLCJwb3dlciIsIkxpbmVhciIsImVhc2VOb25lIiwibm9uZSIsIm4xIiwibjIiLCJuMyIsIlN0ZXBwZWRFYXNlIiwic3RlcHMiLCJpbW1lZGlhdGVTdGFydCIsImlkIiwic2V0IiwiQW5pbWF0aW9uIiwieW95byIsIl9wcm90byIsInN0YXJ0VGltZSIsIl90b3RhbFRpbWUiLCJfcHRMb29rdXAiLCJfcFRpbWUiLCJfcHMiLCJwYXVzZWQiLCJpbmNsdWRlUmVwZWF0cyIsIndyYXBSZXBlYXRzIiwicHJldklzUmV2ZXJ0aW5nIiwiZ2xvYmFsVGltZSIsIl9zYXQiLCJzZWVrIiwicmVzdGFydCIsImluY2x1ZGVEZWxheSIsInBsYXkiLCJyZXZlcnNlZCIsInJldmVyc2UiLCJwYXVzZSIsImF0VGltZSIsInJlc3VtZSIsImlzQWN0aXZlIiwiZXZlbnRDYWxsYmFjayIsInRoZW4iLCJvbkZ1bGZpbGxlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiX3Jlc29sdmUiLCJfdGhlbiIsIl9BbmltYXRpb24iLCJfdGhpcyIsInNvcnRDaGlsZHJlbiIsIl9wcm90bzIiLCJ0byIsImZyb21UbyIsImZyb21WYXJzIiwidG9WYXJzIiwiZGVsYXllZENhbGwiLCJzdGFnZ2VyVG8iLCJzdGFnZ2VyIiwib25Db21wbGV0ZUFsbCIsIm9uQ29tcGxldGVBbGxQYXJhbXMiLCJvbkNvbXBsZXRlIiwib25Db21wbGV0ZVBhcmFtcyIsInN0YWdnZXJGcm9tIiwic3RhZ2dlckZyb21UbyIsInREdXIiLCJjcm9zc2luZ1N0YXJ0IiwicHJldlBhdXNlZCIsInBhdXNlVHdlZW4iLCJwcmV2U3RhcnQiLCJyZXdpbmRpbmciLCJkb2VzV3JhcCIsIm9uUmVwZWF0IiwiX2hhc1BhdXNlIiwiX2ZvcmNpbmciLCJvblVwZGF0ZSIsImFkanVzdGVkVGltZSIsIl90aGlzMiIsImFkZExhYmVsIiwiZ2V0Q2hpbGRyZW4iLCJ0d2VlbnMiLCJ0aW1lbGluZXMiLCJpZ25vcmVCZWZvcmVUaW1lIiwiZ2V0QnlJZCIsImFuaW1hdGlvbnMiLCJyZW1vdmVMYWJlbCIsImtpbGxUd2VlbnNPZiIsIl90b3RhbFRpbWUyIiwiYWRkUGF1c2UiLCJyZW1vdmVQYXVzZSIsInByb3BzIiwib25seUFjdGl2ZSIsImdldFR3ZWVuc09mIiwiX292ZXJ3cml0aW5nVHdlZW4iLCJwYXJzZWRUYXJnZXRzIiwiaXNHbG9iYWxUaW1lIiwiY2hpbGRyZW4iLCJfdGFyZ2V0cyIsInR3ZWVuVG8iLCJ0bCIsIl92YXJzIiwiX29uU3RhcnQiLCJvblN0YXJ0Iiwib25TdGFydFBhcmFtcyIsImluaXR0ZWQiLCJ0d2VlbkZyb21UbyIsImZyb21Qb3NpdGlvbiIsInRvUG9zaXRpb24iLCJuZXh0TGFiZWwiLCJhZnRlclRpbWUiLCJwcmV2aW91c0xhYmVsIiwiYmVmb3JlVGltZSIsImN1cnJlbnRMYWJlbCIsInNoaWZ0Q2hpbGRyZW4iLCJhZGp1c3RMYWJlbHMiLCJzb2Z0IiwiY2xlYXIiLCJpbmNsdWRlTGFiZWxzIiwidXBkYXRlUm9vdCIsIl9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuIiwic2V0dGVyIiwic3RyaW5nRmlsdGVyIiwiZnVuY1BhcmFtIiwiX3JlbmRlckNvbXBsZXhTdHJpbmciLCJtYXRjaEluZGV4Iiwic3RhcnROdW1zIiwiZW5kTnVtIiwiY2h1bmsiLCJzdGFydE51bSIsImhhc1JhbmRvbSIsImUiLCJtIiwiZnAiLCJvcHRpb25hbCIsImN1cnJlbnRWYWx1ZSIsInBhcnNlZFN0YXJ0IiwiX3NldHRlclBsYWluIiwiX3NldHRlckZ1bmNXaXRoUGFyYW0iLCJfc2V0dGVyRnVuYyIsIl9mb3JjZUFsbFByb3BUd2VlbnMiLCJfcmVuZGVyQm9vbGVhbiIsIl9yZW5kZXJQbGFpbiIsIl9wcm9jZXNzVmFycyIsIl9wYXJzZUZ1bmNPclN0cmluZyIsInN0eWxlIiwiX2NoZWNrUGx1Z2luIiwicGx1Z2luIiwicHRMb29rdXAiLCJwcmlvcml0eSIsInByZXZTdGFydEF0IiwiZnVsbFRhcmdldHMiLCJhdXRvT3ZlcndyaXRlIiwiX292ZXJ3cml0ZSIsImNsZWFuVmFycyIsImhhc1ByaW9yaXR5IiwiZ3NEYXRhIiwiaGFybmVzc1ZhcnMiLCJvdmVyd3JpdHRlbiIsIl9wdENhY2hlIiwiX29wIiwiX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSIsIl9vbkluaXQiLCJfdXBkYXRlUHJvcFR3ZWVucyIsInN0YXJ0SXNSZWxhdGl2ZSIsInNraXBSZWN1cnNpb24iLCJwdENhY2hlIiwicm9vdFBUIiwibG9va3VwIiwiX2FkZEFsaWFzZXNUb1ZhcnMiLCJwcm9wZXJ0eUFsaWFzZXMiLCJfcGFyc2VLZXlmcmFtZSIsImFsbFByb3BzIiwiZWFzZUVhY2giLCJfc3RhZ2dlclR3ZWVuUHJvcHMiLCJfc3RhZ2dlclByb3BzVG9Ta2lwIiwiX0FuaW1hdGlvbjIiLCJza2lwSW5oZXJpdCIsIl90aGlzMyIsIl90aGlzMyR2YXJzIiwiY3VyVGFyZ2V0Iiwic3RhZ2dlckZ1bmMiLCJzdGFnZ2VyVmFyc1RvTWVyZ2UiLCJrZiIsIl9wcm90bzMiLCJpc05lZ2F0aXZlIiwicmVzZXRUbyIsImtpbGxpbmdUYXJnZXRzIiwicHJvcFR3ZWVuTG9va3VwIiwiZmlyc3RQVCIsIm92ZXJ3cml0dGVuUHJvcHMiLCJjdXJMb29rdXAiLCJjdXJPdmVyd3JpdGVQcm9wcyIsIm9uUmV2ZXJzZUNvbXBsZXRlIiwib25SZXZlcnNlQ29tcGxldGVQYXJhbXMiLCJfc2V0dGVyQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nIiwib3AiLCJkZXAiLCJfc2V0dGVyV2l0aE1vZGlmaWVyIiwibVNldCIsIm10IiwicHQyIiwiZmlyc3QiLCJsYXN0IiwicHIiLCJjaGFuZ2UiLCJyZW5kZXJlciIsIl9wcm90bzQiLCJUd2Vlbk1heCIsIlR3ZWVuTGl0ZSIsIlRpbWVsaW5lTGl0ZSIsIlRpbWVsaW5lTWF4IiwiX21lZGlhIiwiX2VtcHR5QXJyYXkiLCJfbGFzdE1lZGlhVGltZSIsIl9jb250ZXh0SUQiLCJfZGlzcGF0Y2giLCJfb25NZWRpYUNoYW5nZSIsIm1hdGNoZXMiLCJxdWVyaWVzIiwiY29uZGl0aW9ucyIsImFueU1hdGNoIiwidG9nZ2xlZCIsIm1hdGNoTWVkaWEiLCJvbk1hdGNoIiwiQ29udGV4dCIsIl9yIiwiaXNSZXZlcnRlZCIsIl9wcm90bzUiLCJwcmV2U2VsZWN0b3IiLCJpZ25vcmUiLCJnZXRUd2VlbnMiLCJfdGhpczQiLCJvIiwiTWF0Y2hNZWRpYSIsImNvbnRleHRzIiwiX3Byb3RvNiIsImNvbmQiLCJtcSIsImFjdGl2ZSIsImFkZExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlZ2lzdGVyUGx1Z2luIiwiX2xlbjIiLCJhcmdzIiwiX2tleTIiLCJnZXRQcm9wZXJ0eSIsInVuY2FjaGUiLCJnZXR0ZXIiLCJmb3JtYXQiLCJxdWlja1NldHRlciIsInNldHRlcnMiLCJxdWlja1RvIiwiX3NldERlZmF1bHRzMiIsImlzVHdlZW5pbmciLCJyZWdpc3RlckVmZmVjdCIsIl9yZWYzIiwiZWZmZWN0IiwicGx1Z2lucyIsImV4dGVuZFRpbWVsaW5lIiwicGx1Z2luTmFtZSIsInJlZ2lzdGVyRWFzZSIsInBhcnNlRWFzZSIsImV4cG9ydFJvb3QiLCJpbmNsdWRlRGVsYXllZENhbGxzIiwibWF0Y2hNZWRpYVJlZnJlc2giLCJmb3VuZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1dGlscyIsImluc3RhbGwiLCJlZmZlY3RzIiwidGlja2VyIiwiZ2xvYmFsVGltZWxpbmUiLCJjb3JlIiwiZ2xvYmFscyIsImdldENhY2hlIiwicmV2ZXJ0aW5nIiwidG9BZGQiLCJzdXBwcmVzc092ZXJ3cml0ZXMiLCJfZ2V0UGx1Z2luUHJvcFR3ZWVuIiwiX2FkZE1vZGlmaWVycyIsIm1vZGlmaWVycyIsIl9idWlsZE1vZGlmaWVyUGx1Z2luIiwidGVtcCIsIlBvd2VyMCIsIlBvd2VyMSIsIlBvd2VyMiIsIlBvd2VyMyIsIlBvd2VyNCIsIlF1YWQiLCJDdWJpYyIsIlF1YXJ0IiwiUXVpbnQiLCJTdHJvbmciLCJFbGFzdGljIiwiQmFjayIsIkJvdW5jZSIsIlNpbmUiLCJFeHBvIiwiQ2lyYyIsIl93aW4kMSIsIl9kb2MkMSIsIl9kb2NFbGVtZW50IiwiX3BsdWdpbkluaXR0ZWQiLCJfdGVtcERpdiIsIl90ZW1wRGl2U3R5bGVyIiwiX3JlY2VudFNldHRlclBsdWdpbiIsIl9yZXZlcnRpbmckMSIsIl93aW5kb3dFeGlzdHMkMSIsIl90cmFuc2Zvcm1Qcm9wcyIsIl9SQUQyREVHIiwiX0RFRzJSQUQiLCJfYXRhbjIiLCJhdGFuMiIsIl9iaWdOdW0kMSIsIl9jYXBzRXhwIiwiX2hvcml6b250YWxFeHAiLCJfY29tcGxleEV4cCIsIl9wcm9wZXJ0eUFsaWFzZXMiLCJhdXRvQWxwaGEiLCJzY2FsZSIsImFscGhhIiwiX3JlbmRlckNTU1Byb3AiLCJfcmVuZGVyUHJvcFdpdGhFbmQiLCJfcmVuZGVyQ1NTUHJvcFdpdGhCZWdpbm5pbmciLCJfcmVuZGVyUm91bmRlZENTU1Byb3AiLCJfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSIsIl9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kIiwiX3NldHRlckNTU1N0eWxlIiwiX3NldHRlckNTU1Byb3AiLCJzZXRQcm9wZXJ0eSIsIl9zZXR0ZXJUcmFuc2Zvcm0iLCJfc2V0dGVyU2NhbGUiLCJzY2FsZVgiLCJzY2FsZVkiLCJfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIiwicmVuZGVyVHJhbnNmb3JtIiwiX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIiLCJfdHJhbnNmb3JtUHJvcCIsIl90cmFuc2Zvcm1PcmlnaW5Qcm9wIiwiX3NhdmVTdHlsZSIsImlzTm90Q1NTIiwidGZtIiwiX2dldCIsInpPcmlnaW4iLCJ0cmFuc2Zvcm0iLCJzdmciLCJzdmdvIiwiX3JlbW92ZUluZGVwZW5kZW50VHJhbnNmb3JtcyIsInRyYW5zbGF0ZSIsInJlbW92ZVByb3BlcnR5IiwiX3JldmVydFN0eWxlIiwiX2dldFN0eWxlU2F2ZXIiLCJwcm9wZXJ0aWVzIiwic2F2ZXIiLCJzYXZlIiwiX3N1cHBvcnRzM0QiLCJfY3JlYXRlRWxlbWVudCIsIm5zIiwiY3JlYXRlRWxlbWVudE5TIiwiX2dldENvbXB1dGVkUHJvcGVydHkiLCJza2lwUHJlZml4RmFsbGJhY2siLCJjcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiX2NoZWNrUHJvcFByZWZpeCIsIl9wcmVmaXhlcyIsImVsZW1lbnQiLCJwcmVmZXJQcmVmaXgiLCJfaW5pdENvcmUiLCJkb2N1bWVudEVsZW1lbnQiLCJjc3NUZXh0IiwiX2dldFJlcGFyZW50ZWRDbG9uZUJCb3giLCJvd25lciIsIm93bmVyU1ZHRWxlbWVudCIsImNsb25lIiwiY2xvbmVOb2RlIiwiYmJveCIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsImdldEJCb3giLCJyZW1vdmVDaGlsZCIsIl9nZXRBdHRyaWJ1dGVGYWxsYmFja3MiLCJhdHRyaWJ1dGVzQXJyYXkiLCJoYXNBdHRyaWJ1dGUiLCJfZ2V0QkJveCIsImJvdW5kcyIsImNsb25lZCIsImVycm9yIiwid2lkdGgiLCJoZWlnaHQiLCJfaXNTVkciLCJnZXRDVE0iLCJwYXJlbnROb2RlIiwiX3JlbW92ZVByb3BlcnR5IiwiZmlyc3QyQ2hhcnMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJfYWRkTm9uVHdlZW5pbmdQVCIsImJlZ2lubmluZyIsIm9ubHlTZXRBdEVuZCIsIl9ub25Db252ZXJ0aWJsZVVuaXRzIiwiZGVnIiwicmFkIiwidHVybiIsIl9ub25TdGFuZGFyZExheW91dHMiLCJmbGV4IiwiX2NvbnZlcnRUb1VuaXQiLCJjdXJWYWx1ZSIsImN1clVuaXQiLCJob3Jpem9udGFsIiwiaXNSb290U1ZHIiwidGFnTmFtZSIsIm1lYXN1cmVQcm9wZXJ0eSIsInRvUGl4ZWxzIiwidG9QZXJjZW50IiwicHgiLCJpc1NWRyIsImJvZHkiLCJfcGFyc2VUcmFuc2Zvcm0iLCJvcmlnaW4iLCJfZmlyc3RUd29Pbmx5IiwiX3NwZWNpYWxQcm9wcyIsIl90d2VlbkNvbXBsZXhDU1NTdHJpbmciLCJzdGFydFZhbHVlcyIsInN0YXJ0VmFsdWUiLCJlbmRWYWx1ZSIsImVuZFVuaXQiLCJzdGFydFVuaXQiLCJlbmRWYWx1ZXMiLCJfa2V5d29yZFRvUGVyY2VudCIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwiX2NvbnZlcnRLZXl3b3Jkc1RvUGVyY2VudGFnZXMiLCJfcmVuZGVyQ2xlYXJQcm9wcyIsImNsZWFyVHJhbnNmb3JtcyIsInJvdGF0ZSIsImNsZWFyUHJvcHMiLCJfaWRlbnRpdHkyRE1hdHJpeCIsIl9yb3RhdGlvbmFsUHJvcGVydGllcyIsIl9pc051bGxUcmFuc2Zvcm0iLCJfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5IiwibWF0cml4U3RyaW5nIiwiX2dldE1hdHJpeCIsImZvcmNlMkQiLCJtYXRyaXgiLCJuZXh0U2libGluZyIsImFkZGVkVG9ET00iLCJiYXNlVmFsIiwiY29uc29saWRhdGUiLCJvZmZzZXRQYXJlbnQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJpbnNlcnRCZWZvcmUiLCJfYXBwbHlTVkdPcmlnaW4iLCJvcmlnaW5Jc0Fic29sdXRlIiwic21vb3RoIiwibWF0cml4QXJyYXkiLCJwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbyIsInhPcmlnaW5PbGQiLCJ4T3JpZ2luIiwieU9yaWdpbk9sZCIsInlPcmlnaW4iLCJ4T2Zmc2V0T2xkIiwieE9mZnNldCIsInlPZmZzZXRPbGQiLCJ5T2Zmc2V0IiwidHgiLCJ0eSIsIm9yaWdpblNwbGl0IiwiZGV0ZXJtaW5hbnQiLCJpbnZlcnRlZFNjYWxlWCIsInoiLCJyb3RhdGlvbiIsInJvdGF0aW9uWCIsInJvdGF0aW9uWSIsInNrZXdYIiwic2tld1kiLCJwZXJzcGVjdGl2ZSIsImFuZ2xlIiwiYTEyIiwiYTIyIiwidDEiLCJ0MiIsInQzIiwiYTEzIiwiYTIzIiwiYTMzIiwiYTQyIiwiYTQzIiwiYTMyIiwiZm9yY2VDU1MiLCJ4UGVyY2VudCIsIm9mZnNldFdpZHRoIiwieVBlcmNlbnQiLCJvZmZzZXRIZWlnaHQiLCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZSIsIl9yZW5kZXJTVkdUcmFuc2Zvcm1zIiwiX3JlbmRlckNTU1RyYW5zZm9ybXMiLCJfcmVuZGVyTm9uM0RUcmFuc2Zvcm1zIiwiX2FkZFB4VHJhbnNsYXRlIiwiX3plcm9EZWciLCJfemVyb1B4IiwiX2VuZFBhcmVudGhlc2lzIiwidHJhbnNmb3JtcyIsInVzZTNEIiwiYTExIiwiYTIxIiwidGFuIiwiX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4iLCJjYXAiLCJmaW5hbFZhbHVlIiwiZGlyZWN0aW9uIiwiX2Fzc2lnbiIsInNvdXJjZSIsIl9hZGRSYXdUcmFuc2Zvcm1QVHMiLCJzdGFydENhY2hlIiwiZXhjbHVkZSIsImVuZENhY2hlIiwic2lkZSIsIkNTU1BsdWdpbiIsInNwZWNpYWxQcm9wIiwicmVsYXRpdmUiLCJpc1RyYW5zZm9ybVJlbGF0ZWQiLCJ0cmFuc2Zvcm1Qcm9wVHdlZW4iLCJpbmxpbmVQcm9wcyIsInN0eWxlcyIsInZpc2liaWxpdHkiLCJwYXJzZVRyYW5zZm9ybSIsInNtb290aE9yaWdpbiIsImF1dG9Sb3VuZCIsImNoZWNrUHJlZml4IiwiZ2V0U3R5bGVTYXZlciIsInBvc2l0aW9uQW5kU2NhbGUiLCJvdGhlcnMiLCJhbGwiLCJnc2FwV2l0aENTUyIsIlR3ZWVuTWF4V2l0aENTUyIsImRlZmF1bHQiLCJkZWZpbmVQcm9wZXJ0eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/dist/gsap.js\n");

/***/ }),

/***/ "./node_modules/gsap/utils/strings.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/utils/strings.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   emojiExp: () => (/* binding */ emojiExp),\n/* harmony export */   emojiSafeSplit: () => (/* binding */ emojiSafeSplit),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   splitInnerHTML: () => (/* binding */ splitInnerHTML)\n/* harmony export */ });\n/*!\n * strings: 3.13.0\n * https://gsap.com\n *\n * Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license\n * @author: Jack Doyle, jack@greensock.com\n*/ /* eslint-disable */ var _trimExp = /(?:^\\s+|\\s+$)/g;\nvar emojiExp = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF](?:[\\u200D\\uFE0F][\\uD800-\\uDBFF][\\uDC00-\\uDFFF]){2,}|\\uD83D\\uDC69(?:\\u200D(?:(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67|(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC69\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2642\\u2640]\\uFE0F|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDD27\\uDCBC\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC6F\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3C-\\uDD3E\\uDDD6-\\uDDDF])\\u200D[\\u2640\\u2642]\\uFE0F|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|(?:\\u26F9|\\uD83C[\\uDFCC\\uDFCB]|\\uD83D\\uDD75)(?:\\uFE0F\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642])\\uFE0F|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC69\\u200D[\\u2695\\u2696\\u2708]|\\uD83D\\uDC68(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708]))\\uFE0F|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83D\\uDC69\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92])|(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]))|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDD1-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\u200D(?:(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC67|(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D)?\\uD83D\\uDC66)|\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC69\\uDC6E\\uDC70-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3D\\uDD3E\\uDDD1-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])?|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDEEB\\uDEEC\\uDEF4-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEF8]|\\uD83E[\\uDD10-\\uDD3A\\uDD3C-\\uDD3E\\uDD40-\\uDD45\\uDD47-\\uDD4C\\uDD50-\\uDD6B\\uDD80-\\uDD97\\uDDC0\\uDDD0-\\uDDE6])\\uFE0F)/;\nfunction getText(e) {\n    var type = e.nodeType, result = \"\";\n    if (type === 1 || type === 9 || type === 11) {\n        if (typeof e.textContent === \"string\") {\n            return e.textContent;\n        } else {\n            for(e = e.firstChild; e; e = e.nextSibling){\n                result += getText(e);\n            }\n        }\n    } else if (type === 3 || type === 4) {\n        return e.nodeValue;\n    }\n    return result;\n}\nfunction splitInnerHTML(element, delimiter, trim, preserveSpaces, unescapedCharCodes) {\n    var node = element.firstChild, result = [], s;\n    while(node){\n        if (node.nodeType === 3) {\n            s = (node.nodeValue + \"\").replace(/^\\n+/g, \"\");\n            if (!preserveSpaces) {\n                s = s.replace(/\\s+/g, \" \");\n            }\n            result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces, unescapedCharCodes));\n        } else if ((node.nodeName + \"\").toLowerCase() === \"br\") {\n            result[result.length - 1] += \"<br>\";\n        } else {\n            result.push(node.outerHTML);\n        }\n        node = node.nextSibling;\n    }\n    if (!unescapedCharCodes) {\n        s = result.length;\n        while(s--){\n            result[s] === \"&\" && result.splice(s, 1, \"&amp;\");\n        }\n    }\n    return result;\n}\n/*\n//smaller kb version that only handles the simpler emoji's, which is often perfectly adequate.\n\nlet _emoji = \"[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2694-\\u2697]|\\uD83E[\\uDD10-\\uDD5D]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]\",\n\t_emojiExp = new RegExp(_emoji),\n\t_emojiAndCharsExp = new RegExp(_emoji + \"|.\", \"g\"),\n\t_emojiSafeSplit = (text, delimiter, trim) => {\n\t\tif (trim) {\n\t\t\ttext = text.replace(_trimExp, \"\");\n\t\t}\n\t\treturn ((delimiter === \"\" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || \"\");\n\t};\n */ function emojiSafeSplit(text, delimiter, trim, preserveSpaces, unescapedCharCodes) {\n    text += \"\"; // make sure it's cast as a string. Someone may pass in a number.\n    trim && (text = text.trim ? text.trim() : text.replace(_trimExp, \"\")); // IE9 and earlier compatibility\n    if (delimiter && delimiter !== \"\") {\n        return text.replace(/>/g, \"&gt;\").replace(/</g, \"&lt;\").split(delimiter);\n    }\n    var result = [], l = text.length, i = 0, j, character;\n    for(; i < l; i++){\n        character = text.charAt(i);\n        if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {\n            //special emoji characters use 2 or 4 unicode characters that we must keep together.\n            j = ((text.substr(i, 12).split(emojiExp) || [])[1] || \"\").length || 2;\n            character = text.substr(i, j);\n            result.emoji = 1;\n            i += j - 1;\n        }\n        result.push(unescapedCharCodes ? character : character === \">\" ? \"&gt;\" : character === \"<\" ? \"&lt;\" : preserveSpaces && character === \" \" && (text.charAt(i - 1) === \" \" || text.charAt(i + 1) === \" \") ? \"&nbsp;\" : character);\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RjtZQUNwRkMsSUFBSSxDQUFDLENBQUNKLEtBQUtRLE1BQU0sQ0FBQ0wsR0FBRyxJQUFJRixLQUFLLENBQUM1QixhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFDLEVBQUd3QixNQUFNLElBQUk7WUFDcEVRLFlBQVlMLEtBQUtRLE1BQU0sQ0FBQ0wsR0FBR0M7WUFDM0IxQixPQUFPK0IsS0FBSyxHQUFHO1lBQ2ZOLEtBQUtDLElBQUk7UUFDWDtRQUVBMUIsT0FBT2MsSUFBSSxDQUFDSixxQkFBcUJpQixZQUFZQSxjQUFjLE1BQU0sU0FBU0EsY0FBYyxNQUFNLFNBQVNsQixrQkFBa0JrQixjQUFjLE9BQVFMLENBQUFBLEtBQUtNLE1BQU0sQ0FBQ0gsSUFBSSxPQUFPLE9BQU9ILEtBQUtNLE1BQU0sQ0FBQ0gsSUFBSSxPQUFPLEdBQUUsSUFBSyxXQUFXRTtJQUN4TjtJQUVBLE9BQU8zQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW50ZWdyYXRpb24tbW9kdWwtYXBhcmF0LWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvc3RyaW5ncy5qcz8yZmIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogc3RyaW5nczogMy4xMy4wXG4gKiBodHRwczovL2dzYXAuY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyNSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9nc2FwLmNvbS9zdGFuZGFyZC1saWNlbnNlXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX3RyaW1FeHAgPSAvKD86Xlxccyt8XFxzKyQpL2c7XG5leHBvcnQgdmFyIGVtb2ppRXhwID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKD86W1xcdTIwMERcXHVGRTBGXVtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0pezIsfXxcXHVEODNEXFx1REM2OSg/OlxcdTIwMEQoPzooPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3fCg/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjYpfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1RDgzQ1xcdURGMDh8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MlxcdTI2NDBdXFx1RkUwRnxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVERDI3XFx1RENCQ1xcdUREMkNcXHVERTgwXFx1REU5Ml0pfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzZGXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0MtXFx1REQzRVxcdURERDYtXFx1RERERl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGfFxcdUQ4M0NcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RDgzQ1xcdURERjZcXHVEODNDXFx1RERFNnxcXHVEODNDXFx1RERGNFxcdUQ4M0NcXHVEREYyfFxcdUQ4M0NcXHVEREU5KD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXSl8XFx1RDgzQ1xcdURERjcoPzpcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXSl8XFx1RDgzQ1xcdURERTgoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdKXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQ1xcdURGQ0JdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUZFMEZcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXwoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml0pXFx1RkUwRnwoPzpcXHVEODNEXFx1REM0MVxcdUZFMEZcXHUyMDBEXFx1RDgzRFxcdURERTh8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0RcXHVEQzY4KD86KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pKVxcdUZFMEZ8XFx1RDgzQ1xcdURERjIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdKXxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKXxcXHVEODNDXFx1RERGMSg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXSl8XFx1RDgzQ1xcdURERUYoPzpcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdKXxcXHVEODNDXFx1RERFRCg/OlxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXSl8XFx1RDgzQ1xcdURERUIoPzpcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN10pfFsjXFwqMC05XVxcdUZFMEZcXHUyMEUzfFxcdUQ4M0NcXHVEREU3KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFNig/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREYyXFx1RERGNFxcdURERjYtXFx1RERGQVxcdURERkNcXHVEREZEXFx1RERGRl0pfFxcdUQ4M0NcXHVEREZGKD86XFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdKXxcXHVEODNDXFx1RERGNSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERkIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdKXxcXHVEODNDXFx1RERGMyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXSl8XFx1RDgzQ1xcdURGRjRcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczfFxcdURCNDBcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQjQwXFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjcpXFx1REI0MFxcdURDN0Z8XFx1RDgzRFxcdURDNjgoPzpcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNEXFx1REM2OHwoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnwoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pfCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pKXxcXHVEODNDXFx1RERGOCg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYwKD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREZFKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVFKD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUFcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjldKXxcXHVEODNDXFx1RERGOSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREZBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUEoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXSl8XFx1RDgzQ1xcdURERkMoPzpcXHVEODNDW1xcdURERUJcXHVEREY4XSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzJcXHVERkM3XXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzcwXFx1REM3MlxcdURDNzQtXFx1REM3NlxcdURDNzhcXHVEQzdDXFx1REM4M1xcdURDODVcXHVEQ0FBXFx1REQ3NFxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTRDXFx1REU0RlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM2XFx1REREMS1cXHVEREQ1XSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY4KD86XFx1MjAwRCg/Oig/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3fCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2KXxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjZGOVxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMi1cXHVERkM0XFx1REZDN1xcdURGQ0EtXFx1REZDQ118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjYtXFx1REM2OVxcdURDNkVcXHVEQzcwLVxcdURDNzhcXHVEQzdDXFx1REM4MS1cXHVEQzgzXFx1REM4NS1cXHVEQzg3XFx1RENBQVxcdURENzRcXHVERDc1XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNDUtXFx1REU0N1xcdURFNEItXFx1REU0RlxcdURFQTNcXHVERUI0LVxcdURFQjZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMjZcXHVERDMwLVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDEtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98KD86W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcwQVxcdTI3MEJcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjkzXFx1REZBMC1cXHVERkNBXFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGNFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDM0VcXHVEQzQwXFx1REM0Mi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ3QVxcdUREOTVcXHVERDk2XFx1RERBNFxcdURERkItXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0NcXHVERUQwLVxcdURFRDJcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGOF18XFx1RDgzRVtcXHVERDEwLVxcdUREM0FcXHVERDNDLVxcdUREM0VcXHVERDQwLVxcdURENDVcXHVERDQ3LVxcdURENENcXHVERDUwLVxcdURENkJcXHVERDgwLVxcdUREOTdcXHVEREMwXFx1REREMC1cXHVEREU2XSl8KD86WyNcXCowLTlcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjFEXFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RlxcdTI2OTItXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkM4XFx1MjZDRVxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RDRcXHUyNkU5XFx1MjZFQVxcdTI2RjAtXFx1MjZGNVxcdTI2RjctXFx1MjZGQVxcdTI2RkRcXHUyNzAyXFx1MjcwNVxcdTI3MDgtXFx1MjcwRFxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2M1xcdTI3NjRcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjFcXHVERjI0LVxcdURGOTNcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUUtXFx1REZGMFxcdURGRjMtXFx1REZGNVxcdURGRjctXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDRkRcXHVEQ0ZGLVxcdUREM0RcXHVERDQ5LVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDZGXFx1REQ3MFxcdURENzMtXFx1REQ3QVxcdUREODdcXHVERDhBLVxcdUREOERcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkEtXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0ItXFx1REVEMlxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUVCXFx1REVFQ1xcdURFRjBcXHVERUYzLVxcdURFRjhdfFxcdUQ4M0VbXFx1REQxMC1cXHVERDNBXFx1REQzQy1cXHVERDNFXFx1REQ0MC1cXHVERDQ1XFx1REQ0Ny1cXHVERDRDXFx1REQ1MC1cXHVERDZCXFx1REQ4MC1cXHVERDk3XFx1RERDMFxcdURERDAtXFx1RERFNl0pXFx1RkUwRikvO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHQoZSkge1xuICB2YXIgdHlwZSA9IGUubm9kZVR5cGUsXG4gICAgICByZXN1bHQgPSBcIlwiO1xuXG4gIGlmICh0eXBlID09PSAxIHx8IHR5cGUgPT09IDkgfHwgdHlwZSA9PT0gMTEpIHtcbiAgICBpZiAodHlwZW9mIGUudGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBlLnRleHRDb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGUgPSBlLmZpcnN0Q2hpbGQ7IGU7IGUgPSBlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHJlc3VsdCArPSBnZXRUZXh0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcbiAgICByZXR1cm4gZS5ub2RlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0SW5uZXJIVE1MKGVsZW1lbnQsIGRlbGltaXRlciwgdHJpbSwgcHJlc2VydmVTcGFjZXMsIHVuZXNjYXBlZENoYXJDb2Rlcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgcztcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBzID0gKG5vZGUubm9kZVZhbHVlICsgXCJcIikucmVwbGFjZSgvXlxcbisvZywgXCJcIik7XG5cbiAgICAgIGlmICghcHJlc2VydmVTcGFjZXMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgZW1vamlTYWZlU3BsaXQocywgZGVsaW1pdGVyLCB0cmltLCBwcmVzZXJ2ZVNwYWNlcywgdW5lc2NhcGVkQ2hhckNvZGVzKSk7XG4gICAgfSBlbHNlIGlmICgobm9kZS5ub2RlTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwiYnJcIikge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSArPSBcIjxicj5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobm9kZS5vdXRlckhUTUwpO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgaWYgKCF1bmVzY2FwZWRDaGFyQ29kZXMpIHtcbiAgICBzID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChzLS0pIHtcbiAgICAgIHJlc3VsdFtzXSA9PT0gXCImXCIgJiYgcmVzdWx0LnNwbGljZShzLCAxLCBcIiZhbXA7XCIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKlxuLy9zbWFsbGVyIGtiIHZlcnNpb24gdGhhdCBvbmx5IGhhbmRsZXMgdGhlIHNpbXBsZXIgZW1vamkncywgd2hpY2ggaXMgb2Z0ZW4gcGVyZmVjdGx5IGFkZXF1YXRlLlxuXG5sZXQgX2Vtb2ppID0gXCJbXFx1RTAwMC1cXHVGOEZGXXxcXHVEODNDW1xcdURDMDAtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURGRkZdfFtcXHUyNjk0LVxcdTI2OTddfFxcdUQ4M0VbXFx1REQxMC1cXHVERDVEXXxbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdXCIsXG5cdF9lbW9qaUV4cCA9IG5ldyBSZWdFeHAoX2Vtb2ppKSxcblx0X2Vtb2ppQW5kQ2hhcnNFeHAgPSBuZXcgUmVnRXhwKF9lbW9qaSArIFwifC5cIiwgXCJnXCIpLFxuXHRfZW1vamlTYWZlU3BsaXQgPSAodGV4dCwgZGVsaW1pdGVyLCB0cmltKSA9PiB7XG5cdFx0aWYgKHRyaW0pIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoX3RyaW1FeHAsIFwiXCIpO1xuXHRcdH1cblx0XHRyZXR1cm4gKChkZWxpbWl0ZXIgPT09IFwiXCIgfHwgIWRlbGltaXRlcikgJiYgX2Vtb2ppRXhwLnRlc3QodGV4dCkpID8gdGV4dC5tYXRjaChfZW1vamlBbmRDaGFyc0V4cCkgOiB0ZXh0LnNwbGl0KGRlbGltaXRlciB8fCBcIlwiKTtcblx0fTtcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1vamlTYWZlU3BsaXQodGV4dCwgZGVsaW1pdGVyLCB0cmltLCBwcmVzZXJ2ZVNwYWNlcywgdW5lc2NhcGVkQ2hhckNvZGVzKSB7XG4gIHRleHQgKz0gXCJcIjsgLy8gbWFrZSBzdXJlIGl0J3MgY2FzdCBhcyBhIHN0cmluZy4gU29tZW9uZSBtYXkgcGFzcyBpbiBhIG51bWJlci5cblxuICB0cmltICYmICh0ZXh0ID0gdGV4dC50cmltID8gdGV4dC50cmltKCkgOiB0ZXh0LnJlcGxhY2UoX3RyaW1FeHAsIFwiXCIpKTsgLy8gSUU5IGFuZCBlYXJsaWVyIGNvbXBhdGliaWxpdHlcblxuICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlciAhPT0gXCJcIikge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnNwbGl0KGRlbGltaXRlcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBsID0gdGV4dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBjaGFyYWN0ZXI7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGFyYWN0ZXIgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgIGlmIChjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA+PSAweEQ4MDAgJiYgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMHhEQkZGIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPj0gMHhGRTAwICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPD0gMHhGRTBGKSB7XG4gICAgICAvL3NwZWNpYWwgZW1vamkgY2hhcmFjdGVycyB1c2UgMiBvciA0IHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IHdlIG11c3Qga2VlcCB0b2dldGhlci5cbiAgICAgIGogPSAoKHRleHQuc3Vic3RyKGksIDEyKS5zcGxpdChlbW9qaUV4cCkgfHwgW10pWzFdIHx8IFwiXCIpLmxlbmd0aCB8fCAyO1xuICAgICAgY2hhcmFjdGVyID0gdGV4dC5zdWJzdHIoaSwgaik7XG4gICAgICByZXN1bHQuZW1vamkgPSAxO1xuICAgICAgaSArPSBqIC0gMTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaCh1bmVzY2FwZWRDaGFyQ29kZXMgPyBjaGFyYWN0ZXIgOiBjaGFyYWN0ZXIgPT09IFwiPlwiID8gXCImZ3Q7XCIgOiBjaGFyYWN0ZXIgPT09IFwiPFwiID8gXCImbHQ7XCIgOiBwcmVzZXJ2ZVNwYWNlcyAmJiBjaGFyYWN0ZXIgPT09IFwiIFwiICYmICh0ZXh0LmNoYXJBdChpIC0gMSkgPT09IFwiIFwiIHx8IHRleHQuY2hhckF0KGkgKyAxKSA9PT0gXCIgXCIpID8gXCImbmJzcDtcIiA6IGNoYXJhY3Rlcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSJdLCJuYW1lcyI6WyJfdHJpbUV4cCIsImVtb2ppRXhwIiwiZ2V0VGV4dCIsImUiLCJ0eXBlIiwibm9kZVR5cGUiLCJyZXN1bHQiLCJ0ZXh0Q29udGVudCIsImZpcnN0Q2hpbGQiLCJuZXh0U2libGluZyIsIm5vZGVWYWx1ZSIsInNwbGl0SW5uZXJIVE1MIiwiZWxlbWVudCIsImRlbGltaXRlciIsInRyaW0iLCJwcmVzZXJ2ZVNwYWNlcyIsInVuZXNjYXBlZENoYXJDb2RlcyIsIm5vZGUiLCJzIiwicmVwbGFjZSIsInB1c2giLCJhcHBseSIsImVtb2ppU2FmZVNwbGl0Iiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImxlbmd0aCIsIm91dGVySFRNTCIsInNwbGljZSIsInRleHQiLCJzcGxpdCIsImwiLCJpIiwiaiIsImNoYXJhY3RlciIsImNoYXJBdCIsImNoYXJDb2RlQXQiLCJzdWJzdHIiLCJlbW9qaSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/gsap/utils/strings.js\n");

/***/ })

};
;